<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr::type Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1type.html">type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classrttr_1_1type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::type Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classrttr_1_1type.html">type</a> class holds the type information for any arbitrary object.  
 <a href="classrttr_1_1type.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a695c388f245ae5f550b8ef6bb343a800"><td class="memItemLeft" align="right" valign="top">typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a695c388f245ae5f550b8ef6bb343a800">type_id</a></td></tr>
<tr class="separator:a695c388f245ae5f550b8ef6bb343a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afec6296ac7c1d21cda157b9cbbdf3af4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afec6296ac7c1d21cda157b9cbbdf3af4">type</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:afec6296ac7c1d21cda157b9cbbdf3af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a type to another one.  <a href="classrttr_1_1type.html#afec6296ac7c1d21cda157b9cbbdf3af4">More...</a><br /></td></tr>
<tr class="separator:afec6296ac7c1d21cda157b9cbbdf3af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44572a03514d83035580f516ebaf4e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ad44572a03514d83035580f516ebaf4e1">create</a> (std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args=std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;()) const</td></tr>
<tr class="memdesc:ad44572a03514d83035580f516ebaf4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the current type, with the given arguments <code>args</code> for the constructor.  <a href="classrttr_1_1type.html#ad44572a03514d83035580f516ebaf4e1">More...</a><br /></td></tr>
<tr class="separator:ad44572a03514d83035580f516ebaf4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bc44604dae75f4368428afabf364ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a33bc44604dae75f4368428afabf364ac">destroy</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a33bc44604dae75f4368428afabf364ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the contained object in the variant <code>obj</code>.  <a href="classrttr_1_1type.html#a33bc44604dae75f4368428afabf364ac">More...</a><br /></td></tr>
<tr class="separator:a33bc44604dae75f4368428afabf364ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9b001581881e62aaf794f456e405e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aed9b001581881e62aaf794f456e405e7">get_base_classes</a> () const noexcept</td></tr>
<tr class="memdesc:aed9b001581881e62aaf794f456e405e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all base classes of this type.  <a href="classrttr_1_1type.html#aed9b001581881e62aaf794f456e405e7">More...</a><br /></td></tr>
<tr class="separator:aed9b001581881e62aaf794f456e405e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ed385e76752e7c02ffd9bf5a0ae410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1constructor.html">constructor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae1ed385e76752e7c02ffd9bf5a0ae410">get_constructor</a> (const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;params=std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;()) const noexcept</td></tr>
<tr class="memdesc:ae1ed385e76752e7c02ffd9bf5a0ae410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a public constructor whose parameters match the types in the specified list.  <a href="classrttr_1_1type.html#ae1ed385e76752e7c02ffd9bf5a0ae410">More...</a><br /></td></tr>
<tr class="separator:ae1ed385e76752e7c02ffd9bf5a0ae410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273b0ac03043a9008f4f63c4e8246587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1constructor.html">constructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a273b0ac03043a9008f4f63c4e8246587">get_constructors</a> () const noexcept</td></tr>
<tr class="memdesc:a273b0ac03043a9008f4f63c4e8246587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered <em>public</em> constructors for this type.  <a href="classrttr_1_1type.html#a273b0ac03043a9008f4f63c4e8246587">More...</a><br /></td></tr>
<tr class="separator:a273b0ac03043a9008f4f63c4e8246587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6054d1af85fcf5d4fb30cc57ef7f325e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1constructor.html">constructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a6054d1af85fcf5d4fb30cc57ef7f325e">get_constructors</a> (filter_items filter) const noexcept</td></tr>
<tr class="memdesc:a6054d1af85fcf5d4fb30cc57ef7f325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered constructors for this type, based on the given <code>filter</code>.  <a href="classrttr_1_1type.html#a6054d1af85fcf5d4fb30cc57ef7f325e">More...</a><br /></td></tr>
<tr class="separator:a6054d1af85fcf5d4fb30cc57ef7f325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579391b0b9fdb6d4d001efd1c409bad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a579391b0b9fdb6d4d001efd1c409bad7">get_derived_classes</a> () const noexcept</td></tr>
<tr class="memdesc:a579391b0b9fdb6d4d001efd1c409bad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all derived classes of this type.  <a href="classrttr_1_1type.html#a579391b0b9fdb6d4d001efd1c409bad7">More...</a><br /></td></tr>
<tr class="separator:a579391b0b9fdb6d4d001efd1c409bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d900648f71d11873896f58b1f9a3ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1destructor.html">destructor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a12d900648f71d11873896f58b1f9a3ac">get_destructor</a> () const noexcept</td></tr>
<tr class="memdesc:a12d900648f71d11873896f58b1f9a3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding destructor for this type.  <a href="classrttr_1_1type.html#a12d900648f71d11873896f58b1f9a3ac">More...</a><br /></td></tr>
<tr class="separator:a12d900648f71d11873896f58b1f9a3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b0e3e85de99df74f956a84b463f10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1enumeration.html">enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aa0b0e3e85de99df74f956a84b463f10b">get_enumeration</a> () const noexcept</td></tr>
<tr class="memdesc:aa0b0e3e85de99df74f956a84b463f10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator if this type is an enum type; otherwise the returned value is <a class="el" href="classrttr_1_1enumeration.html#a465644dd0af25f6d55cd17704c4e6137">not valid</a>.  <a href="classrttr_1_1type.html#aa0b0e3e85de99df74f956a84b463f10b">More...</a><br /></td></tr>
<tr class="separator:aa0b0e3e85de99df74f956a84b463f10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0fee08c9ec342fbfb8a1f9ecf0095a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html#a695c388f245ae5f550b8ef6bb343a800">type_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a9f0fee08c9ec342fbfb8a1f9ecf0095a">get_id</a> () const noexcept</td></tr>
<tr class="memdesc:a9f0fee08c9ec342fbfb8a1f9ecf0095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the id of this type.  <a href="classrttr_1_1type.html#a9f0fee08c9ec342fbfb8a1f9ecf0095a">More...</a><br /></td></tr>
<tr class="separator:a9f0fee08c9ec342fbfb8a1f9ecf0095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecd54b252a3957e52c2eaa41e18f4cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aeecd54b252a3957e52c2eaa41e18f4cd">get_metadata</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;key) const</td></tr>
<tr class="memdesc:aeecd54b252a3957e52c2eaa41e18f4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta data for the given key <code>key</code>.  <a href="classrttr_1_1type.html#aeecd54b252a3957e52c2eaa41e18f4cd">More...</a><br /></td></tr>
<tr class="separator:aeecd54b252a3957e52c2eaa41e18f4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d31b84c050f5b22509c16d0379fe0c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4d31b84c050f5b22509c16d0379fe0c7">get_method</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) const noexcept</td></tr>
<tr class="memdesc:a4d31b84c050f5b22509c16d0379fe0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a method with the name <code>name</code>.  <a href="classrttr_1_1type.html#a4d31b84c050f5b22509c16d0379fe0c7">More...</a><br /></td></tr>
<tr class="separator:a4d31b84c050f5b22509c16d0379fe0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9ba82f9564a749547fd5562d7cc40a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a1e9ba82f9564a749547fd5562d7cc40a">get_method</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;<a class="el" href="structrttr_1_1type__list.html">type_list</a>) const noexcept</td></tr>
<tr class="memdesc:a1e9ba82f9564a749547fd5562d7cc40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a method with the name <code>name</code> which match the given parameter type list <code><a class="el" href="structrttr_1_1type__list.html" title="Contains a list of template parameters.">type_list</a></code>.  <a href="classrttr_1_1type.html#a1e9ba82f9564a749547fd5562d7cc40a">More...</a><br /></td></tr>
<tr class="separator:a1e9ba82f9564a749547fd5562d7cc40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ffced2826ff08f2a761acbeb133ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a67ffced2826ff08f2a761acbeb133ae9">get_methods</a> () const noexcept</td></tr>
<tr class="memdesc:a67ffced2826ff08f2a761acbeb133ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered <em>public</em> methods for this type and all its base classes.  <a href="classrttr_1_1type.html#a67ffced2826ff08f2a761acbeb133ae9">More...</a><br /></td></tr>
<tr class="separator:a67ffced2826ff08f2a761acbeb133ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0181dd63628275d64819334ff7272324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0181dd63628275d64819334ff7272324">get_methods</a> (filter_items filter) const noexcept</td></tr>
<tr class="memdesc:a0181dd63628275d64819334ff7272324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered methods for this type, based on the given <code>filter</code>.  <a href="classrttr_1_1type.html#a0181dd63628275d64819334ff7272324">More...</a><br /></td></tr>
<tr class="separator:a0181dd63628275d64819334ff7272324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d519457c68429ef2316067d1cf6700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a16d519457c68429ef2316067d1cf6700">get_name</a> () const noexcept</td></tr>
<tr class="memdesc:a16d519457c68429ef2316067d1cf6700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique and human-readable name of the type.  <a href="classrttr_1_1type.html#a16d519457c68429ef2316067d1cf6700">More...</a><br /></td></tr>
<tr class="separator:a16d519457c68429ef2316067d1cf6700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d2837c650a639b9aab9bd6e580dc8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af4d2837c650a639b9aab9bd6e580dc8a">get_properties</a> () const noexcept</td></tr>
<tr class="memdesc:af4d2837c650a639b9aab9bd6e580dc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered <em>public</em> properties for this type and all its base classes.  <a href="classrttr_1_1type.html#af4d2837c650a639b9aab9bd6e580dc8a">More...</a><br /></td></tr>
<tr class="separator:af4d2837c650a639b9aab9bd6e580dc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77289c46150e0be761bc2168a56e2ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ad77289c46150e0be761bc2168a56e2ae">get_properties</a> (filter_items filter) const noexcept</td></tr>
<tr class="memdesc:ad77289c46150e0be761bc2168a56e2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered properties for this type, based on the given <code>filter</code>.  <a href="classrttr_1_1type.html#ad77289c46150e0be761bc2168a56e2ae">More...</a><br /></td></tr>
<tr class="separator:ad77289c46150e0be761bc2168a56e2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53c4df812c270f3f74b77210bc6a926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1property.html">property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae53c4df812c270f3f74b77210bc6a926">get_property</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) const noexcept</td></tr>
<tr class="memdesc:ae53c4df812c270f3f74b77210bc6a926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a property with the name <code>name</code>.  <a href="classrttr_1_1type.html#ae53c4df812c270f3f74b77210bc6a926">More...</a><br /></td></tr>
<tr class="separator:ae53c4df812c270f3f74b77210bc6a926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3010aa9577570ea86078b2ce2b2f8677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a3010aa9577570ea86078b2ce2b2f8677">get_property_value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, <a class="el" href="classrttr_1_1instance.html">instance</a> obj) const</td></tr>
<tr class="memdesc:a3010aa9577570ea86078b2ce2b2f8677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property value of property named <code>name</code> from the instance <code>obj</code>.  <a href="classrttr_1_1type.html#a3010aa9577570ea86078b2ce2b2f8677">More...</a><br /></td></tr>
<tr class="separator:a3010aa9577570ea86078b2ce2b2f8677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e0f91eaae62ff7f44419fd94836a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a50e0f91eaae62ff7f44419fd94836a1c">get_raw_type</a> () const noexcept</td></tr>
<tr class="memdesc:a50e0f91eaae62ff7f44419fd94836a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object which represent the raw type.  <a href="classrttr_1_1type.html#a50e0f91eaae62ff7f44419fd94836a1c">More...</a><br /></td></tr>
<tr class="separator:a50e0f91eaae62ff7f44419fd94836a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae3874c7987835639df28055e0b9708"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aaae3874c7987835639df28055e0b9708">get_sizeof</a> () const noexcept</td></tr>
<tr class="memdesc:aaae3874c7987835639df28055e0b9708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the object representation of the current type (i.e.  <a href="classrttr_1_1type.html#aaae3874c7987835639df28055e0b9708">More...</a><br /></td></tr>
<tr class="separator:aaae3874c7987835639df28055e0b9708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f58cffb2a57754cd6d25f71022028fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a6f58cffb2a57754cd6d25f71022028fd">get_template_arguments</a> () const noexcept</td></tr>
<tr class="memdesc:a6f58cffb2a57754cd6d25f71022028fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of type objects that represents the template arguments.  <a href="classrttr_1_1type.html#a6f58cffb2a57754cd6d25f71022028fd">More...</a><br /></td></tr>
<tr class="separator:a6f58cffb2a57754cd6d25f71022028fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6af1ac4dd7e107cdfabb1050546724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">get_wrapped_type</a> () const noexcept</td></tr>
<tr class="memdesc:a9b6af1ac4dd7e107cdfabb1050546724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object which represent the wrapped type.  <a href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">More...</a><br /></td></tr>
<tr class="separator:a9b6af1ac4dd7e107cdfabb1050546724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7329cac11337f4022d7d10eebe80d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afc7329cac11337f4022d7d10eebe80d3">invoke</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, <a class="el" href="classrttr_1_1instance.html">instance</a> obj, std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args) const</td></tr>
<tr class="memdesc:afc7329cac11337f4022d7d10eebe80d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>.  <a href="classrttr_1_1type.html#afc7329cac11337f4022d7d10eebe80d3">More...</a><br /></td></tr>
<tr class="separator:afc7329cac11337f4022d7d10eebe80d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac53b079eca2d784a126ad6a3b13b9e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">is_arithmetic</a> () const noexcept</td></tr>
<tr class="memdesc:aac53b079eca2d784a126ad6a3b13b9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an arithmetic type.  <a href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">More...</a><br /></td></tr>
<tr class="separator:aac53b079eca2d784a126ad6a3b13b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ecc638e72ac4a5b43025bd0ddf5eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a85ecc638e72ac4a5b43025bd0ddf5eb6">is_array</a> () const noexcept</td></tr>
<tr class="memdesc:a85ecc638e72ac4a5b43025bd0ddf5eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> whether the given type represents an array.  <a href="classrttr_1_1type.html#a85ecc638e72ac4a5b43025bd0ddf5eb6">More...</a><br /></td></tr>
<tr class="separator:a85ecc638e72ac4a5b43025bd0ddf5eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d23b7e6159ef21e64b6245cfe7d59b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a95d23b7e6159ef21e64b6245cfe7d59b">is_associative_container</a> () const noexcept</td></tr>
<tr class="memdesc:a95d23b7e6159ef21e64b6245cfe7d59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an <a href="https://en.wikipedia.org/wiki/Associative_containers" target="_blank">associative container</a>.  <a href="classrttr_1_1type.html#a95d23b7e6159ef21e64b6245cfe7d59b">More...</a><br /></td></tr>
<tr class="separator:a95d23b7e6159ef21e64b6245cfe7d59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef0cb9177ae3a786297f41b50c8f8c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ef0cb9177ae3a786297f41b50c8f8c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a7ef0cb9177ae3a786297f41b50c8f8c6">is_base_of</a> () const noexcept</td></tr>
<tr class="memdesc:a7ef0cb9177ae3a786297f41b50c8f8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is the base class from the given type <em>T</em>, otherwise false.  <a href="classrttr_1_1type.html#a7ef0cb9177ae3a786297f41b50c8f8c6">More...</a><br /></td></tr>
<tr class="separator:a7ef0cb9177ae3a786297f41b50c8f8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f75e13ced3ba2cfd22a22ea70042895"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a9f75e13ced3ba2cfd22a22ea70042895">is_base_of</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a9f75e13ced3ba2cfd22a22ea70042895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is the base class from the given type <code>other</code>, otherwise false.  <a href="classrttr_1_1type.html#a9f75e13ced3ba2cfd22a22ea70042895">More...</a><br /></td></tr>
<tr class="separator:a9f75e13ced3ba2cfd22a22ea70042895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34296e0290e93317c34118945c0e2db9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a34296e0290e93317c34118945c0e2db9">is_class</a> () const noexcept</td></tr>
<tr class="memdesc:a34296e0290e93317c34118945c0e2db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type is class; that is not an atomic type or a method.  <a href="classrttr_1_1type.html#a34296e0290e93317c34118945c0e2db9">More...</a><br /></td></tr>
<tr class="separator:a34296e0290e93317c34118945c0e2db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb6d74e9baac6dc6cb3dddeb1a96611"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4eb6d74e9baac6dc6cb3dddeb1a96611"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4eb6d74e9baac6dc6cb3dddeb1a96611">is_derived_from</a> () const noexcept</td></tr>
<tr class="memdesc:a4eb6d74e9baac6dc6cb3dddeb1a96611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is derived from the given type <em>T</em>, otherwise false.  <a href="classrttr_1_1type.html#a4eb6d74e9baac6dc6cb3dddeb1a96611">More...</a><br /></td></tr>
<tr class="separator:a4eb6d74e9baac6dc6cb3dddeb1a96611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8484b0779404e55c3116ea5a1b894fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ac8484b0779404e55c3116ea5a1b894fa">is_derived_from</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ac8484b0779404e55c3116ea5a1b894fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is derived from the given type <code>other</code>, otherwise false.  <a href="classrttr_1_1type.html#ac8484b0779404e55c3116ea5a1b894fa">More...</a><br /></td></tr>
<tr class="separator:ac8484b0779404e55c3116ea5a1b894fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e41c2c736ed5ce3198a84da9af4d6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a60e41c2c736ed5ce3198a84da9af4d6d">is_enumeration</a> () const noexcept</td></tr>
<tr class="memdesc:a60e41c2c736ed5ce3198a84da9af4d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an enumeration.  <a href="classrttr_1_1type.html#a60e41c2c736ed5ce3198a84da9af4d6d">More...</a><br /></td></tr>
<tr class="separator:a60e41c2c736ed5ce3198a84da9af4d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95eb802279180d8a3757532909ec8fef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a95eb802279180d8a3757532909ec8fef">is_function_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:a95eb802279180d8a3757532909ec8fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a function e.g.  <a href="classrttr_1_1type.html#a95eb802279180d8a3757532909ec8fef">More...</a><br /></td></tr>
<tr class="separator:a95eb802279180d8a3757532909ec8fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cb22627f1b5197931ee17c209e6606"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a17cb22627f1b5197931ee17c209e6606">is_member_function_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:a17cb22627f1b5197931ee17c209e6606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a member function.  <a href="classrttr_1_1type.html#a17cb22627f1b5197931ee17c209e6606">More...</a><br /></td></tr>
<tr class="separator:a17cb22627f1b5197931ee17c209e6606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe02a3c7f659e40491564b91cf192fc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#abe02a3c7f659e40491564b91cf192fc4">is_member_object_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:abe02a3c7f659e40491564b91cf192fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a member object.  <a href="classrttr_1_1type.html#abe02a3c7f659e40491564b91cf192fc4">More...</a><br /></td></tr>
<tr class="separator:abe02a3c7f659e40491564b91cf192fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a00513155d3e678454aa349b0caaa7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a24a00513155d3e678454aa349b0caaa7">is_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:a24a00513155d3e678454aa349b0caaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer.  <a href="classrttr_1_1type.html#a24a00513155d3e678454aa349b0caaa7">More...</a><br /></td></tr>
<tr class="separator:a24a00513155d3e678454aa349b0caaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8362b580469d9357d8c97d9b3a6fe8ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a8362b580469d9357d8c97d9b3a6fe8ff">is_sequential_container</a> () const noexcept</td></tr>
<tr class="memdesc:a8362b580469d9357d8c97d9b3a6fe8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an <a href="https://en.wikipedia.org/wiki/Sequence_container_(C%2B%2B)" target="_blank">sequence container</a>.  <a href="classrttr_1_1type.html#a8362b580469d9357d8c97d9b3a6fe8ff">More...</a><br /></td></tr>
<tr class="separator:a8362b580469d9357d8c97d9b3a6fe8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013ec8f5a1086afa8142be318ccb5c9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a013ec8f5a1086afa8142be318ccb5c9f">is_template_instantiation</a> () const noexcept</td></tr>
<tr class="memdesc:a013ec8f5a1086afa8142be318ccb5c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type is an instantiation of a class template.  <a href="classrttr_1_1type.html#a013ec8f5a1086afa8142be318ccb5c9f">More...</a><br /></td></tr>
<tr class="separator:a013ec8f5a1086afa8142be318ccb5c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6b241be3e6a25d787248e0b9d6f20b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a5d6b241be3e6a25d787248e0b9d6f20b">is_valid</a> () const noexcept</td></tr>
<tr class="memdesc:a5d6b241be3e6a25d787248e0b9d6f20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is valid, that means the type holds valid data to a type.  <a href="classrttr_1_1type.html#a5d6b241be3e6a25d787248e0b9d6f20b">More...</a><br /></td></tr>
<tr class="separator:a5d6b241be3e6a25d787248e0b9d6f20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bd09e2408fbc2816e201c2d82df582"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af1bd09e2408fbc2816e201c2d82df582">is_wrapper</a> () const noexcept</td></tr>
<tr class="memdesc:af1bd09e2408fbc2816e201c2d82df582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a wrapper type.  <a href="classrttr_1_1type.html#af1bd09e2408fbc2816e201c2d82df582">More...</a><br /></td></tr>
<tr class="separator:af1bd09e2408fbc2816e201c2d82df582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7eb29496eefb3088748fd1d94c827bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ac7eb29496eefb3088748fd1d94c827bd">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ac7eb29496eefb3088748fd1d94c827bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to check if this <a class="el" href="classrttr_1_1type.html">type</a> is valid or not.  <a href="classrttr_1_1type.html#ac7eb29496eefb3088748fd1d94c827bd">More...</a><br /></td></tr>
<tr class="separator:ac7eb29496eefb3088748fd1d94c827bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b738cc01e01139884f27f487af65bf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a7b738cc01e01139884f27f487af65bf6">operator!=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a7b738cc01e01139884f27f487af65bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this type with the <em>other</em> type and returns true if both describe different types, otherwise returns false.  <a href="classrttr_1_1type.html#a7b738cc01e01139884f27f487af65bf6">More...</a><br /></td></tr>
<tr class="separator:a7b738cc01e01139884f27f487af65bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efa67807aa9426c64deb17ac2814af5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a9efa67807aa9426c64deb17ac2814af5">operator&lt;</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a9efa67807aa9426c64deb17ac2814af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="classrttr_1_1type.html#a9efa67807aa9426c64deb17ac2814af5">More...</a><br /></td></tr>
<tr class="separator:a9efa67807aa9426c64deb17ac2814af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1b76e0b76968aacecf936262fd47cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a9b1b76e0b76968aacecf936262fd47cd">operator&lt;=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a9b1b76e0b76968aacecf936262fd47cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="classrttr_1_1type.html#a9b1b76e0b76968aacecf936262fd47cd">More...</a><br /></td></tr>
<tr class="separator:a9b1b76e0b76968aacecf936262fd47cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17a5bddbcff0a442cab910a91418047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ac17a5bddbcff0a442cab910a91418047">operator=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ac17a5bddbcff0a442cab910a91418047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a type to another one.  <a href="classrttr_1_1type.html#ac17a5bddbcff0a442cab910a91418047">More...</a><br /></td></tr>
<tr class="separator:ac17a5bddbcff0a442cab910a91418047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e3a655ae521b2acc9b98d664f7c903"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a66e3a655ae521b2acc9b98d664f7c903">operator==</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a66e3a655ae521b2acc9b98d664f7c903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this type with the <em>other</em> type and returns true if both describe the same type, otherwise returns false.  <a href="classrttr_1_1type.html#a66e3a655ae521b2acc9b98d664f7c903">More...</a><br /></td></tr>
<tr class="separator:a66e3a655ae521b2acc9b98d664f7c903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936f39e7d1fb10a973bb22e3b43c8704"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a936f39e7d1fb10a973bb22e3b43c8704">operator&gt;</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a936f39e7d1fb10a973bb22e3b43c8704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="classrttr_1_1type.html#a936f39e7d1fb10a973bb22e3b43c8704">More...</a><br /></td></tr>
<tr class="separator:a936f39e7d1fb10a973bb22e3b43c8704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb823dce537521ab4933035a5d0b2521"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#adb823dce537521ab4933035a5d0b2521">operator&gt;=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:adb823dce537521ab4933035a5d0b2521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="classrttr_1_1type.html#adb823dce537521ab4933035a5d0b2521">More...</a><br /></td></tr>
<tr class="separator:adb823dce537521ab4933035a5d0b2521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57f575909bf13fa24d03ad14393204a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af57f575909bf13fa24d03ad14393204a">set_property_value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, <a class="el" href="classrttr_1_1instance.html">instance</a> obj, <a class="el" href="classrttr_1_1argument.html">argument</a> arg) const</td></tr>
<tr class="memdesc:af57f575909bf13fa24d03ad14393204a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the given value <code>arg</code> to a property named <code>name</code> to the instance <code>obj</code>.  <a href="classrttr_1_1type.html#af57f575909bf13fa24d03ad14393204a">More...</a><br /></td></tr>
<tr class="separator:af57f575909bf13fa24d03ad14393204a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5336e448f0881d2141be932e74fc756f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5336e448f0881d2141be932e74fc756f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">get</a> () noexcept</td></tr>
<tr class="memdesc:a5336e448f0881d2141be932e74fc756f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object for the given template type <em>T</em>.  <a href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">More...</a><br /></td></tr>
<tr class="separator:a5336e448f0881d2141be932e74fc756f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2abeb0984be9d1b1f5dc8f1a54033e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe2abeb0984be9d1b1f5dc8f1a54033e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afe2abeb0984be9d1b1f5dc8f1a54033e">get</a> (T &amp;&amp;object) noexcept</td></tr>
<tr class="memdesc:afe2abeb0984be9d1b1f5dc8f1a54033e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object for the given instance <em>object</em>.  <a href="classrttr_1_1type.html#afe2abeb0984be9d1b1f5dc8f1a54033e">More...</a><br /></td></tr>
<tr class="separator:afe2abeb0984be9d1b1f5dc8f1a54033e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba79b9f4916c30db74fe65508dca033"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">get_by_name</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) noexcept</td></tr>
<tr class="memdesc:a7ba79b9f4916c30db74fe65508dca033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type object with the given name <code>name</code>.  <a href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">More...</a><br /></td></tr>
<tr class="separator:a7ba79b9f4916c30db74fe65508dca033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fa4ae4fb0619be68c3b83967fefb51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a15fa4ae4fb0619be68c3b83967fefb51">get_global_method</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) noexcept</td></tr>
<tr class="memdesc:a15fa4ae4fb0619be68c3b83967fefb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global method with the name <code>name</code>.  <a href="classrttr_1_1type.html#a15fa4ae4fb0619be68c3b83967fefb51">More...</a><br /></td></tr>
<tr class="separator:a15fa4ae4fb0619be68c3b83967fefb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96e1fba11f481929eda97399aaedf68"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ab96e1fba11f481929eda97399aaedf68">get_global_method</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;params) noexcept</td></tr>
<tr class="memdesc:ab96e1fba11f481929eda97399aaedf68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global method with the name <code>name</code> which match the given parameter list <code>params</code>.  <a href="classrttr_1_1type.html#ab96e1fba11f481929eda97399aaedf68">More...</a><br /></td></tr>
<tr class="separator:ab96e1fba11f481929eda97399aaedf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b9569ae785763a1e0002fce9fa373b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ad5b9569ae785763a1e0002fce9fa373b">get_global_methods</a> () noexcept</td></tr>
<tr class="memdesc:ad5b9569ae785763a1e0002fce9fa373b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered global methods.  <a href="classrttr_1_1type.html#ad5b9569ae785763a1e0002fce9fa373b">More...</a><br /></td></tr>
<tr class="separator:ad5b9569ae785763a1e0002fce9fa373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990a44b24435ec4fe82b4d73a3958530"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a990a44b24435ec4fe82b4d73a3958530">get_global_properties</a> () noexcept</td></tr>
<tr class="memdesc:a990a44b24435ec4fe82b4d73a3958530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered global properties.  <a href="classrttr_1_1type.html#a990a44b24435ec4fe82b4d73a3958530">More...</a><br /></td></tr>
<tr class="separator:a990a44b24435ec4fe82b4d73a3958530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b754b6b0cccc39632323e3ee37f778e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1property.html">property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a9b754b6b0cccc39632323e3ee37f778e">get_global_property</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) noexcept</td></tr>
<tr class="memdesc:a9b754b6b0cccc39632323e3ee37f778e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global property with the name <code>name</code>.  <a href="classrttr_1_1type.html#a9b754b6b0cccc39632323e3ee37f778e">More...</a><br /></td></tr>
<tr class="separator:a9b754b6b0cccc39632323e3ee37f778e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148b6cb7890fcd53b7d6559a2fb610fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a148b6cb7890fcd53b7d6559a2fb610fe">get_property_value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name)</td></tr>
<tr class="memdesc:a148b6cb7890fcd53b7d6559a2fb610fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property value of property named <code>name</code>.  <a href="classrttr_1_1type.html#a148b6cb7890fcd53b7d6559a2fb610fe">More...</a><br /></td></tr>
<tr class="separator:a148b6cb7890fcd53b7d6559a2fb610fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09461f2a8eb076188a465504319ae80"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae09461f2a8eb076188a465504319ae80">get_types</a> () noexcept</td></tr>
<tr class="memdesc:ae09461f2a8eb076188a465504319ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered type objects.  <a href="classrttr_1_1type.html#ae09461f2a8eb076188a465504319ae80">More...</a><br /></td></tr>
<tr class="separator:ae09461f2a8eb076188a465504319ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe763c9f268d4fa897d8e52b89c2e093"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afe763c9f268d4fa897d8e52b89c2e093">invoke</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args)</td></tr>
<tr class="memdesc:afe763c9f268d4fa897d8e52b89c2e093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a global method named <code>name</code> with the specified argument <code>args</code>.  <a href="classrttr_1_1type.html#afe763c9f268d4fa897d8e52b89c2e093">More...</a><br /></td></tr>
<tr class="separator:afe763c9f268d4fa897d8e52b89c2e093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4912d4dac773276a6142a70a40ab0543"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4912d4dac773276a6142a70a40ab0543"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4912d4dac773276a6142a70a40ab0543">register_comparators</a> ()</td></tr>
<tr class="memdesc:a4912d4dac773276a6142a70a40ab0543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register comparison operators for template type <code>T</code>.  <a href="classrttr_1_1type.html#a4912d4dac773276a6142a70a40ab0543">More...</a><br /></td></tr>
<tr class="separator:a4912d4dac773276a6142a70a40ab0543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f5f2ea31cc79846a829aa5737680f0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a81f5f2ea31cc79846a829aa5737680f0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">register_converter_func</a> (F func)</td></tr>
<tr class="memdesc:a81f5f2ea31cc79846a829aa5737680f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a converter func <code>F</code>, which will be used internally by the <a class="el" href="classrttr_1_1variant.html">variant</a> class to convert between types.  <a href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">More...</a><br /></td></tr>
<tr class="separator:a81f5f2ea31cc79846a829aa5737680f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af963b3fcb5b3af10bca20decd8566b6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af963b3fcb5b3af10bca20decd8566b6c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af963b3fcb5b3af10bca20decd8566b6c">register_equal_comparator</a> ()</td></tr>
<tr class="memdesc:af963b3fcb5b3af10bca20decd8566b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the equal comparison operators for template type <code>T</code>.  <a href="classrttr_1_1type.html#af963b3fcb5b3af10bca20decd8566b6c">More...</a><br /></td></tr>
<tr class="separator:af963b3fcb5b3af10bca20decd8566b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c27b3dbc76884d432902420be574d4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c27b3dbc76884d432902420be574d4d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a5c27b3dbc76884d432902420be574d4d">register_less_than_comparator</a> ()</td></tr>
<tr class="memdesc:a5c27b3dbc76884d432902420be574d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the less than comparison operators for template type <code>T</code>.  <a href="classrttr_1_1type.html#a5c27b3dbc76884d432902420be574d4d">More...</a><br /></td></tr>
<tr class="separator:a5c27b3dbc76884d432902420be574d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fbbd3ac5729e695c8c2ef0fca4cbbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80fbbd3ac5729e695c8c2ef0fca4cbbc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a80fbbd3ac5729e695c8c2ef0fca4cbbc">register_wrapper_converter_for_base_classes</a> ()</td></tr>
<tr class="memdesc:a80fbbd3ac5729e695c8c2ef0fca4cbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register for all base classes of the giving type <code>T</code> wrapper converter functions.  <a href="classrttr_1_1type.html#a80fbbd3ac5729e695c8c2ef0fca4cbbc">More...</a><br /></td></tr>
<tr class="separator:a80fbbd3ac5729e695c8c2ef0fca4cbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748930ab0ca3b8254f1bf85322f3612"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0748930ab0ca3b8254f1bf85322f3612">set_property_value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, <a class="el" href="classrttr_1_1argument.html">argument</a> arg)</td></tr>
<tr class="memdesc:a0748930ab0ca3b8254f1bf85322f3612"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the given value <code>arg</code> to a property named <code>name</code>.  <a href="classrttr_1_1type.html#a0748930ab0ca3b8254f1bf85322f3612">More...</a><br /></td></tr>
<tr class="separator:a0748930ab0ca3b8254f1bf85322f3612"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classrttr_1_1type.html">type</a> class holds the type information for any arbitrary object. </p>
<p>Every class or primitive data type can have an unique type object. With the help of this object you can compare unknown types for equality at runtime or introspect the type for its <a class="el" href="classrttr_1_1property.html">properties</a>, <a class="el" href="classrttr_1_1method.html">methods</a>, <a class="el" href="classrttr_1_1enumeration.html">enumerations</a>, <a class="el" href="classrttr_1_1constructor.html">constructors</a> and <a class="el" href="classrttr_1_1destructor.html">destructor</a>.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Retrieve %type</h2>
<p>A type object <b>cannot</b> be created. It is only possible to retrieve a type object via three static template member functions:</p>
<h3><a class="anchor" id="autotoc_md23"></a>
type::get&lt;T&gt;()</h3>
<p>This function just expects one template argument. Use it to check against a known type.</p>
<div class="fragment"><div class="line">type::get&lt;int&gt;() == type::get&lt;int&gt;();  <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;int&gt;() == type::get&lt;bool&gt;(); <span class="comment">// yields to false</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
type::get_by_name(string_view)</h3>
<p>This function just expects the name of the type. This is useful when you know only the name of the type and cannot include the type itself into the source code.</p>
<div class="fragment"><div class="line"><a class="code" href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">type::get_by_name</a>(<span class="stringliteral">&quot;int&quot;</span>)  == type::get&lt;int&gt;(); <span class="comment">// yields to true</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">type::get_by_name</a>(<span class="stringliteral">&quot;bool&quot;</span>) == type::get&lt;int&gt;(); <span class="comment">// yields to false</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">type::get_by_name</a>(<span class="stringliteral">&quot;MyNameSpace::MyStruct&quot;</span>) == type::get&lt;MyNameSpace::MyStruct&gt;();  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Before using the function <a class="el" href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">type::get_by_name()</a>, you have to use one time the function via <a class="el" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get&lt;T&gt;()</a>, otherwise the type is not registered in the type system.</dd></dl>
<h3><a class="anchor" id="autotoc_md25"></a>
type::get&lt;T&gt;(T&amp;&amp; obj)</h3>
<p>This function takes a universal reference and returns from every given object the corresponding type object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> int_obj;</div>
<div class="line"><span class="keywordtype">int</span>* int_obj_ptr = &amp;int_obj;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>* c_int_obj_ptr = int_obj_ptr;</div>
<div class="line"> </div>
<div class="line">type::get&lt;int&gt;()         == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(int_obj);        <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;int*&gt;()        == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(int_obj_ptr);    <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;const int*&gt;()  == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(c_int_obj_ptr);  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><p>When this function is called for a glvalue expression whose type is a polymorphic class type, then the result refers to a <a class="el" href="classrttr_1_1type.html">type</a> object representing the type of the most derived object.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Base { <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>Derived : Base { <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(Base) };</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">Derived d;</div>
<div class="line">Base&amp; base = d;</div>
<div class="line">type::get&lt;Derived&gt;()   == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(base);      <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;Base&gt;()      == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(base);      <span class="comment">// yields to false</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// remark, when called with pointers:</span></div>
<div class="line">Base* base_ptr = &amp;d;</div>
<div class="line">type::get&lt;Derived&gt;()   == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(base_ptr);  <span class="comment">// yields to false</span></div>
<div class="line">type::get&lt;Base*&gt;()     == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(base_ptr);  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>If the type of the expression is a cv-qualified type, the result of the <a class="el" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f" title="Returns a type object for the given template type T.">rttr::type::get</a> expression refers to a <a class="el" href="classrttr_1_1type.html" title="The type class holds the type information for any arbitrary object.">rttr::type</a> object representing the cv-unqualified type.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">class </span>D { ... };</div>
<div class="line">D d1;</div>
<div class="line"><span class="keyword">const</span> D d2;</div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(d1)  == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(d2);         <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D&gt;();  <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(d2);         <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D&amp;&gt;(); <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D*&gt;(); <span class="comment">// yields false</span></div>
</div><!-- fragment --><p> Any <code>top level</code> cv-qualifier of the given type <code>T</code> will be removed.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Copying and Assignment</h2>
<p>A <a class="el" href="classrttr_1_1type.html">type</a> object is lightweight and can be copied by value. However, each copy will refer to the same underlying type. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a695c388f245ae5f550b8ef6bb343a800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695c388f245ae5f550b8ef6bb343a800">&#9670;&nbsp;</a></span>type_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uintptr_t <a class="el" href="classrttr_1_1type.html#a695c388f245ae5f550b8ef6bb343a800">rttr::type::type_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afec6296ac7c1d21cda157b9cbbdf3af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec6296ac7c1d21cda157b9cbbdf3af4">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rttr::type::type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a type to another one. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad44572a03514d83035580f516ebaf4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44572a03514d83035580f516ebaf4e1">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::create </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em> = <code>std::vector&lt;&#160;<a class="el" href="classrttr_1_1argument.html">argument</a>&#160;&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the current type, with the given arguments <code>args</code> for the constructor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the argument types does not match the parameter list of the constructor then the he will not be invoked. Constructors with registered <a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> will be honored.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of the given type. </dd></dl>

</div>
</div>
<a id="a33bc44604dae75f4368428afabf364ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33bc44604dae75f4368428afabf364ac">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the contained object in the variant <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the <code>obj</code> could be destroyed the given <code>obj</code> is invalid after calling this method; Otherwise it is still valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the destructor of the object could be invoked, otherwise false. </dd></dl>

</div>
</div>
<a id="a5336e448f0881d2141be932e74fc756f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5336e448f0881d2141be932e74fc756f">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a type object for the given template type <em>T</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>type for the template type <em>T</em>. </dd></dl>

</div>
</div>
<a id="afe2abeb0984be9d1b1f5dc8f1a54033e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2abeb0984be9d1b1f5dc8f1a54033e">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a type object for the given instance <em>object</em>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the type of the expression is a cv-qualified type, the result of the <a class="el" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f" title="Returns a type object for the given template type T.">type::get()</a> expression refers to a type object representing the cv-unqualified type. When <a class="el" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f" title="Returns a type object for the given template type T.">type::get()</a> is applied to a glvalue expression whose type is a polymorphic class type, the result refers to a type object representing the type of the most derived object.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>type for an <em>object</em> of type <em>T</em>. </dd></dl>

</div>
</div>
<a id="aed9b001581881e62aaf794f456e405e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9b001581881e62aaf794f456e405e7">&#9670;&nbsp;</a></span>get_base_classes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1type.html">type</a>&gt; rttr::type::get_base_classes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all base classes of this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>. The order of this list depends on the declaration order of classes inside RTTR_ENABLE. E.g. <a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59" title="This macro is necessary in order to retrieve type information about the inheritance graph of a class.">RTTR_ENABLE(A1, A2)</a> =&gt; A1 will be for A2 in the list. Accordingly the root (or parent or base) class is always the first type in the list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of types. </dd></dl>

</div>
</div>
<a id="a7ba79b9f4916c30db74fe65508dca033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba79b9f4916c30db74fe65508dca033">&#9670;&nbsp;</a></span>get_by_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type object with the given name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The search for the type is case sensitive. White spaces will be ignored. The name of the type corresponds to the name which was used during <a class="el" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a>. Only after the registration process was executed, then the type can be retrieved with this function. Otherwise and invalid type will be returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classrttr_1_1type.html">type</a> object with the name <code>name</code>. </dd></dl>

</div>
</div>
<a id="ae1ed385e76752e7c02ffd9bf5a0ae410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ed385e76752e7c02ffd9bf5a0ae410">&#9670;&nbsp;</a></span>get_constructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1constructor.html">constructor</a> rttr::type::get_constructor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>std::vector&lt;&#160;<a class="el" href="classrttr_1_1type.html">type</a>&#160;&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a public constructor whose parameters match the types in the specified list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When no parameter list is given, it will be searched for the default constructor.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A valid constructor will be returned when the parameter matches the registered constructor; otherwise an invalid constructor. </dd></dl>

</div>
</div>
<a id="a273b0ac03043a9008f4f63c4e8246587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273b0ac03043a9008f4f63c4e8246587">&#9670;&nbsp;</a></span>get_constructors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1constructor.html">constructor</a>&gt; rttr::type::get_constructors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered <em>public</em> constructors for this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to retrieve <em>private</em> constructors, use <a class="el" href="classrttr_1_1type.html#a6054d1af85fcf5d4fb30cc57ef7f325e">type::get_constructors(filter_items) const</a> with following filter combination <code><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f" title="Includes all members in the search, which needs an instance to be invoked.">filter_item::instance_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d" title="Includes all static members in the search.">filter_item::static_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32" title="Includes all non public (private or protected) members in the search.">filter_item::non_public_access</a></code> The constructors are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of constructors. </dd></dl>

</div>
</div>
<a id="a6054d1af85fcf5d4fb30cc57ef7f325e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6054d1af85fcf5d4fb30cc57ef7f325e">&#9670;&nbsp;</a></span>get_constructors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1constructor.html">constructor</a>&gt; rttr::type::get_constructors </td>
          <td>(</td>
          <td class="paramtype">filter_items&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered constructors for this type, based on the given <code>filter</code>. </p>
<p>The base classes are <b>not</b> included in the search.</p>
<p>Combine the enum values inside <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">filter_item</a> with the OR operator to return a certain range of constructors.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_struct { my_struct() {} my_struct(<span class="keywordtype">int</span>) {} my_struct(<span class="keywordtype">bool</span>) {} <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;my_struct&gt;</a>(<span class="stringliteral">&quot;my_struct&quot;</span>)</div>
<div class="line">        .<a class="code" href="classrttr_1_1registration_1_1class__.html#a0c0f9b9b4a78e8eefb17f690f15e7795">constructor</a>&lt;&gt;() ( <a class="code" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">policy::ctor::as_object</a> )</div>
<div class="line">        .constructor&lt;<span class="keywordtype">bool</span>&gt;(<a class="code" href="classrttr_1_1registration.html#a5ac82a82df83ce2dd8c34ada18d7b904">registration::protected_access</a>) ( <a class="code" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">policy::ctor::as_object</a> )</div>
<div class="line">        .constructor&lt;<span class="keywordtype">int</span>&gt;() ( <a class="code" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">policy::ctor::as_object</a> );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1type.html#afec6296ac7c1d21cda157b9cbbdf3af4">type</a> t = rttr::type::get&lt;my_struct&gt;();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ctor : t.get_constructors())</div>
<div class="line">        std::cout &lt;&lt; ctor.get_signature() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;my_struct( ), my_struct( int ),&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ctor : t.get_constructors(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; ctor.get_signature() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;my_struct( bool ),&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ctor : t.get_constructors(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d">filter_item::static_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; ctor.get_signature() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;my_struct( bool ),&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ctor : t.get_constructors(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b">filter_item::public_access</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da">filter_item::declared_only</a>))</div>
<div class="line">        std::cout &lt;&lt; ctor.get_signature() &lt;&lt; std::endl; <span class="comment">// prints &quot;my_struct( ), my_struct( int ),&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The properties are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of properties. </dd></dl>

</div>
</div>
<a id="a579391b0b9fdb6d4d001efd1c409bad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579391b0b9fdb6d4d001efd1c409bad7">&#9670;&nbsp;</a></span>get_derived_classes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1type.html">type</a>&gt; rttr::type::get_derived_classes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all derived classes of this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>. The order of this list depends on the declaration order of classes inside RTTR_ENABLE. E.g. <a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59" title="This macro is necessary in order to retrieve type information about the inheritance graph of a class.">RTTR_ENABLE(A1, A2)</a> =&gt; A1 will be for A2 in the list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of type objects. </dd></dl>

</div>
</div>
<a id="a12d900648f71d11873896f58b1f9a3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d900648f71d11873896f58b1f9a3ac">&#9670;&nbsp;</a></span>get_destructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1destructor.html">destructor</a> rttr::type::get_destructor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the corresponding destructor for this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there is no constructor registered for this type, then also the destructor is not available. A destructor will always been automatically registered.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the destructor for this type. </dd></dl>

</div>
</div>
<a id="aa0b0e3e85de99df74f956a84b463f10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b0e3e85de99df74f956a84b463f10b">&#9670;&nbsp;</a></span>get_enumeration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1enumeration.html">enumeration</a> rttr::type::get_enumeration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the enumerator if this type is an enum type; otherwise the returned value is <a class="el" href="classrttr_1_1enumeration.html#a465644dd0af25f6d55cd17704c4e6137">not valid</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#a60e41c2c736ed5ce3198a84da9af4d6d" title="Returns true whether the given type represents an enumeration.">is_enumeration()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A enumeration object. </dd></dl>

</div>
</div>
<a id="a15fa4ae4fb0619be68c3b83967fefb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fa4ae4fb0619be68c3b83967fefb51">&#9670;&nbsp;</a></span>get_global_method() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_global_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global method with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code>, and invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a id="ab96e1fba11f481929eda97399aaedf68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96e1fba11f481929eda97399aaedf68">&#9670;&nbsp;</a></span>get_global_method() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_global_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global method with the name <code>name</code> which match the given parameter list <code>params</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code> and matching parameter list <code>params</code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code> and parameter signature <code>params</code>. </dd></dl>

</div>
</div>
<a id="ad5b9569ae785763a1e0002fce9fa373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b9569ae785763a1e0002fce9fa373b">&#9670;&nbsp;</a></span>get_global_methods()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1method.html">method</a>&gt; rttr::type::get_global_methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered global methods. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the methods in the range is undefined. Client code should <b>not</b> depend on the order in which methods are returned, because that order varies.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of methods. </dd></dl>

</div>
</div>
<a id="a990a44b24435ec4fe82b4d73a3958530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990a44b24435ec4fe82b4d73a3958530">&#9670;&nbsp;</a></span>get_global_properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1property.html">property</a>&gt; rttr::type::get_global_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered global properties. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the properties in the range is undefined. Client code should <b>not</b> depend on the order in which properties are returned, because that order varies.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of properties. </dd></dl>

</div>
</div>
<a id="a9b754b6b0cccc39632323e3ee37f778e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b754b6b0cccc39632323e3ee37f778e">&#9670;&nbsp;</a></span>get_global_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1property.html">property</a> rttr::type::get_global_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global property with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no property with the name <code>name</code>, then an invalid property is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A property with name <code>name</code>. </dd></dl>

</div>
</div>
<a id="a9f0fee08c9ec342fbfb8a1f9ecf0095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0fee08c9ec342fbfb8a1f9ecf0095a">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html#a695c388f245ae5f550b8ef6bb343a800">type_id</a> rttr::type::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the id of this type. </p>
<dl class="section note"><dt>Note</dt><dd>This id is unique at process runtime, but the id can be changed every time the process is executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type id. </dd></dl>

</div>
</div>
<a id="aeecd54b252a3957e52c2eaa41e18f4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecd54b252a3957e52c2eaa41e18f4cd">&#9670;&nbsp;</a></span>get_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the meta data for the given key <code>key</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When no meta data is registered with the given <code>key</code>, an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object is returned (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant object, containing arbitrary data. </dd></dl>

</div>
</div>
<a id="a4d31b84c050f5b22509c16d0379fe0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d31b84c050f5b22509c16d0379fe0c7">&#9670;&nbsp;</a></span>get_method() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a method with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a id="a1e9ba82f9564a749547fd5562d7cc40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9ba82f9564a749547fd5562d7cc40a">&#9670;&nbsp;</a></span>get_method() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a method with the name <code>name</code> which match the given parameter type list <code><a class="el" href="structrttr_1_1type__list.html" title="Contains a list of template parameters.">type_list</a></code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code> and matching parameter type list <code><a class="el" href="structrttr_1_1type__list.html" title="Contains a list of template parameters.">type_list</a></code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a id="a67ffced2826ff08f2a761acbeb133ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ffced2826ff08f2a761acbeb133ae9">&#9670;&nbsp;</a></span>get_methods() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1method.html">method</a>&gt; rttr::type::get_methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered <em>public</em> methods for this type and all its base classes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to retrieve <em>private</em> methods, use <a class="el" href="classrttr_1_1type.html#a0181dd63628275d64819334ff7272324">type::get_methods(filter_items) const</a> with following filter combination <code><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f" title="Includes all members in the search, which needs an instance to be invoked.">filter_item::instance_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d" title="Includes all static members in the search.">filter_item::static_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32" title="Includes all non public (private or protected) members in the search.">filter_item::non_public_access</a></code> The methods are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of methods. </dd></dl>

</div>
</div>
<a id="a0181dd63628275d64819334ff7272324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0181dd63628275d64819334ff7272324">&#9670;&nbsp;</a></span>get_methods() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1method.html">method</a>&gt; rttr::type::get_methods </td>
          <td>(</td>
          <td class="paramtype">filter_items&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered methods for this type, based on the given <code>filter</code>. </p>
<p>The base classes are included in the search.</p>
<p>Combine the enum values inside <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">filter_item</a> with the OR operator to return a certain range of methods.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>base { <span class="keywordtype">void</span> func_1() {} <span class="keywordtype">void</span> func_2() {} <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>derived : base { <span class="keywordtype">void</span> func_3() {} <span class="keyword">static</span> <span class="keywordtype">void</span> func_4() {} <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(base) };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;base&gt;</a>(<span class="stringliteral">&quot;base&quot;</span>)</div>
<div class="line">        .<a class="code" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">method</a>(<span class="stringliteral">&quot;func_1&quot;</span>, &amp;base::func_1)</div>
<div class="line">        .method(<span class="stringliteral">&quot;func_2&quot;</span>, &amp;base::func_2, <a class="code" href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;derived&gt;</a>(<span class="stringliteral">&quot;derived&quot;</span>)</div>
<div class="line">        .<a class="code" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">method</a>(<span class="stringliteral">&quot;func_3&quot;</span>, &amp;derived::func_3)</div>
<div class="line">        .method(<span class="stringliteral">&quot;func_4&quot;</span>, &amp;derived::func_4, <a class="code" href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1type.html#afec6296ac7c1d21cda157b9cbbdf3af4">type</a> t = rttr::type::get&lt;derived&gt;();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; meth : t.get_methods())</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;func_1, func_3,&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; meth : t.get_methods(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;func_2,&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; meth : t.get_methods(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d">filter_item::static_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;func_4,&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; meth : t.get_methods(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b">filter_item::public_access</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da">filter_item::declared_only</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;func_3,&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The methods are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of methods. </dd></dl>

</div>
</div>
<a id="a16d519457c68429ef2316067d1cf6700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d519457c68429ef2316067d1cf6700">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> rttr::type::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique and human-readable name of the type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The content of this string is compiler depended.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type name. </dd></dl>

</div>
</div>
<a id="af4d2837c650a639b9aab9bd6e580dc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d2837c650a639b9aab9bd6e580dc8a">&#9670;&nbsp;</a></span>get_properties() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1property.html">property</a>&gt; rttr::type::get_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered <em>public</em> properties for this type and all its base classes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to retrieve <em>private</em> properties, use <a class="el" href="classrttr_1_1type.html#ad77289c46150e0be761bc2168a56e2ae">type::get_properties(filter_items) const</a> with following filter combination <code><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f" title="Includes all members in the search, which needs an instance to be invoked.">filter_item::instance_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d" title="Includes all static members in the search.">filter_item::static_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32" title="Includes all non public (private or protected) members in the search.">filter_item::non_public_access</a></code> The properties are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of properties. </dd></dl>

</div>
</div>
<a id="ad77289c46150e0be761bc2168a56e2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77289c46150e0be761bc2168a56e2ae">&#9670;&nbsp;</a></span>get_properties() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1property.html">property</a>&gt; rttr::type::get_properties </td>
          <td>(</td>
          <td class="paramtype">filter_items&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered properties for this type, based on the given <code>filter</code>. </p>
<p>The base classes are included in the search.</p>
<p>Combine the enum values inside <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">filter_item</a> with the OR operator to return a certain range of properties.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>base { <span class="keywordtype">int</span> p1, p2; <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>derived : base { <span class="keywordtype">int</span> p3; <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> p4 = 23; <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(base) };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;base&gt;</a>(<span class="stringliteral">&quot;base&quot;</span>)</div>
<div class="line">        .<a class="code" href="classrttr_1_1registration_1_1class__.html#a1e2a392693ad3d5b62ea85abdd1d6111">property</a>(<span class="stringliteral">&quot;p1&quot;</span>, &amp;base::p1)</div>
<div class="line">        .property(<span class="stringliteral">&quot;p2&quot;</span>, &amp;base::p2, <a class="code" href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;derived&gt;</a>(<span class="stringliteral">&quot;derived&quot;</span>)</div>
<div class="line">        .<a class="code" href="classrttr_1_1registration_1_1class__.html#a1e2a392693ad3d5b62ea85abdd1d6111">property</a>(<span class="stringliteral">&quot;p3&quot;</span>, &amp;derived::p3)</div>
<div class="line">        .property_readonly(<span class="stringliteral">&quot;p4&quot;</span>, &amp;derived::p4, <a class="code" href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1type.html#afec6296ac7c1d21cda157b9cbbdf3af4">type</a> t = rttr::type::get&lt;derived&gt;();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; prop : t.get_properties())</div>
<div class="line">        std::cout &lt;&lt; prop.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;p1, p3,&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; prop : t.get_properties(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;p2,&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; prop : t.get_properties(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d">filter_item::static_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;p4,&quot;</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; prop : t.get_properties(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b">filter_item::public_access</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da">filter_item::declared_only</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;p3&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The properties are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of properties. </dd></dl>

</div>
</div>
<a id="ae53c4df812c270f3f74b77210bc6a926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53c4df812c270f3f74b77210bc6a926">&#9670;&nbsp;</a></span>get_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1property.html">property</a> rttr::type::get_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a property with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no property with the name <code>name</code>, then an invalid property is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A property with name <code>name</code>. </dd></dl>

</div>
</div>
<a id="a148b6cb7890fcd53b7d6559a2fb610fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148b6cb7890fcd53b7d6559a2fb610fe">&#9670;&nbsp;</a></span>get_property_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_property_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property value of property named <code>name</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A variant containing the value of the property. </dd></dl>

</div>
</div>
<a id="a3010aa9577570ea86078b2ce2b2f8677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3010aa9577570ea86078b2ce2b2f8677">&#9670;&nbsp;</a></span>get_property_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_property_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the property value of property named <code>name</code> from the instance <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the given instance is empty, the value of global property will be tryed to returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant containing the value of the property. </dd></dl>

</div>
</div>
<a id="a50e0f91eaae62ff7f44419fd94836a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e0f91eaae62ff7f44419fd94836a1c">&#9670;&nbsp;</a></span>get_raw_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_raw_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a type object which represent the raw type. </p>
<p>A raw type, is a type type without any qualifiers (const and volatile) nor any pointer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When the current type is already the raw type, it will return an copy from itself.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding raw type object. </dd></dl>

</div>
</div>
<a id="aaae3874c7987835639df28055e0b9708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae3874c7987835639df28055e0b9708">&#9670;&nbsp;</a></span>get_sizeof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t rttr::type::get_sizeof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size in bytes of the object representation of the current type (i.e. </p>
<p><code>sizeof(T)</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the type in bytes. </dd></dl>

</div>
</div>
<a id="a6f58cffb2a57754cd6d25f71022028fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f58cffb2a57754cd6d25f71022028fd">&#9670;&nbsp;</a></span>get_template_arguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1type.html">type</a>&gt; rttr::type::get_template_arguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of type objects that represents the template arguments. </p>
<p>An empty list is returned when this type is not an instantiation of a template or contains no template arguments at all.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Args&gt;</div>
<div class="line"><span class="keyword">struct </span>my_class { };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> type_list = type::get&lt;my_class&lt;int, bool, char&gt;&gt;().<a class="code" href="classrttr_1_1type.html#a6f58cffb2a57754cd6d25f71022028fd">get_template_arguments</a>();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : type_list)</div>
<div class="line">{</div>
<div class="line">   std::cout &lt;&lt; t.get_name() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl; <span class="comment">// will print &#39;int bool char&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A list of nested types.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#a013ec8f5a1086afa8142be318ccb5c9f" title="Returns true whether the given type is an instantiation of a class template.">is_template_instantiation()</a> </dd></dl>

</div>
</div>
<a id="ae09461f2a8eb076188a465504319ae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09461f2a8eb076188a465504319ae80">&#9670;&nbsp;</a></span>get_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1type.html">type</a>&gt; rttr::type::get_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered type objects. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the type object is unspecified.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of type objects. </dd></dl>

</div>
</div>
<a id="a9b6af1ac4dd7e107cdfabb1050546724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6af1ac4dd7e107cdfabb1050546724">&#9670;&nbsp;</a></span>get_wrapped_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_wrapped_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a type object which represent the wrapped type. </p>
<p>A wrapper type is a class which encapsulate an instance of another type. This encapsulate type is also called <em>wrapped type</em>.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><a class="code" href="classrttr_1_1type.html#afec6296ac7c1d21cda157b9cbbdf3af4">type</a> wrapped_type = type::get&lt;std::shared_ptr&lt;int&gt;&gt;().<a class="code" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">get_wrapped_type</a>();</div>
<div class="line">wrapped_type == type::get&lt;int*&gt;(); <span class="comment">// yields to true</span></div>
<div class="line"> </div>
<div class="line">wrapped_type = type::get&lt;std::reference_wrapper&lt;int&gt;&gt;().<a class="code" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">get_wrapped_type</a>();</div>
<div class="line">wrapped_type == type::get&lt;int&gt;(); <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>When the current type is not a wrapper type, this function will return an <a class="el" href="classrttr_1_1type.html#a5d6b241be3e6a25d787248e0b9d6f20b">invalid type</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper&lt;T&gt;</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type object of the wrapped type. </dd></dl>

</div>
</div>
<a id="afc7329cac11337f4022d7d10eebe80d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7329cac11337f4022d7d10eebe80d3">&#9670;&nbsp;</a></span>invoke() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>, or as shortcut use simply <code>{}</code>. Methods with registered <a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> will be honored.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant object containing the possible return value, otherwise when it is a void function an empty but valid variant object. </dd></dl>

</div>
</div>
<a id="afe763c9f268d4fa897d8e52b89c2e093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe763c9f268d4fa897d8e52b89c2e093">&#9670;&nbsp;</a></span>invoke() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a global method named <code>name</code> with the specified argument <code>args</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A variant object containing the possible return value, otherwise when it is a void function an empty but valid variant object. Methods with registered <a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> will be honored. </dd></dl>

</div>
</div>
<a id="aac53b079eca2d784a126ad6a3b13b9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac53b079eca2d784a126ad6a3b13b9e5">&#9670;&nbsp;</a></span>is_arithmetic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_arithmetic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an arithmetic type. </p>
<p>An arithmetic type is a integral type or a floating point type. e.g. <code>bool</code>, <code>int</code>, <code>float</code>, etc...</p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a arithmetic type, otherwise false. </dd></dl>

</div>
</div>
<a id="a85ecc638e72ac4a5b43025bd0ddf5eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ecc638e72ac4a5b43025bd0ddf5eb6">&#9670;&nbsp;</a></span>is_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> whether the given type represents an array. </p>
<p>An array is always also a sequential container. The check will return <code>true</code> only for raw C-Style arrays: </p><div class="fragment"><div class="line">type::get&lt;int[10]&gt;().is_array();            <span class="comment">// true</span></div>
<div class="line">type::get&lt;int&gt;().is_array();                <span class="comment">// false</span></div>
<div class="line">type::get&lt;std::array&lt;int,10&gt;&gt;().<a class="code" href="classrttr_1_1type.html#a85ecc638e72ac4a5b43025bd0ddf5eb6">is_array</a>(); <span class="comment">// false</span></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the type is an array, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#a8362b580469d9357d8c97d9b3a6fe8ff" title="Returns true whether the given type represents an sequence container.">is_sequential_container()</a> </dd></dl>

</div>
</div>
<a id="a95d23b7e6159ef21e64b6245cfe7d59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d23b7e6159ef21e64b6245cfe7d59b">&#9670;&nbsp;</a></span>is_associative_container()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_associative_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an <a href="https://en.wikipedia.org/wiki/Associative_containers" target="_blank">associative container</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an associative container, otherwise false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrttr_1_1associative__container__mapper.html">associative_container_mapper&lt;T&gt;</a> </dd></dl>

</div>
</div>
<a id="a7ef0cb9177ae3a786297f41b50c8f8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef0cb9177ae3a786297f41b50c8f8c6">&#9670;&nbsp;</a></span>is_base_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_base_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this type is the base class from the given type <em>T</em>, otherwise false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this type is a base class type from <em>T</em>, otherwise false. </dd></dl>

</div>
</div>
<a id="a9f75e13ced3ba2cfd22a22ea70042895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f75e13ced3ba2cfd22a22ea70042895">&#9670;&nbsp;</a></span>is_base_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_base_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this type is the base class from the given type <code>other</code>, otherwise false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this type is a base class type from <code>other</code>, otherwise false. </dd></dl>

</div>
</div>
<a id="a34296e0290e93317c34118945c0e2db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34296e0290e93317c34118945c0e2db9">&#9670;&nbsp;</a></span>is_class()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_class </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type is class; that is not an atomic type or a method. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a class, otherwise false. </dd></dl>

</div>
</div>
<a id="a4eb6d74e9baac6dc6cb3dddeb1a96611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb6d74e9baac6dc6cb3dddeb1a96611">&#9670;&nbsp;</a></span>is_derived_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_derived_from </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this type is derived from the given type <em>T</em>, otherwise false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this type is a derived type from <em>T</em>, otherwise false. </dd></dl>

</div>
</div>
<a id="ac8484b0779404e55c3116ea5a1b894fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8484b0779404e55c3116ea5a1b894fa">&#9670;&nbsp;</a></span>is_derived_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_derived_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this type is derived from the given type <code>other</code>, otherwise false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this type is a derived type from <code>other</code>, otherwise false. </dd></dl>

</div>
</div>
<a id="a60e41c2c736ed5ce3198a84da9af4d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e41c2c736ed5ce3198a84da9af4d6d">&#9670;&nbsp;</a></span>is_enumeration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_enumeration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an enumeration. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an enumeration, otherwise false. </dd></dl>

</div>
</div>
<a id="a95eb802279180d8a3757532909ec8fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95eb802279180d8a3757532909ec8fef">&#9670;&nbsp;</a></span>is_function_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_function_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a function e.g. </p>
<p><code>void (*)(void)</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a function pointer, otherwise false. </dd></dl>

</div>
</div>
<a id="a17cb22627f1b5197931ee17c209e6606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cb22627f1b5197931ee17c209e6606">&#9670;&nbsp;</a></span>is_member_function_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_member_function_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a member function. </p>
<p>e.g. <code>void (MyClass::*)(void)</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a member function pointer type, otherwise false. </dd></dl>

</div>
</div>
<a id="abe02a3c7f659e40491564b91cf192fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe02a3c7f659e40491564b91cf192fc4">&#9670;&nbsp;</a></span>is_member_object_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_member_object_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a member object. </p>
<p>e.g. <code>int (MyClass::*)</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a member object pointer, otherwise false. </dd></dl>

</div>
</div>
<a id="a24a00513155d3e678454aa349b0caaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a00513155d3e678454aa349b0caaa7">&#9670;&nbsp;</a></span>is_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer. </p>
<p>e.g. <code>int*</code>, or <code>bool*</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a pointer, otherwise false. </dd></dl>

</div>
</div>
<a id="a8362b580469d9357d8c97d9b3a6fe8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8362b580469d9357d8c97d9b3a6fe8ff">&#9670;&nbsp;</a></span>is_sequential_container()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_sequential_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an <a href="https://en.wikipedia.org/wiki/Sequence_container_(C%2B%2B)" target="_blank">sequence container</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an sequential container, otherwise false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrttr_1_1sequential__container__mapper.html">sequential_container_mapper&lt;T&gt;</a> </dd></dl>

</div>
</div>
<a id="a013ec8f5a1086afa8142be318ccb5c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013ec8f5a1086afa8142be318ccb5c9f">&#9670;&nbsp;</a></span>is_template_instantiation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_template_instantiation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type is an instantiation of a class template. </p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>foo { }; <span class="comment">// class template</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>bar { }; <span class="comment">// NO class template</span></div>
<div class="line"> </div>
<div class="line">type::get&lt;foo&lt;int&gt;&gt;().<a class="code" href="classrttr_1_1type.html#a013ec8f5a1086afa8142be318ccb5c9f">is_template_instantiation</a>(); <span class="comment">// yield to &#39;true&#39;</span></div>
<div class="line">type::get&lt;bar&gt;().is_template_instantiation();      <span class="comment">// yield to &#39;false&#39;</span></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the type is a class template, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#a6f58cffb2a57754cd6d25f71022028fd" title="Returns a list of type objects that represents the template arguments.">get_template_arguments()</a> </dd></dl>

</div>
</div>
<a id="a5d6b241be3e6a25d787248e0b9d6f20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6b241be3e6a25d787248e0b9d6f20b">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this type is valid, that means the type holds valid data to a type. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is valid, otherwise false. </dd></dl>

</div>
</div>
<a id="af1bd09e2408fbc2816e201c2d82df582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bd09e2408fbc2816e201c2d82df582">&#9670;&nbsp;</a></span>is_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a wrapper type. </p>
<p>A wrapper type is a class which encapsulate an instance of another type. RTTR recognize automatically following wrapper types:</p><ul>
<li><code><code>std::shared_ptr&lt;T&gt;</code></code> </li>
<li><code><code>std::reference_wrapper&lt;T&gt;</code></code> </li>
<li><code><code>std::weak_ptr&lt;T&gt;</code></code> </li>
<li><code><code>std::unique_ptr&lt;T&gt;</code></code> </li>
</ul>
<p>In order to work with custom wrapper types, its required to specialize the class <a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper&lt;T&gt;</a> and implement a getter function to retrieve the encapsulate type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper&lt;T&gt;</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an wrapper, otherwise false. </dd></dl>

</div>
</div>
<a id="ac7eb29496eefb3088748fd1d94c827bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7eb29496eefb3088748fd1d94c827bd">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rttr::type::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to check if this <a class="el" href="classrttr_1_1type.html">type</a> is valid or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this <a class="el" href="classrttr_1_1type.html">type</a> is valid, otherwise false. </dd></dl>

</div>
</div>
<a id="a7b738cc01e01139884f27f487af65bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b738cc01e01139884f27f487af65bf6">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this type with the <em>other</em> type and returns true if both describe different types, otherwise returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both type are <b>not</b> equal, otherwise false. </dd></dl>

</div>
</div>
<a id="a9efa67807aa9426c64deb17ac2814af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa67807aa9426c64deb17ac2814af5">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is less than the <em>other</em>. </dd></dl>

</div>
</div>
<a id="a9b1b76e0b76968aacecf936262fd47cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1b76e0b76968aacecf936262fd47cd">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is less than or equal to <em>other</em>. </dd></dl>

</div>
</div>
<a id="ac17a5bddbcff0a442cab910a91418047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17a5bddbcff0a442cab910a91418047">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a>&amp; rttr::type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a type to another one. </p>
<dl class="section return"><dt>Returns</dt><dd>A type object. </dd></dl>

</div>
</div>
<a id="a66e3a655ae521b2acc9b98d664f7c903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e3a655ae521b2acc9b98d664f7c903">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this type with the <em>other</em> type and returns true if both describe the same type, otherwise returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both type are equal, otherwise false. </dd></dl>

</div>
</div>
<a id="a936f39e7d1fb10a973bb22e3b43c8704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936f39e7d1fb10a973bb22e3b43c8704">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is greater than the <em>other</em>. </dd></dl>

</div>
</div>
<a id="adb823dce537521ab4933035a5d0b2521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb823dce537521ab4933035a5d0b2521">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is greater than or equal to <em>other</em>. </dd></dl>

</div>
</div>
<a id="a4912d4dac773276a6142a70a40ab0543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4912d4dac773276a6142a70a40ab0543">&#9670;&nbsp;</a></span>register_comparators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::register_comparators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register comparison operators for template type <code>T</code>. </p>
<p>This requires a valid <code>operator==</code> and <code>operator&lt;</code> for type <code>T</code>.</p>
<p>The registered comparison operators will be used in the <a class="el" href="classrttr_1_1variant.html">variant</a> class.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="comment">// two variants, same content</span></div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> a = std::make_tuple&lt;int, std::string&gt;(12, std::string(<span class="stringliteral">&quot;some text&quot;</span>));</div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> b = std::make_tuple&lt;int, std::string&gt;(12, std::string(<span class="stringliteral">&quot;some text&quot;</span>));</div>
<div class="line"> </div>
<div class="line"> a == b;                <span class="comment">// yields to false</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// register comparators for type &#39;std::tuple&lt;std::string, int&gt;&#39;</span></div>
<div class="line"> type::register_comparators&lt;std::tuple&lt;std::string, int&gt;&gt;();</div>
<div class="line"> </div>
<div class="line"> a == b;                <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a37c60d6dd82d2ba2e88fc73ee9f3a950" title="Compares this variant with other and returns true if they are equal; otherwise returns false.">variant::operator==()</a>, <a class="el" href="classrttr_1_1variant.html#a234abe122450f444d9564dc96ffc4043" title="Compares this variant with other and returns true if this is less than other, otherwise returns false...">variant::operator&lt;()</a> </dd></dl>

</div>
</div>
<a id="a81f5f2ea31cc79846a829aa5737680f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f5f2ea31cc79846a829aa5737680f0">&#9670;&nbsp;</a></span>register_converter_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::register_converter_func </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a converter func <code>F</code>, which will be used internally by the <a class="el" href="classrttr_1_1variant.html">variant</a> class to convert between types. </p>
<p>This function converts a <em>source</em> type to a <em>target</em> type. The signature of this function has to be the following: <code>TargetType (SourceType, bool&amp; ok)</code></p>
<p>See following example code: </p><div class="fragment"><div class="line">std::string conv_func(<span class="keywordtype">int</span> <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>, <span class="keywordtype">bool</span>&amp; ok)</div>
<div class="line">{</div>
<div class="line">   std::string result = std::to_string(<a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>);</div>
<div class="line">   ok = <span class="keyword">true</span>;</div>
<div class="line">   <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// register the conversion function</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func</a>(conv_func);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c" title="Converts the containing variant internally to the given type target_type.">variant::convert()</a> </dd></dl>

</div>
</div>
<a id="af963b3fcb5b3af10bca20decd8566b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af963b3fcb5b3af10bca20decd8566b6c">&#9670;&nbsp;</a></span>register_equal_comparator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::register_equal_comparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register the equal comparison operators for template type <code>T</code>. </p>
<p>This requires a valid <code>operator==</code> for type <code>T</code>.</p>
<p>The registered comparison operators will be used in the <a class="el" href="classrttr_1_1variant.html">variant</a> class.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="comment">// two variants, same content</span></div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> a = std::make_tuple&lt;int, int&gt;(42, 42);</div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> b = std::make_tuple&lt;int, int&gt;(42, 42);</div>
<div class="line"> </div>
<div class="line"> a == b;                <span class="comment">// yields to false</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// register comparators for type &#39;std::tuple&lt;int, int&gt;&#39;</span></div>
<div class="line"> type::register_comparators&lt;std::tuple&lt;int, int&gt;&gt;();</div>
<div class="line"> </div>
<div class="line"> a == b;                <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a37c60d6dd82d2ba2e88fc73ee9f3a950" title="Compares this variant with other and returns true if they are equal; otherwise returns false.">variant::operator==()</a> </dd></dl>

</div>
</div>
<a id="a5c27b3dbc76884d432902420be574d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c27b3dbc76884d432902420be574d4d">&#9670;&nbsp;</a></span>register_less_than_comparator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::register_less_than_comparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register the less than comparison operators for template type <code>T</code>. </p>
<p>This requires a valid <code>operator&lt;</code> for type <code>T</code>.</p>
<p>The registered comparison operators will be used in the <a class="el" href="classrttr_1_1variant.html">variant</a> class.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_id</div>
<div class="line">{</div>
<div class="line">   my_id(<span class="keywordtype">int</span> i) : id(i) {}</div>
<div class="line">   <span class="keywordtype">bool</span> <a class="code" href="classrttr_1_1type.html#a9efa67807aa9426c64deb17ac2814af5">operator&lt;</a>(<span class="keyword">const</span> foo&amp; rhs)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">id</span> &lt; rhs.id); }</div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">int</span> id;</div>
<div class="line">};</div>
<div class="line"><span class="comment">// two variants, same content</span></div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> a = my_id(23);</div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> b = my_id(42);</div>
<div class="line"> </div>
<div class="line"> a &lt; b;                <span class="comment">// yields to false</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// register comparators for type &#39;my_id&#39;</span></div>
<div class="line"> type::register_less_than_comparator&lt;my_id&gt;();</div>
<div class="line"> </div>
<div class="line"> a &lt; b;                <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a234abe122450f444d9564dc96ffc4043" title="Compares this variant with other and returns true if this is less than other, otherwise returns false...">variant::operator&lt;()</a> </dd></dl>

</div>
</div>
<a id="a80fbbd3ac5729e695c8c2ef0fca4cbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fbbd3ac5729e695c8c2ef0fca4cbbc">&#9670;&nbsp;</a></span>register_wrapper_converter_for_base_classes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::register_wrapper_converter_for_base_classes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register for all base classes of the giving type <code>T</code> wrapper converter functions. </p>
<p>The converters are registered in both directions respectively. From derived to base class and vice versa.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>base { <span class="keyword">virtual</span> ~base() {}; <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>derived : base { <span class="keyword">virtual</span> ~derived() {}; <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(base) };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> var = std::make_shared&lt;derived&gt;();</div>
<div class="line">var.convert(<a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>&lt;std::shared_ptr&lt;base&gt;&gt;());    <span class="comment">// yields to `false`</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// register the conversion functions</span></div>
<div class="line">type::register_wrapper_converter_for_base_classes&lt;std::shared_ptr&lt;derived&gt;&gt;();</div>
<div class="line"> </div>
<div class="line">var.convert(<a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>&lt;std::shared_ptr&lt;base&gt;&gt;());    <span class="comment">// yields to `true`, derived to base conversion</span></div>
<div class="line">var.convert(<a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>&lt;std::shared_ptr&lt;derived&gt;&gt;()); <span class="comment">// yields to `true`, base to derived conversion</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c" title="Converts the containing variant internally to the given type target_type.">variant::convert()</a>, <a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper&lt;T&gt;</a> </dd></dl>

</div>
</div>
<a id="a0748930ab0ca3b8254f1bf85322f3612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748930ab0ca3b8254f1bf85322f3612">&#9670;&nbsp;</a></span>set_property_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool rttr::type::set_property_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will set the given value <code>arg</code> to a property named <code>name</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A bool value, which is true, when the value could be set, otherwise false. </dd></dl>

</div>
</div>
<a id="af57f575909bf13fa24d03ad14393204a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57f575909bf13fa24d03ad14393204a">&#9670;&nbsp;</a></span>set_property_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::set_property_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set the given value <code>arg</code> to a property named <code>name</code> to the instance <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the given instance is empty, the value of a global property with name <code>name</code> will be tryed to set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bool value, which is true, when the value could be set, otherwise false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassrttr_1_1type_html_a9b6af1ac4dd7e107cdfabb1050546724"><div class="ttname"><a href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">rttr::type::get_wrapped_type</a></div><div class="ttdeci">type get_wrapped_type() const noexcept</div><div class="ttdoc">Returns a type object which represent the wrapped type.</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html_a1e2a392693ad3d5b62ea85abdd1d6111"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html#a1e2a392693ad3d5b62ea85abdd1d6111">rttr::registration::class_::property</a></div><div class="ttdeci">bind&lt; detail::prop, Class_Type, A, acc_level, Visitor_List &gt; property(string_view name, A acc, acc_level level=acc_level())</div><div class="ttdoc">Register a property to this class.</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_afec6296ac7c1d21cda157b9cbbdf3af4"><div class="ttname"><a href="classrttr_1_1type.html#afec6296ac7c1d21cda157b9cbbdf3af4">rttr::type::type</a></div><div class="ttdeci">type(const type &amp;other) noexcept</div><div class="ttdoc">Assigns a type to another one.</div></div>
<div class="ttc" id="anamespacerttr_html_a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32"><div class="ttname"><a href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">rttr::filter_item::non_public_access</a></div><div class="ttdeci">@ non_public_access</div><div class="ttdoc">Includes all non public (private or protected) members in the search.</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html_a0c0f9b9b4a78e8eefb17f690f15e7795"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html#a0c0f9b9b4a78e8eefb17f690f15e7795">rttr::registration::class_::constructor</a></div><div class="ttdeci">bind&lt; detail::ctor, Class_Type, acc_level, Visitor_List, Args... &gt; constructor(acc_level level=acc_level())</div><div class="ttdoc">Register a constructor for this class type with or without arguments.</div></div>
<div class="ttc" id="anamespacerttr_html_a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d"><div class="ttname"><a href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d">rttr::filter_item::static_item</a></div><div class="ttdeci">@ static_item</div><div class="ttdoc">Includes all static members in the search.</div></div>
<div class="ttc" id="anamespacerttr_html_a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b"><div class="ttname"><a href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b">rttr::filter_item::public_access</a></div><div class="ttdeci">@ public_access</div><div class="ttdoc">Includes all public specified members in the search.</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a013ec8f5a1086afa8142be318ccb5c9f"><div class="ttname"><a href="classrttr_1_1type.html#a013ec8f5a1086afa8142be318ccb5c9f">rttr::type::is_template_instantiation</a></div><div class="ttdeci">bool is_template_instantiation() const noexcept</div><div class="ttdoc">Returns true whether the given type is an instantiation of a class template.</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a85ecc638e72ac4a5b43025bd0ddf5eb6"><div class="ttname"><a href="classrttr_1_1type.html#a85ecc638e72ac4a5b43025bd0ddf5eb6">rttr::type::is_array</a></div><div class="ttdeci">bool is_array() const noexcept</div><div class="ttdoc">Returns true whether the given type represents an array.</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html_a8bbc90d48413ac8b5e172d9cc4e4019f"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">rttr::registration::class_::method</a></div><div class="ttdeci">bind&lt; detail::meth, Class_Type, F, acc_level, Visitor_List &gt; method(string_view name, F f, acc_level level=acc_level())</div><div class="ttdoc">Register a method to this class.</div></div>
<div class="ttc" id="anamespacerttr_html_a54ecd8bad715cbc451e7aa8491667d4a"><div class="ttname"><a href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">rttr::value</a></div><div class="ttdeci">detail::enum_data&lt; Enum_Type &gt; value(string_view, Enum_Type value)</div><div class="ttdoc">The value function should be used to add a mapping from enum name to value during the registration pr...</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_ad4f13d06475a06f860c63bc68d0c8a4b"><div class="ttname"><a href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">rttr::type::variant</a></div><div class="ttdeci">friend class variant</div><div class="ttdef"><b>Definition:</b> type.h:1232</div></div>
<div class="ttc" id="aclassrttr_1_1registration_html_a5ac82a82df83ce2dd8c34ada18d7b904"><div class="ttname"><a href="classrttr_1_1registration.html#a5ac82a82df83ce2dd8c34ada18d7b904">rttr::registration::protected_access</a></div><div class="ttdeci">static const detail::protected_access protected_access</div><div class="ttdoc">This variable can be used to specify during registration of a class member the access level: protecte...</div><div class="ttdef"><b>Definition:</b> registration.h:433</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a81f5f2ea31cc79846a829aa5737680f0"><div class="ttname"><a href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">rttr::type::register_converter_func</a></div><div class="ttdeci">static void register_converter_func(F func)</div><div class="ttdoc">Register a converter func F, which will be used internally by the variant class to convert between ty...</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_</a></div><div class="ttdoc">The class_ is used to register classes to RTTR.</div><div class="ttdef"><b>Definition:</b> registration.h:154</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a5336e448f0881d2141be932e74fc756f"><div class="ttname"><a href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">rttr::type::get</a></div><div class="ttdeci">static type get() noexcept</div><div class="ttdoc">Returns a type object for the given template type T.</div></div>
<div class="ttc" id="aregistration_8h_html_ac6326400f16225ee15b52eabcaae8130"><div class="ttname"><a href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div><div class="ttdeci">#define RTTR_REGISTRATION</div><div class="ttdoc">Use this macro to automatically register your reflection information to RTTR before main is called.</div><div class="ttdef"><b>Definition:</b> registration.h:770</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a9efa67807aa9426c64deb17ac2814af5"><div class="ttname"><a href="classrttr_1_1type.html#a9efa67807aa9426c64deb17ac2814af5">rttr::type::operator&lt;</a></div><div class="ttdeci">bool operator&lt;(const type &amp;other) const noexcept</div><div class="ttdoc">Comparison operator for sorting the type data according to some internal criterion.</div></div>
<div class="ttc" id="anamespacerttr_html_a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da"><div class="ttname"><a href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da">rttr::filter_item::declared_only</a></div><div class="ttdeci">@ declared_only</div><div class="ttdoc">Returns all members declared for the current type; inherited members are not returned.</div></div>
<div class="ttc" id="aclassrttr_1_1registration_html_a8920352ec53e1cd44bdec18ef5e89568"><div class="ttname"><a href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a></div><div class="ttdeci">static const detail::private_access private_access</div><div class="ttdoc">This variable can be used to specify during registration of a class member the access level: private.</div><div class="ttdef"><b>Definition:</b> registration.h:459</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a6f58cffb2a57754cd6d25f71022028fd"><div class="ttname"><a href="classrttr_1_1type.html#a6f58cffb2a57754cd6d25f71022028fd">rttr::type::get_template_arguments</a></div><div class="ttdeci">array_range&lt; type &gt; get_template_arguments() const noexcept</div><div class="ttdoc">Returns a list of type objects that represents the template arguments.</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a7ba79b9f4916c30db74fe65508dca033"><div class="ttname"><a href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">rttr::type::get_by_name</a></div><div class="ttdeci">static type get_by_name(string_view name) noexcept</div><div class="ttdoc">Returns the type object with the given name name.</div></div>
<div class="ttc" id="astructrttr_1_1policy_1_1ctor_html_a1e3b8ee81a41ce6b2e075bef1620f28c"><div class="ttname"><a href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">rttr::policy::ctor::as_object</a></div><div class="ttdeci">static const detail::as_object as_object</div><div class="ttdoc">The as_object policy will create an instance of a class with automatic storage.</div><div class="ttdef"><b>Definition:</b> policy.h:356</div></div>
<div class="ttc" id="arttr__enable_8h_html_a848bcae21d3a54e07ca6450689820a59"><div class="ttname"><a href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a></div><div class="ttdeci">#define RTTR_ENABLE(...)</div><div class="ttdoc">This macro is necessary in order to retrieve type information about the inheritance graph of a class.</div><div class="ttdef"><b>Definition:</b> rttr_enable.h:76</div></div>
<div class="ttc" id="anamespacerttr_html_a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f"><div class="ttname"><a href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">rttr::filter_item::instance_item</a></div><div class="ttdeci">@ instance_item</div><div class="ttdoc">Includes all members in the search, which needs an instance to be invoked.</div></div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
