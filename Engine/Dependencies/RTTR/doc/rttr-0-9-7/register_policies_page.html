<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: Policies</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Policies </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Sometimes it is necessary to adjust the default registration behaviour of RTTR. Therefore policies were introduced. There are policies for <a class="el" href="structrttr_1_1policy_1_1ctor.html">constructors</a>, <a class="el" href="structrttr_1_1policy_1_1meth.html">methods</a> and <a class="el" href="structrttr_1_1policy_1_1prop.html">properties</a> available.</p>
<p><a class="el" href="register_policies_page.html#ctor_policy_link">Constructors</a>:</p><ul>
<li>as_object</li>
<li>as_std_shared_ptr</li>
<li>as_raw_ptr</li>
</ul>
<p><a class="el" href="register_policies_page.html#prop_policy_link">Properties</a>:</p><ul>
<li>bind_as_ptr</li>
<li>as_reference_wrapper</li>
</ul>
<p><a class="el" href="register_policies_page.html#meth_policy_link">Methods</a>:</p><ul>
<li>discard_return</li>
<li>return_ref_as_ptr</li>
</ul>
<p>For easier usage, the policies are grouped to its corresponding items; e.g. all policies for methods can be found under <code>policy::meth</code>; all policies for properties under <code>policy::prop</code> etc.</p>
<h1><a class="anchor" id="ctor_policy_link"></a>
Constructors</h1>
<h3><a class="anchor" id="autotoc_md62"></a>
as_object</h3>
<p>The <a class="el" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">as_object</a> policy will create an instance of a class with automatic storage.</p>
<p>Objects with automatic storage duration are automatically destroyed when the block in which they are created exits. Which is in our case the variant. However, that means also you don't have to deal with pointers or wrappers. In order to use this creation policy, the object must be <em>copy constructible</em>.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .<a class="code" href="classrttr_1_1registration_1_1class__.html#a0c0f9b9b4a78e8eefb17f690f15e7795">constructor</a>&lt;&gt;()</div>
<div class="line">                   (</div>
<div class="line">                       <a class="code" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">policy::ctor::as_object</a></div>
<div class="line">                   );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classrttr_1_1variant.html">variant</a> var = type::get&lt;Foo&gt;().create();   <span class="comment">// creates a new instance of &#39;Foo&#39; and moves the content into variant &#39;var&#39;</span></div>
<div class="line">  std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type</a>&lt;Foo&gt;();           <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">  <a class="code" href="classrttr_1_1variant.html">variant</a> var2 = var;                        <span class="comment">// creates a new instance of &#39;Foo&#39;, through copy construction</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;                                  <span class="comment">// the memory of the two &#39;Foo&#39; instances is freed automatically</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md63"></a>
as_std_shared_ptr</h3>
<p>The <a class="el" href="structrttr_1_1policy_1_1ctor.html#a40f2a2ef8f270cad3deabf1b83e8764c">as_std_shared_ptr</a> policy will create an instance of a class through <code>std::make_shared&lt;T&gt;</code>.</p>
<p>That means the object is wrapped into a <code>std::shared_ptr&lt;T&gt;</code>. The wrapped object is destroyed and its memory deallocated when either of the following happens:</p><ul>
<li>the last remaining variant object (which contains the <code>shared_ptr</code> owning the object is destroyed.</li>
<li>the last remaining variant owning the <code>shared_ptr</code> is assigned another object.</li>
</ul>
<p>The object is destroyed using the default deleter of <code>std::shared_ptr</code>.</p>
<p>See following example code:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .<a class="code" href="classrttr_1_1registration_1_1class__.html#a0c0f9b9b4a78e8eefb17f690f15e7795">constructor</a>&lt;&gt;()</div>
<div class="line">                   (</div>
<div class="line">                       <a class="code" href="structrttr_1_1policy_1_1ctor.html#a40f2a2ef8f270cad3deabf1b83e8764c">policy::ctor::as_std_shared_ptr</a></div>
<div class="line">                   );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classrttr_1_1variant.html">variant</a> var = type::get&lt;Foo&gt;().create();</div>
<div class="line">  std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type</a>&lt;std::shared_ptr&lt;Foo&gt;&gt;();  <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;                                          <span class="comment">// the memory for contained &#39;Foo&#39; instance is freed automatically,</span></div>
<div class="line">}                                                    <span class="comment">// because the var object is gone out of scope</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md64"></a>
as_raw_ptr</h3>
<p>The <a class="el" href="structrttr_1_1policy_1_1ctor.html#a3a8150de98f16fdad329b85f43d32da1">as_raw_ptr</a> policy will create an instance of a class as raw pointer.</p>
<p>That means the object is created with a <code>new</code>-expression and its lifetime lasts until it is destroyed using a <code>delete</code>-expression. In order to invoke the delete expression use the corresponding destructor.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .<a class="code" href="classrttr_1_1registration_1_1class__.html#a0c0f9b9b4a78e8eefb17f690f15e7795">constructor</a>&lt;&gt;()</div>
<div class="line">                  (</div>
<div class="line">                      <a class="code" href="structrttr_1_1policy_1_1ctor.html#a3a8150de98f16fdad329b85f43d32da1">policy::ctor::as_raw_ptr</a></div>
<div class="line">                  );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classrttr_1_1variant.html">variant</a> var = type::get&lt;Foo&gt;().create();</div>
<div class="line">  std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type</a>&lt;Foo*&gt;();          <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">  var.<a class="code" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">get_type</a>().<a class="code" href="classrttr_1_1type.html#a33bc44604dae75f4368428afabf364ac">destroy</a>(var);               <span class="comment">// free&#39;s the memory with &#39;delete&#39;</span></div>
<div class="line">  std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">is_valid</a>();               <span class="comment">// prints &quot;false&quot;</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="prop_policy_link"></a>
Properties</h1>
<h3><a class="anchor" id="autotoc_md65"></a>
bind_as_ptr</h3>
<p>The motivation for <a class="el" href="structrttr_1_1policy_1_1prop.html#af18a7107143029acd396d39abfd8c94c">bind_as_ptr</a> policy is to avoid expensive copies when returning a property. The default registration behaviour of RTTR is to return all values by copying the content in a variant. When you have primitive data types like integer or doubles you are good to go with the standard binding behaviour. But when you have big arrays, it would be a waste to always copy the content when retrieving or setting the value, therefore this policy was introduced.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;int&gt; vec;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                 .<a class="code" href="classrttr_1_1registration_1_1class__.html#a1e2a392693ad3d5b62ea85abdd1d6111">property</a>(<span class="stringliteral">&quot;vec&quot;</span>, &amp;Foo::vec)</div>
<div class="line">                 (</div>
<div class="line">                     <a class="code" href="structrttr_1_1policy_1_1prop.html#af18a7107143029acd396d39abfd8c94c">policy::prop::bind_as_ptr</a></div>
<div class="line">                 )</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Foo obj;</div>
<div class="line">    <span class="keyword">property</span> prop = type::get&lt;Foo&gt;().get_property(<span class="stringliteral">&quot;vec&quot;</span>);</div>
<div class="line">    <a class="code" href="classrttr_1_1variant.html">variant</a> var = prop.<a class="code" href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">get_value</a>(obj);</div>
<div class="line">    std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type</a>&lt;std::vector&lt;int&gt;*&gt;(); <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// not really necessary, but remark that now a &#39;std::vector&lt;int&gt;*&#39; is expected</span></div>
<div class="line">    prop.set_value(obj, var);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md66"></a>
as_reference_wrapper</h3>
<p>The motivation for the <a class="el" href="structrttr_1_1policy_1_1prop.html#a6e551c5748cfaad0d8f1afc353817f78">as_reference_wrapper</a> policy is the same like the <a class="el" href="structrttr_1_1policy_1_1prop.html#af18a7107143029acd396d39abfd8c94c">prop::bind_as_ptr</a> policy, avoid copy of data. The value will be wrapped inside a <code>std::reference_wrapper&lt;T&gt;</code></p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;int&gt; vec;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                 .<a class="code" href="classrttr_1_1registration_1_1class__.html#a1e2a392693ad3d5b62ea85abdd1d6111">property</a>(<span class="stringliteral">&quot;vec&quot;</span>, &amp;Foo::vec)</div>
<div class="line">                 (</div>
<div class="line">                     <a class="code" href="structrttr_1_1policy_1_1prop.html#a6e551c5748cfaad0d8f1afc353817f78">policy::prop::as_reference_wrapper</a></div>
<div class="line">                 )</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Foo obj;</div>
<div class="line">    <span class="keyword">property</span> prop = type::get&lt;Foo&gt;().get_property(<span class="stringliteral">&quot;vec&quot;</span>);</div>
<div class="line">    <a class="code" href="classrttr_1_1variant.html">variant</a> var = prop.<a class="code" href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">get_value</a>(obj);</div>
<div class="line">    std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type</a>&lt; std::reference_wrapper&lt;std::vector&lt;int&gt;&gt; &gt;(); <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// not really necessary, but remark that now a &#39;std::reference_wrapper&lt;std::vector&lt;int&gt;&gt;&#39; is expected</span></div>
<div class="line">    prop.set_value(obj, var);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="meth_policy_link"></a>
Methods</h1>
<h3><a class="anchor" id="autotoc_md67"></a>
discard_return</h3>
<p>Sometimes it is necessary that the client caller should ignore the return value of a method call. Therefore <a class="el" href="structrttr_1_1policy_1_1meth.html#a1797eaaddcd48aa0de8edd79ea9070f9">discard_return</a> policy was introduced.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> calculate_func() { <span class="keywordflow">return</span> 42; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                 .<a class="code" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">method</a>(<span class="stringliteral">&quot;get_value&quot;</span>, &amp;Foo::calculate_func)</div>
<div class="line">                 (</div>
<div class="line">                     <a class="code" href="structrttr_1_1policy_1_1meth.html#a1797eaaddcd48aa0de8edd79ea9070f9">policy::meth::discard_return</a></div>
<div class="line">                 );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Foo obj;</div>
<div class="line">    <a class="code" href="classrttr_1_1method.html">method</a> meth  = type::get&lt;Foo&gt;().get_method(<span class="stringliteral">&quot;calculate_func&quot;</span>);</div>
<div class="line">    <a class="code" href="classrttr_1_1variant.html">variant</a> var = meth.<a class="code" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke</a>(obj);</div>
<div class="line">    std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type</a>&lt;<span class="keywordtype">void</span>&gt;(); <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md68"></a>
return_ref_as_ptr</h3>
<p>The motivation for the <a class="el" href="structrttr_1_1policy_1_1meth.html#ad67ab6cccd0eefa54b80a83851105018">return_ref_as_ptr</a> policy is the same like the <a class="el" href="structrttr_1_1policy_1_1prop.html#af18a7107143029acd396d39abfd8c94c">prop::bind_as_ptr</a> policy. When you really need to get a reference to the return value of a method call you have to use this policy, otherwise the returned reference will be copied into the variant.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::string&amp; get_text() { <span class="keyword">static</span> std::string text; <span class="keywordflow">return</span> text; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                 .<a class="code" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">method</a>(<span class="stringliteral">&quot;get_text&quot;</span>, &amp;Foo::get_text)</div>
<div class="line">                 (</div>
<div class="line">                     <a class="code" href="structrttr_1_1policy_1_1meth.html#ad67ab6cccd0eefa54b80a83851105018">policy::meth::return_ref_as_ptr</a></div>
<div class="line">                 );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Foo obj;</div>
<div class="line">    <a class="code" href="classrttr_1_1method.html">method</a> meth  = type::get&lt;Foo&gt;().get_method(<span class="stringliteral">&quot;get_text&quot;</span>);</div>
<div class="line">    <a class="code" href="classrttr_1_1variant.html">variant</a> var = meth.<a class="code" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke</a>(obj);</div>
<div class="line">    std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type</a>&lt;std::string*&gt;(); <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>A closing hint: you can of course build your own policies in that way, that you build wrappers around your properties or methods and then bind the wrapper instead of the original accessor.</p>
<hr  />
<div type="button" class="btn btn-default doxy-button"><a class="el" href="parameter_names_page.html">previous</a></div><div class="btn btn-default doxy-button"><a class="el" href="register_plugins.html">next</a></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="astructrttr_1_1policy_1_1meth_html_a1797eaaddcd48aa0de8edd79ea9070f9"><div class="ttname"><a href="structrttr_1_1policy_1_1meth.html#a1797eaaddcd48aa0de8edd79ea9070f9">rttr::policy::meth::discard_return</a></div><div class="ttdeci">static const detail::discard_return discard_return</div><div class="ttdoc">This policy should be used when the return value of a method should not be forwarded to the caller.</div><div class="ttdef"><b>Definition:</b> policy.h:191</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html_a1e2a392693ad3d5b62ea85abdd1d6111"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html#a1e2a392693ad3d5b62ea85abdd1d6111">rttr::registration::class_::property</a></div><div class="ttdeci">bind&lt; detail::prop, Class_Type, A, acc_level, Visitor_List &gt; property(string_view name, A acc, acc_level level=acc_level())</div><div class="ttdoc">Register a property to this class.</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html_a8a2fe635a8452ac3a2370589d6fc4bfb"><div class="ttname"><a href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">rttr::variant::is_type</a></div><div class="ttdeci">bool is_type() const</div><div class="ttdoc">Returns true if the containing variant data is of the given template type T.</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html_a0c0f9b9b4a78e8eefb17f690f15e7795"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html#a0c0f9b9b4a78e8eefb17f690f15e7795">rttr::registration::class_::constructor</a></div><div class="ttdeci">bind&lt; detail::ctor, Class_Type, acc_level, Visitor_List, Args... &gt; constructor(acc_level level=acc_level())</div><div class="ttdoc">Register a constructor for this class type with or without arguments.</div></div>
<div class="ttc" id="anamespacerttr_html"><div class="ttname"><a href="namespacerttr.html">rttr</a></div><div class="ttdef"><b>Definition:</b> access_levels.h:33</div></div>
<div class="ttc" id="astructrttr_1_1policy_1_1prop_html_a6e551c5748cfaad0d8f1afc353817f78"><div class="ttname"><a href="structrttr_1_1policy_1_1prop.html#a6e551c5748cfaad0d8f1afc353817f78">rttr::policy::prop::as_reference_wrapper</a></div><div class="ttdeci">static const detail::as_reference_wrapper as_reference_wrapper</div><div class="ttdoc">The as_reference_wrapper policy will bind a member object as std::reference_wrapper type.</div><div class="ttdef"><b>Definition:</b> policy.h:243</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html_a8bbc90d48413ac8b5e172d9cc4e4019f"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">rttr::registration::class_::method</a></div><div class="ttdeci">bind&lt; detail::meth, Class_Type, F, acc_level, Visitor_List &gt; method(string_view name, F f, acc_level level=acc_level())</div><div class="ttdoc">Register a method to this class.</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html_aed6e6a2e29b4d1ac51a09b7d9037dd44"><div class="ttname"><a href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">rttr::variant::is_valid</a></div><div class="ttdeci">bool is_valid() const</div><div class="ttdoc">Returns true if this variant is valid, that means the variant is holding some data.</div></div>
<div class="ttc" id="aclassrttr_1_1method_html_aea4351075b4cbe6f2f2b6500cf226f20"><div class="ttname"><a href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">rttr::method::invoke</a></div><div class="ttdeci">variant invoke(instance object) const</div><div class="ttdoc">Invokes the method represented by the current instance object.</div></div>
<div class="ttc" id="astructrttr_1_1policy_1_1meth_html_ad67ab6cccd0eefa54b80a83851105018"><div class="ttname"><a href="structrttr_1_1policy_1_1meth.html#ad67ab6cccd0eefa54b80a83851105018">rttr::policy::meth::return_ref_as_ptr</a></div><div class="ttdeci">static const detail::return_as_ptr return_ref_as_ptr</div><div class="ttdoc">This policy can be used when a method return a reference to an object and the caller should be able t...</div><div class="ttdef"><b>Definition:</b> policy.h:161</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_</a></div><div class="ttdoc">The class_ is used to register classes to RTTR.</div><div class="ttdef"><b>Definition:</b> registration.h:154</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a33bc44604dae75f4368428afabf364ac"><div class="ttname"><a href="classrttr_1_1type.html#a33bc44604dae75f4368428afabf364ac">rttr::type::destroy</a></div><div class="ttdeci">bool destroy(variant &amp;obj) const noexcept</div><div class="ttdoc">Destroys the contained object in the variant obj.</div></div>
<div class="ttc" id="aregistration_8h_html_ac6326400f16225ee15b52eabcaae8130"><div class="ttname"><a href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div><div class="ttdeci">#define RTTR_REGISTRATION</div><div class="ttdoc">Use this macro to automatically register your reflection information to RTTR before main is called.</div><div class="ttdef"><b>Definition:</b> registration.h:770</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html_aa3a9f7e07cdc4d922a4e09882c5c0574"><div class="ttname"><a href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">rttr::variant::get_value</a></div><div class="ttdeci">T &amp; get_value()</div><div class="ttdoc">Returns a reference to the containing value as type T.</div></div>
<div class="ttc" id="astructrttr_1_1policy_1_1ctor_html_a40f2a2ef8f270cad3deabf1b83e8764c"><div class="ttname"><a href="structrttr_1_1policy_1_1ctor.html#a40f2a2ef8f270cad3deabf1b83e8764c">rttr::policy::ctor::as_std_shared_ptr</a></div><div class="ttdeci">static const detail::as_std_shared_ptr as_std_shared_ptr</div><div class="ttdoc">The as_std_shared_ptr policy will create an instance of a class through std::make_shared&lt;T&gt;.</div><div class="ttdef"><b>Definition:</b> policy.h:321</div></div>
<div class="ttc" id="aclassrttr_1_1method_html"><div class="ttname"><a href="classrttr_1_1method.html">rttr::method</a></div><div class="ttdoc">The method class provides several meta information about a method and can be invoked.</div><div class="ttdef"><b>Definition:</b> method.h:146</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html"><div class="ttname"><a href="classrttr_1_1variant.html">rttr::variant</a></div><div class="ttdoc">The variant class allows to store data of any type and convert between these types transparently.</div><div class="ttdef"><b>Definition:</b> variant.h:223</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html_a7a72579286ed164225c5be882ab6ea81"><div class="ttname"><a href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">rttr::variant::get_type</a></div><div class="ttdeci">type get_type() const</div><div class="ttdoc">Returns the type object of underlying data.</div></div>
<div class="ttc" id="astructrttr_1_1policy_1_1prop_html_af18a7107143029acd396d39abfd8c94c"><div class="ttname"><a href="structrttr_1_1policy_1_1prop.html#af18a7107143029acd396d39abfd8c94c">rttr::policy::prop::bind_as_ptr</a></div><div class="ttdeci">static const detail::bind_as_ptr bind_as_ptr</div><div class="ttdoc">The bind_as_ptr policy will bind a member object as pointer type.</div><div class="ttdef"><b>Definition:</b> policy.h:208</div></div>
<div class="ttc" id="astructrttr_1_1policy_1_1ctor_html_a1e3b8ee81a41ce6b2e075bef1620f28c"><div class="ttname"><a href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">rttr::policy::ctor::as_object</a></div><div class="ttdeci">static const detail::as_object as_object</div><div class="ttdoc">The as_object policy will create an instance of a class with automatic storage.</div><div class="ttdef"><b>Definition:</b> policy.h:356</div></div>
<div class="ttc" id="astructrttr_1_1policy_1_1ctor_html_a3a8150de98f16fdad329b85f43d32da1"><div class="ttname"><a href="structrttr_1_1policy_1_1ctor.html#a3a8150de98f16fdad329b85f43d32da1">rttr::policy::ctor::as_raw_ptr</a></div><div class="ttdeci">static const detail::as_raw_pointer as_raw_ptr</div><div class="ttdoc">The as_raw_ptr policy will create an instance of a class as raw pointer.</div><div class="ttdef"><b>Definition:</b> policy.h:285</div></div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
