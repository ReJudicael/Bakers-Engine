<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr::associative_container_mapper&lt; T &gt; Struct Template Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="structrttr_1_1associative__container__mapper.html">associative_container_mapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structrttr_1_1associative__container__mapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::associative_container_mapper&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="structrttr_1_1associative__container__mapper.html">associative_container_mapper</a> class is a class template to access an associative container via one common interface.  
 <a href="structrttr_1_1associative__container__mapper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="associative__mapper_8h_source.html">associative_mapper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2418dc59daf48c985db7c8bf50143959"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> = typename T::const_iterator</td></tr>
<tr class="memdesc:a2418dc59daf48c985db7c8bf50143959"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias delcaration to the const iterator.  <a href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">More...</a><br /></td></tr>
<tr class="separator:a2418dc59daf48c985db7c8bf50143959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ffd67de017b43397169103e6ff1bed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> = T</td></tr>
<tr class="memdesc:a26ffd67de017b43397169103e6ff1bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias declaration to the container type itself.  <a href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">More...</a><br /></td></tr>
<tr class="separator:a26ffd67de017b43397169103e6ff1bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d2d5f862d839386bfba1dff51d42d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> = typename T::iterator</td></tr>
<tr class="memdesc:a72d2d5f862d839386bfba1dff51d42d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias delcaration to the iterator.  <a href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">More...</a><br /></td></tr>
<tr class="separator:a72d2d5f862d839386bfba1dff51d42d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07287bff9d5b990e92f8dfa214ccaad4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> = typename T::key_type</td></tr>
<tr class="memdesc:a07287bff9d5b990e92f8dfa214ccaad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias to the key type.  <a href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">More...</a><br /></td></tr>
<tr class="separator:a07287bff9d5b990e92f8dfa214ccaad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1673b17d6f51ec8ea863491d98921db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a> = typename T::mapped_type</td></tr>
<tr class="separator:ad1673b17d6f51ec8ea863491d98921db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a265f6dfb5354db8b7013c34cf63e0003"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a265f6dfb5354db8b7013c34cf63e0003">begin</a> (const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container)</td></tr>
<tr class="memdesc:a265f6dfb5354db8b7013c34cf63e0003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="structrttr_1_1associative__container__mapper.html#a265f6dfb5354db8b7013c34cf63e0003">More...</a><br /></td></tr>
<tr class="separator:a265f6dfb5354db8b7013c34cf63e0003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c4640bb0e7f8429881cf44633c4047"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a09c4640bb0e7f8429881cf44633c4047">begin</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container)</td></tr>
<tr class="memdesc:a09c4640bb0e7f8429881cf44633c4047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="structrttr_1_1associative__container__mapper.html#a09c4640bb0e7f8429881cf44633c4047">More...</a><br /></td></tr>
<tr class="separator:a09c4640bb0e7f8429881cf44633c4047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd139f88e50df36a2820846f8cca3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#ab7cd139f88e50df36a2820846f8cca3e">clear</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container)</td></tr>
<tr class="memdesc:ab7cd139f88e50df36a2820846f8cca3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the container.  <a href="structrttr_1_1associative__container__mapper.html#ab7cd139f88e50df36a2820846f8cca3e">More...</a><br /></td></tr>
<tr class="separator:ab7cd139f88e50df36a2820846f8cca3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3fd3b1ff89cab13c1354e8011290a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#abe3fd3b1ff89cab13c1354e8011290a4">end</a> (const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container)</td></tr>
<tr class="memdesc:abe3fd3b1ff89cab13c1354e8011290a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="structrttr_1_1associative__container__mapper.html#abe3fd3b1ff89cab13c1354e8011290a4">More...</a><br /></td></tr>
<tr class="separator:abe3fd3b1ff89cab13c1354e8011290a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911fbeace8bcc94bddb1dc390ccf93f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a911fbeace8bcc94bddb1dc390ccf93f3">end</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container)</td></tr>
<tr class="memdesc:a911fbeace8bcc94bddb1dc390ccf93f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="structrttr_1_1associative__container__mapper.html#a911fbeace8bcc94bddb1dc390ccf93f3">More...</a><br /></td></tr>
<tr class="separator:a911fbeace8bcc94bddb1dc390ccf93f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad859eabc71a8c92540d7c046c674d129"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>, <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#ad859eabc71a8c92540d7c046c674d129">equal_range</a> (const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container, const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;key)</td></tr>
<tr class="memdesc:ad859eabc71a8c92540d7c046c674d129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container.  <a href="structrttr_1_1associative__container__mapper.html#ad859eabc71a8c92540d7c046c674d129">More...</a><br /></td></tr>
<tr class="separator:ad859eabc71a8c92540d7c046c674d129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfdd0e7c1e034e9628f12ce5310ab32"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>, <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a0cfdd0e7c1e034e9628f12ce5310ab32">equal_range</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container, const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;key)</td></tr>
<tr class="memdesc:a0cfdd0e7c1e034e9628f12ce5310ab32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container.  <a href="structrttr_1_1associative__container__mapper.html#a0cfdd0e7c1e034e9628f12ce5310ab32">More...</a><br /></td></tr>
<tr class="separator:a0cfdd0e7c1e034e9628f12ce5310ab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfece5d50acd4f82d088cda5b623470"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#aadfece5d50acd4f82d088cda5b623470">erase</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container, const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;key)</td></tr>
<tr class="memdesc:aadfece5d50acd4f82d088cda5b623470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="structrttr_1_1associative__container__mapper.html#aadfece5d50acd4f82d088cda5b623470">More...</a><br /></td></tr>
<tr class="separator:aadfece5d50acd4f82d088cda5b623470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a573fe30983be464e1bc1242f15e17d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a6a573fe30983be464e1bc1242f15e17d">find</a> (const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container, const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;key)</td></tr>
<tr class="memdesc:a6a573fe30983be464e1bc1242f15e17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key and returns its iterator.  <a href="structrttr_1_1associative__container__mapper.html#a6a573fe30983be464e1bc1242f15e17d">More...</a><br /></td></tr>
<tr class="separator:a6a573fe30983be464e1bc1242f15e17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa40dcbc832d12a004bf5ed43c804d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#affa40dcbc832d12a004bf5ed43c804d8">find</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container, const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;key)</td></tr>
<tr class="memdesc:affa40dcbc832d12a004bf5ed43c804d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key and returns its iterator.  <a href="structrttr_1_1associative__container__mapper.html#affa40dcbc832d12a004bf5ed43c804d8">More...</a><br /></td></tr>
<tr class="separator:affa40dcbc832d12a004bf5ed43c804d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c842e3002ee4570b979790766e85425"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a8c842e3002ee4570b979790766e85425">get_key</a> (const <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> &amp;itr)</td></tr>
<tr class="memdesc:a8c842e3002ee4570b979790766e85425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current iterator's key as a const reference.  <a href="structrttr_1_1associative__container__mapper.html#a8c842e3002ee4570b979790766e85425">More...</a><br /></td></tr>
<tr class="separator:a8c842e3002ee4570b979790766e85425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4341d43b6b7766a04b6cb0959dfd68"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#aea4341d43b6b7766a04b6cb0959dfd68">get_size</a> (const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container)</td></tr>
<tr class="memdesc:aea4341d43b6b7766a04b6cb0959dfd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="structrttr_1_1associative__container__mapper.html#aea4341d43b6b7766a04b6cb0959dfd68">More...</a><br /></td></tr>
<tr class="separator:aea4341d43b6b7766a04b6cb0959dfd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bc11767c532b63e574344f7dfff22a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a40bc11767c532b63e574344f7dfff22a">get_value</a> (const <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> &amp;itr)</td></tr>
<tr class="memdesc:a40bc11767c532b63e574344f7dfff22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current iterator's value as const reference.  <a href="structrttr_1_1associative__container__mapper.html#a40bc11767c532b63e574344f7dfff22a">More...</a><br /></td></tr>
<tr class="separator:a40bc11767c532b63e574344f7dfff22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919e8945f98f99bb2fa564967dc0796"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#af919e8945f98f99bb2fa564967dc0796">get_value</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> &amp;itr)</td></tr>
<tr class="memdesc:af919e8945f98f99bb2fa564967dc0796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current iterator's value as reference.  <a href="structrttr_1_1associative__container__mapper.html#af919e8945f98f99bb2fa564967dc0796">More...</a><br /></td></tr>
<tr class="separator:af919e8945f98f99bb2fa564967dc0796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a8d86de0de26bb717872a444ada20"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#af00a8d86de0de26bb717872a444ada20">insert_key</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container, const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;key)</td></tr>
<tr class="memdesc:af00a8d86de0de26bb717872a444ada20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a key into the container.  <a href="structrttr_1_1associative__container__mapper.html#af00a8d86de0de26bb717872a444ada20">More...</a><br /></td></tr>
<tr class="separator:af00a8d86de0de26bb717872a444ada20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad022985d0bc75de68cb1b236190545"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#aaad022985d0bc75de68cb1b236190545">insert_key_value</a> (<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container, const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;key, const <a class="el" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a> &amp;<a class="el" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>)</td></tr>
<tr class="memdesc:aaad022985d0bc75de68cb1b236190545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a key-value into the container.  <a href="structrttr_1_1associative__container__mapper.html#aaad022985d0bc75de68cb1b236190545">More...</a><br /></td></tr>
<tr class="separator:aaad022985d0bc75de68cb1b236190545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6284476f38dedeb4b0a6ec84a8299556"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html#a6284476f38dedeb4b0a6ec84a8299556">is_empty</a> (const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;container)</td></tr>
<tr class="memdesc:a6284476f38dedeb4b0a6ec84a8299556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="structrttr_1_1associative__container__mapper.html#a6284476f38dedeb4b0a6ec84a8299556">More...</a><br /></td></tr>
<tr class="separator:a6284476f38dedeb4b0a6ec84a8299556"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct rttr::associative_container_mapper&lt; T &gt;</h3>

<p>The <a class="el" href="structrttr_1_1associative__container__mapper.html">associative_container_mapper</a> class is a class template to access an associative container via one common interface. </p>
<p>This class will be only used internally by RTTR via the <a class="el" href="classrttr_1_1variant__associative__view.html" title="The variant_associative_view describes a class that refers to an associative container (e....">variant_associative_view</a> class to get access to elements of an associative container. In order to use your own custom associative container type, you have to provide a specialization of this class.</p>
<p>Out of the box, RTTR has specialization for following associative container types:</p><ul>
<li><code><code>std::set&lt;Key&gt;</code></code> </li>
<li><code><code>std::map&lt;Key</code>, T&gt;</code></li>
<li><code><code>std::multiset&lt;Key&gt;</code></code> </li>
<li><code><code>std::multimap&lt;Key</code>, T&gt;</code></li>
<li><code><code>std::unordered_set&lt;Key&gt;</code></code> </li>
<li><code><code>std::unordered_map&lt;Key</code>, T&gt;</code></li>
<li><code><code>std::unordered_multiset&lt;Key&gt;</code></code> </li>
<li><code><code>std::unordered_multimap&lt;Key</code>, T&gt;</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md0"></a>
Custom associative container</h2>
<p>For a specialization of the class <a class="el" href="structrttr_1_1associative__container__mapper.html">associative_container_mapper&lt;T&gt;</a> you have to provide some nested alias templates:</p><ol type="1">
<li><code>using container_t = T;</code></li>
<li><code>using key_t = typename T::key_type;</code></li>
<li><code>using value_t = typename T::mapped_type;</code> <dl class="section remark"><dt>Remarks</dt><dd>When you have a key-only container, like <code>std::set&lt;T&gt;</code>, use <code>void</code>; i.e. <code>using value_t = void;</code></dd></dl>
</li>
<li><code>using itr_t = typename T::iterator;</code></li>
<li><code>using const_itr_t = typename T::const_iterator;</code></li>
</ol>
<p>and following member functions:</p><ol type="1">
<li><code>static const key_t&amp; <a class="el" href="structrttr_1_1associative__container__mapper.html#a8c842e3002ee4570b979790766e85425" title="Returns the current iterator&#39;s key as a const reference.">get_key(const const_itr_t&amp; itr)</a>;</code></li>
<li><code>static value_t&amp; <a class="el" href="structrttr_1_1associative__container__mapper.html#af919e8945f98f99bb2fa564967dc0796" title="Returns the current iterator&#39;s value as reference.">get_value(itr_t&amp; itr)</a>;</code></li>
<li><code>static const value_t&amp; <a class="el" href="structrttr_1_1associative__container__mapper.html#a40bc11767c532b63e574344f7dfff22a" title="Returns the current iterator&#39;s value as const reference.">get_value(const const_itr_t&amp; itr)</a>;</code></li>
<li><code>static itr_t <a class="el" href="structrttr_1_1associative__container__mapper.html#a09c4640bb0e7f8429881cf44633c4047" title="Returns an iterator to the first element of the container.">begin(container_t&amp; container)</a>;</code></li>
<li><code>static const_itr_t <a class="el" href="structrttr_1_1associative__container__mapper.html#a265f6dfb5354db8b7013c34cf63e0003" title="Returns an iterator to the first element of the container.">begin(const container_t&amp; container)</a>;</code></li>
<li><code>static const_itr_t <a class="el" href="structrttr_1_1associative__container__mapper.html#abe3fd3b1ff89cab13c1354e8011290a4" title="Returns an iterator to the element following the last element of the container.">end(const container_t&amp; container)</a>;</code></li>
<li><code>static itr_t <a class="el" href="structrttr_1_1associative__container__mapper.html#affa40dcbc832d12a004bf5ed43c804d8" title="Finds an element with key equivalent to key and returns its iterator.">find(container_t&amp; container, const key_t&amp; key)</a>;</code></li>
<li><code>static const_itr_t <a class="el" href="structrttr_1_1associative__container__mapper.html#a6a573fe30983be464e1bc1242f15e17d" title="Finds an element with key equivalent to key and returns its iterator.">find(const container_t&amp; container, const key_t&amp; key)</a>;</code></li>
<li><code>static std::pair&lt;itr_t, itr_t&gt; <a class="el" href="structrttr_1_1associative__container__mapper.html#a0cfdd0e7c1e034e9628f12ce5310ab32" title="Returns a range containing all elements with the given key in the container.">equal_range(container_t&amp; container, const key_t&amp; key)</a>;</code></li>
<li><code>static std::pair&lt;const_itr_t, const_itr_t&gt; <a class="el" href="structrttr_1_1associative__container__mapper.html#ad859eabc71a8c92540d7c046c674d129" title="Returns a range containing all elements with the given key in the container.">equal_range(const container_t&amp; container, const key_t&amp; key)</a>;</code></li>
<li><code>static void <a class="el" href="structrttr_1_1associative__container__mapper.html#ab7cd139f88e50df36a2820846f8cca3e" title="Removes all elements from the container.">clear(container_t&amp; container)</a>;</code></li>
<li><code>static bool <a class="el" href="structrttr_1_1associative__container__mapper.html#a6284476f38dedeb4b0a6ec84a8299556" title="Returns the number of elements in the container.">is_empty(const container_t&amp; container)</a>;</code></li>
<li><code>static std::size_t <a class="el" href="structrttr_1_1associative__container__mapper.html#aea4341d43b6b7766a04b6cb0959dfd68" title="Returns the number of elements in the container.">get_size(const container_t&amp; container)</a>;</code></li>
<li><code>static std::size_t <a class="el" href="structrttr_1_1associative__container__mapper.html#aadfece5d50acd4f82d088cda5b623470" title="Removes the element (if one exists) with the key equivalent to key.">erase(container_t&amp; container, const key_t&amp; key)</a>;</code></li>
<li><code>static std::pair&lt;itr_t, bool&gt; <a class="el" href="structrttr_1_1associative__container__mapper.html#af00a8d86de0de26bb717872a444ada20" title="Inserts a key into the container.">insert_key(container_t&amp; container, const key_t&amp; key)</a>;</code> <dl class="section remark"><dt>Remarks</dt><dd>This method needs to be implemented only when you have a key-only container.</dd></dl>
</li>
<li><code>static std::pair&lt;itr_t, bool&gt; <a class="el" href="structrttr_1_1associative__container__mapper.html#aaad022985d0bc75de68cb1b236190545" title="Inserts a key-value into the container.">insert_key_value(container_t&amp; container, const key_t&amp; key, const value_t&amp; value)</a>;</code> <dl class="section remark"><dt>Remarks</dt><dd>This method needs to be implemented only when you have a key-value container.</dd></dl>
Following code example for the associative container <a href="http://doc.qt.io/qt-5/qhash.html" target="_blank">QHash&lt;K, T&gt;</a> illustrates how to add a specialization:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacerttr.html">rttr</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>associative_container_mapper&lt;QHash&lt;K, T&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>   = QHash&lt;K, T&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>         = <span class="keyword">typename</span> QHash&lt;K, T&gt;::key_type;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a>       = <span class="keyword">typename</span> QHash&lt;K, T&gt;::mapped_type;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>         = <span class="keyword">typename</span> QHash&lt;K, T&gt;::iterator;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>   = <span class="keyword">typename</span> QHash&lt;K, T&gt;::const_iterator;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>&amp; <a class="code" href="structrttr_1_1associative__container__mapper.html#a8c842e3002ee4570b979790766e85425">get_key</a>(<span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>&amp; itr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> itr.key();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a>&amp; <a class="code" href="structrttr_1_1associative__container__mapper.html#af919e8945f98f99bb2fa564967dc0796">get_value</a>(<a class="code" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>&amp; itr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> itr.value();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a>&amp; <a class="code" href="structrttr_1_1associative__container__mapper.html#af919e8945f98f99bb2fa564967dc0796">get_value</a>(<span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>&amp; itr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> itr.value();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> <a class="code" href="structrttr_1_1associative__container__mapper.html#a09c4640bb0e7f8429881cf44633c4047">begin</a>(<a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.begin();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> <a class="code" href="structrttr_1_1associative__container__mapper.html#a09c4640bb0e7f8429881cf44633c4047">begin</a>(<span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.begin();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> <a class="code" href="structrttr_1_1associative__container__mapper.html#a911fbeace8bcc94bddb1dc390ccf93f3">end</a>(<a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.end();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> <a class="code" href="structrttr_1_1associative__container__mapper.html#a911fbeace8bcc94bddb1dc390ccf93f3">end</a>(<span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.end();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> <a class="code" href="structrttr_1_1associative__container__mapper.html#affa40dcbc832d12a004bf5ed43c804d8">find</a>(<a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container, <a class="code" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>&amp; key)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.find(key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> <a class="code" href="structrttr_1_1associative__container__mapper.html#affa40dcbc832d12a004bf5ed43c804d8">find</a>(<span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container, <a class="code" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>&amp; key)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.find(key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::pair&lt;itr_t, itr_t&gt; <a class="code" href="structrttr_1_1associative__container__mapper.html#a0cfdd0e7c1e034e9628f12ce5310ab32">equal_range</a>(<a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container, <a class="code" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>&amp; key)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> ret = container.equal_range(key);</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(ret.first, ret.second);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::pair&lt;const_itr_t, const_itr_t&gt; <a class="code" href="structrttr_1_1associative__container__mapper.html#a0cfdd0e7c1e034e9628f12ce5310ab32">equal_range</a>(<span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container, <a class="code" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>&amp; key)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> ret = container.equal_range(key);</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(ret.first, ret.second);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#ab7cd139f88e50df36a2820846f8cca3e">clear</a>(<a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        container.clear();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a6284476f38dedeb4b0a6ec84a8299556">is_empty</a>(<span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.isEmpty();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::size_t <a class="code" href="structrttr_1_1associative__container__mapper.html#aea4341d43b6b7766a04b6cb0959dfd68">get_size</a>(<span class="keyword">const</span> <a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.size();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::size_t <a class="code" href="structrttr_1_1associative__container__mapper.html#aadfece5d50acd4f82d088cda5b623470">erase</a>(<a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container, <a class="code" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>&amp; key)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> container.remove(key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::pair&lt;itr_t, bool&gt; <a class="code" href="structrttr_1_1associative__container__mapper.html#aaad022985d0bc75de68cb1b236190545">insert_key_value</a>(<a class="code" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a>&amp; container, <a class="code" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>&amp; key, <a class="code" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a>&amp; <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(container.insert(key, <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>), <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// end namespace rttr</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Make sure you put your specialization inside the namespace <code>rttr</code>. The best place for this code, is below the declaration of your custom associative container type. When this is not possible, include your specialization code before registering your types to RTTR. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2418dc59daf48c985db7c8bf50143959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2418dc59daf48c985db7c8bf50143959">&#9670;&nbsp;</a></span>const_itr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::<a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> =  typename T::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias delcaration to the const iterator. </p>

</div>
</div>
<a id="a26ffd67de017b43397169103e6ff1bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ffd67de017b43397169103e6ff1bed">&#9670;&nbsp;</a></span>container_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::<a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias declaration to the container type itself. </p>

</div>
</div>
<a id="a72d2d5f862d839386bfba1dff51d42d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d2d5f862d839386bfba1dff51d42d3">&#9670;&nbsp;</a></span>itr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::<a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> =  typename T::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias delcaration to the iterator. </p>

</div>
</div>
<a id="a07287bff9d5b990e92f8dfa214ccaad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07287bff9d5b990e92f8dfa214ccaad4">&#9670;&nbsp;</a></span>key_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::<a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> =  typename T::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias to the key type. </p>

</div>
</div>
<a id="ad1673b17d6f51ec8ea863491d98921db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1673b17d6f51ec8ea863491d98921db">&#9670;&nbsp;</a></span>value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::<a class="el" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a> =  typename T::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias to the value type. </p><dl class="section remark"><dt>Remarks</dt><dd>When you have a key only container use <code>void</code> as value type. Then you also dont need to add a <a class="el" href="structrttr_1_1associative__container__mapper.html#aaad022985d0bc75de68cb1b236190545" title="Inserts a key-value into the container.">insert_key_value()</a> function </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a265f6dfb5354db8b7013c34cf63e0003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265f6dfb5354db8b7013c34cf63e0003">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="a09c4640bb0e7f8429881cf44633c4047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c4640bb0e7f8429881cf44633c4047">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="ab7cd139f88e50df36a2820846f8cca3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cd139f88e50df36a2820846f8cca3e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the container. </p>

</div>
</div>
<a id="abe3fd3b1ff89cab13c1354e8011290a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3fd3b1ff89cab13c1354e8011290a4">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="a911fbeace8bcc94bddb1dc390ccf93f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911fbeace8bcc94bddb1dc390ccf93f3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="ad859eabc71a8c92540d7c046c674d129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad859eabc71a8c92540d7c046c674d129">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;<a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>, <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a>&gt; <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. </p>
<p>The range is defined by two constant iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. </p>

</div>
</div>
<a id="a0cfdd0e7c1e034e9628f12ce5310ab32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfdd0e7c1e034e9628f12ce5310ab32">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;<a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>, <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>&gt; <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. </p>
<p>The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. </p>

</div>
</div>
<a id="aadfece5d50acd4f82d088cda5b623470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfece5d50acd4f82d088cda5b623470">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>

</div>
</div>
<a id="a6a573fe30983be464e1bc1242f15e17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a573fe30983be464e1bc1242f15e17d">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key and returns its iterator. </p>

</div>
</div>
<a id="affa40dcbc832d12a004bf5ed43c804d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa40dcbc832d12a004bf5ed43c804d8">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key and returns its iterator. </p>

</div>
</div>
<a id="a8c842e3002ee4570b979790766e85425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c842e3002ee4570b979790766e85425">&#9670;&nbsp;</a></span>get_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a>&amp; <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::get_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current iterator's key as a const reference. </p>

</div>
</div>
<a id="aea4341d43b6b7766a04b6cb0959dfd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4341d43b6b7766a04b6cb0959dfd68">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>

</div>
</div>
<a id="a40bc11767c532b63e574344f7dfff22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bc11767c532b63e574344f7dfff22a">&#9670;&nbsp;</a></span>get_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a>&amp; <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">const_itr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current iterator's value as const reference. </p>

</div>
</div>
<a id="af919e8945f98f99bb2fa564967dc0796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af919e8945f98f99bb2fa564967dc0796">&#9670;&nbsp;</a></span>get_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a>&amp; <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::get_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current iterator's value as reference. </p>

</div>
</div>
<a id="af00a8d86de0de26bb717872a444ada20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a8d86de0de26bb717872a444ada20">&#9670;&nbsp;</a></span>insert_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;<a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>, bool&gt; <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::insert_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a key into the container. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only necessary, when you have a key-only container. Like <code>std::set&lt;T&gt;</code>. Otherwise you don't need to declare it. </dd></dl>

</div>
</div>
<a id="aaad022985d0bc75de68cb1b236190545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad022985d0bc75de68cb1b236190545">&#9670;&nbsp;</a></span>insert_key_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;<a class="el" href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">itr_t</a>, bool&gt; <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::insert_key_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">key_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">value_t</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a key-value into the container. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only necessary, when you have a key-value container. Like <code>std::map&lt;T&gt;</code>. Otherwise you don't need to declare it. </dd></dl>

</div>
</div>
<a id="a6284476f38dedeb4b0a6ec84a8299556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6284476f38dedeb4b0a6ec84a8299556">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structrttr_1_1associative__container__mapper.html">rttr::associative_container_mapper</a>&lt; T &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">container_t</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="associative__mapper_8h_source.html">associative_mapper.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_ad1673b17d6f51ec8ea863491d98921db"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#ad1673b17d6f51ec8ea863491d98921db">rttr::associative_container_mapper::value_t</a></div><div class="ttdeci">typename T::mapped_type value_t</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:247</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_af919e8945f98f99bb2fa564967dc0796"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#af919e8945f98f99bb2fa564967dc0796">rttr::associative_container_mapper::get_value</a></div><div class="ttdeci">static value_t &amp; get_value(itr_t &amp;itr)</div><div class="ttdoc">Returns the current iterator's value as reference.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:266</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a09c4640bb0e7f8429881cf44633c4047"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a09c4640bb0e7f8429881cf44633c4047">rttr::associative_container_mapper::begin</a></div><div class="ttdeci">static itr_t begin(container_t &amp;container)</div><div class="ttdoc">Returns an iterator to the first element of the container.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:284</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_affa40dcbc832d12a004bf5ed43c804d8"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#affa40dcbc832d12a004bf5ed43c804d8">rttr::associative_container_mapper::find</a></div><div class="ttdeci">static itr_t find(container_t &amp;container, const key_t &amp;key)</div><div class="ttdoc">Finds an element with key equivalent to key and returns its iterator.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:320</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a72d2d5f862d839386bfba1dff51d42d3"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a72d2d5f862d839386bfba1dff51d42d3">rttr::associative_container_mapper::itr_t</a></div><div class="ttdeci">typename T::iterator itr_t</div><div class="ttdoc">An alias delcaration to the iterator.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:248</div></div>
<div class="ttc" id="anamespacerttr_html"><div class="ttname"><a href="namespacerttr.html">rttr</a></div><div class="ttdef"><b>Definition:</b> access_levels.h:33</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a0cfdd0e7c1e034e9628f12ce5310ab32"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a0cfdd0e7c1e034e9628f12ce5310ab32">rttr::associative_container_mapper::equal_range</a></div><div class="ttdeci">static std::pair&lt; itr_t, itr_t &gt; equal_range(container_t &amp;container, const key_t &amp;key)</div><div class="ttdoc">Returns a range containing all elements with the given key in the container.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:340</div></div>
<div class="ttc" id="anamespacerttr_html_a54ecd8bad715cbc451e7aa8491667d4a"><div class="ttname"><a href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">rttr::value</a></div><div class="ttdeci">detail::enum_data&lt; Enum_Type &gt; value(string_view, Enum_Type value)</div><div class="ttdoc">The value function should be used to add a mapping from enum name to value during the registration pr...</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a07287bff9d5b990e92f8dfa214ccaad4"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a07287bff9d5b990e92f8dfa214ccaad4">rttr::associative_container_mapper::key_t</a></div><div class="ttdeci">typename T::key_type key_t</div><div class="ttdoc">An alias to the key type.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:244</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_ab7cd139f88e50df36a2820846f8cca3e"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#ab7cd139f88e50df36a2820846f8cca3e">rttr::associative_container_mapper::clear</a></div><div class="ttdeci">static void clear(container_t &amp;container)</div><div class="ttdoc">Removes all elements from the container.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:360</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a2418dc59daf48c985db7c8bf50143959"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a2418dc59daf48c985db7c8bf50143959">rttr::associative_container_mapper::const_itr_t</a></div><div class="ttdeci">typename T::const_iterator const_itr_t</div><div class="ttdoc">An alias delcaration to the const iterator.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:249</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_aaad022985d0bc75de68cb1b236190545"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#aaad022985d0bc75de68cb1b236190545">rttr::associative_container_mapper::insert_key_value</a></div><div class="ttdeci">static std::pair&lt; itr_t, bool &gt; insert_key_value(container_t &amp;container, const key_t &amp;key, const value_t &amp;value)</div><div class="ttdoc">Inserts a key-value into the container.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:404</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a6284476f38dedeb4b0a6ec84a8299556"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a6284476f38dedeb4b0a6ec84a8299556">rttr::associative_container_mapper::is_empty</a></div><div class="ttdeci">static bool is_empty(const container_t &amp;container)</div><div class="ttdoc">Returns the number of elements in the container.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:368</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_aea4341d43b6b7766a04b6cb0959dfd68"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#aea4341d43b6b7766a04b6cb0959dfd68">rttr::associative_container_mapper::get_size</a></div><div class="ttdeci">static std::size_t get_size(const container_t &amp;container)</div><div class="ttdoc">Returns the number of elements in the container.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:376</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a26ffd67de017b43397169103e6ff1bed"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a26ffd67de017b43397169103e6ff1bed">rttr::associative_container_mapper::container_t</a></div><div class="ttdeci">T container_t</div><div class="ttdoc">An alias declaration to the container type itself.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:243</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_aadfece5d50acd4f82d088cda5b623470"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#aadfece5d50acd4f82d088cda5b623470">rttr::associative_container_mapper::erase</a></div><div class="ttdeci">static std::size_t erase(container_t &amp;container, const key_t &amp;key)</div><div class="ttdoc">Removes the element (if one exists) with the key equivalent to key.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:384</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a911fbeace8bcc94bddb1dc390ccf93f3"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a911fbeace8bcc94bddb1dc390ccf93f3">rttr::associative_container_mapper::end</a></div><div class="ttdeci">static itr_t end(container_t &amp;container)</div><div class="ttdoc">Returns an iterator to the element following the last element of the container.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:302</div></div>
<div class="ttc" id="astructrttr_1_1associative__container__mapper_html_a8c842e3002ee4570b979790766e85425"><div class="ttname"><a href="structrttr_1_1associative__container__mapper.html#a8c842e3002ee4570b979790766e85425">rttr::associative_container_mapper::get_key</a></div><div class="ttdeci">static const key_t &amp; get_key(const const_itr_t &amp;itr)</div><div class="ttdoc">Returns the current iterator's key as a const reference.</div><div class="ttdef"><b>Definition:</b> associative_mapper.h:256</div></div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
