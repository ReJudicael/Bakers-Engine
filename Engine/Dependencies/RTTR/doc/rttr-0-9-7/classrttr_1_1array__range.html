<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr::array_range&lt; T, Predicate &gt; Class Template Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1array__range.html">array_range</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrttr_1_1array__range-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::array_range&lt; T, Predicate &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classrttr_1_1array__range.html">array_range</a> class provides a view into an underlying data structure with lower and upper limits.  
 <a href="classrttr_1_1array__range.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array__range_8h_source.html">array_range.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7ea3dc42cccc2e26cb9ee8fa6fd1d534"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a7ea3dc42cccc2e26cb9ee8fa6fd1d534">bounds_type</a> = T *</td></tr>
<tr class="separator:a7ea3dc42cccc2e26cb9ee8fa6fd1d534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cd5ffa9de2d2fca76d486cf0461976"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> = array_iterator&lt; const T &gt;</td></tr>
<tr class="memdesc:a62cd5ffa9de2d2fca76d486cf0461976"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant forward iterator.  <a href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">More...</a><br /></td></tr>
<tr class="separator:a62cd5ffa9de2d2fca76d486cf0461976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa344d1585997aed6c09623b16cc7539"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> = array_reverse_iterator&lt; const T &gt;</td></tr>
<tr class="memdesc:aaa344d1585997aed6c09623b16cc7539"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant forward iterator that reverses the direction.  <a href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">More...</a><br /></td></tr>
<tr class="separator:aaa344d1585997aed6c09623b16cc7539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0258d2c5cec42693d3c3d5583f03bf3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ac0258d2c5cec42693d3c3d5583f03bf3">iterator</a> = array_iterator&lt; T &gt;</td></tr>
<tr class="memdesc:ac0258d2c5cec42693d3c3d5583f03bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator.  <a href="classrttr_1_1array__range.html#ac0258d2c5cec42693d3c3d5583f03bf3">More...</a><br /></td></tr>
<tr class="separator:ac0258d2c5cec42693d3c3d5583f03bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4d75a6ecd9a31c8e7cffbed51d1938"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#afc4d75a6ecd9a31c8e7cffbed51d1938">reverse_iterator</a> = array_reverse_iterator&lt; T &gt;</td></tr>
<tr class="memdesc:afc4d75a6ecd9a31c8e7cffbed51d1938"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator that reverses the direction.  <a href="classrttr_1_1array__range.html#afc4d75a6ecd9a31c8e7cffbed51d1938">More...</a><br /></td></tr>
<tr class="separator:afc4d75a6ecd9a31c8e7cffbed51d1938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc99768a20e004e8bb2c2dd8f6f38e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#aedc99768a20e004e8bb2c2dd8f6f38e5">size_type</a> = std::size_t</td></tr>
<tr class="separator:aedc99768a20e004e8bb2c2dd8f6f38e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568cdf1e55c4686cc9fc31bc9bdccc6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a568cdf1e55c4686cc9fc31bc9bdccc6a">value_type</a> = T</td></tr>
<tr class="separator:a568cdf1e55c4686cc9fc31bc9bdccc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd6ca91b76f7ae39e1cdc7911446f327"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#afd6ca91b76f7ae39e1cdc7911446f327">array_range</a> ()</td></tr>
<tr class="memdesc:afd6ca91b76f7ae39e1cdc7911446f327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classrttr_1_1array__range.html#afd6ca91b76f7ae39e1cdc7911446f327">More...</a><br /></td></tr>
<tr class="separator:afd6ca91b76f7ae39e1cdc7911446f327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f292c213cbd26222d9a741480b972cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a4f292c213cbd26222d9a741480b972cd">array_range</a> (const T *<a class="el" href="classrttr_1_1array__range.html#a77ef89b9834db7beca634c257300a328">begin</a>, <a class="el" href="classrttr_1_1array__range.html#aedc99768a20e004e8bb2c2dd8f6f38e5">size_type</a> <a class="el" href="classrttr_1_1array__range.html#afc4e321f630dba1bead6a3629fca75e8">size</a>, const Predicate &amp;pred=Predicate())</td></tr>
<tr class="memdesc:a4f292c213cbd26222d9a741480b972cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an array range starting from <code>begin</code> to <code>end</code> [begin, end).  <a href="classrttr_1_1array__range.html#a4f292c213cbd26222d9a741480b972cd">More...</a><br /></td></tr>
<tr class="separator:a4f292c213cbd26222d9a741480b972cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ef89b9834db7beca634c257300a328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a77ef89b9834db7beca634c257300a328">begin</a> ()</td></tr>
<tr class="memdesc:a77ef89b9834db7beca634c257300a328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the range.  <a href="classrttr_1_1array__range.html#a77ef89b9834db7beca634c257300a328">More...</a><br /></td></tr>
<tr class="separator:a77ef89b9834db7beca634c257300a328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be61969316fe861e3c1d9744be3c1ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a9be61969316fe861e3c1d9744be3c1ac">begin</a> () const</td></tr>
<tr class="memdesc:a9be61969316fe861e3c1d9744be3c1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the range.  <a href="classrttr_1_1array__range.html#a9be61969316fe861e3c1d9744be3c1ac">More...</a><br /></td></tr>
<tr class="separator:a9be61969316fe861e3c1d9744be3c1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e61263b3398ee11b31e929722e4e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#af5e61263b3398ee11b31e929722e4e26">cbegin</a> () const</td></tr>
<tr class="memdesc:af5e61263b3398ee11b31e929722e4e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the range.  <a href="classrttr_1_1array__range.html#af5e61263b3398ee11b31e929722e4e26">More...</a><br /></td></tr>
<tr class="separator:af5e61263b3398ee11b31e929722e4e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab178ee3878618f8a7c825567201786eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ab178ee3878618f8a7c825567201786eb">cend</a> () const</td></tr>
<tr class="memdesc:ab178ee3878618f8a7c825567201786eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the element following the last element of the range.  <a href="classrttr_1_1array__range.html#ab178ee3878618f8a7c825567201786eb">More...</a><br /></td></tr>
<tr class="separator:ab178ee3878618f8a7c825567201786eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89da4a6ad4c1f92d3f7ddb48b4f06674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a89da4a6ad4c1f92d3f7ddb48b4f06674">crbegin</a> () const</td></tr>
<tr class="memdesc:a89da4a6ad4c1f92d3f7ddb48b4f06674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the first element of the reversed range.  <a href="classrttr_1_1array__range.html#a89da4a6ad4c1f92d3f7ddb48b4f06674">More...</a><br /></td></tr>
<tr class="separator:a89da4a6ad4c1f92d3f7ddb48b4f06674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d994702be1efd67429516b6104d9d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ae8d994702be1efd67429516b6104d9d3">crend</a> () const</td></tr>
<tr class="memdesc:ae8d994702be1efd67429516b6104d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the element following the last element of the reversed range.  <a href="classrttr_1_1array__range.html#ae8d994702be1efd67429516b6104d9d3">More...</a><br /></td></tr>
<tr class="separator:ae8d994702be1efd67429516b6104d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b6b1d9cf6f5f2b0f76f6d631935d78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a33b6b1d9cf6f5f2b0f76f6d631935d78">empty</a> () const</td></tr>
<tr class="memdesc:a33b6b1d9cf6f5f2b0f76f6d631935d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the range has no elements, i.e.  <a href="classrttr_1_1array__range.html#a33b6b1d9cf6f5f2b0f76f6d631935d78">More...</a><br /></td></tr>
<tr class="separator:a33b6b1d9cf6f5f2b0f76f6d631935d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09562ceb3ebe5c72a74084cc1717ce94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a09562ceb3ebe5c72a74084cc1717ce94">end</a> ()</td></tr>
<tr class="memdesc:a09562ceb3ebe5c72a74084cc1717ce94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the range.  <a href="classrttr_1_1array__range.html#a09562ceb3ebe5c72a74084cc1717ce94">More...</a><br /></td></tr>
<tr class="separator:a09562ceb3ebe5c72a74084cc1717ce94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74d5f14ed8d33e4f731fabd6226cb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ad74d5f14ed8d33e4f731fabd6226cb73">end</a> () const</td></tr>
<tr class="memdesc:ad74d5f14ed8d33e4f731fabd6226cb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the element following the last element of the range.  <a href="classrttr_1_1array__range.html#ad74d5f14ed8d33e4f731fabd6226cb73">More...</a><br /></td></tr>
<tr class="separator:ad74d5f14ed8d33e4f731fabd6226cb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac905ef9925f47b70ed65dedba3155cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ac905ef9925f47b70ed65dedba3155cac">rbegin</a> ()</td></tr>
<tr class="memdesc:ac905ef9925f47b70ed65dedba3155cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed range.  <a href="classrttr_1_1array__range.html#ac905ef9925f47b70ed65dedba3155cac">More...</a><br /></td></tr>
<tr class="separator:ac905ef9925f47b70ed65dedba3155cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f27d4cd641b74bf61f8eeb6655120f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a10f27d4cd641b74bf61f8eeb6655120f">rbegin</a> () const</td></tr>
<tr class="memdesc:a10f27d4cd641b74bf61f8eeb6655120f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the first element of the reversed range.  <a href="classrttr_1_1array__range.html#a10f27d4cd641b74bf61f8eeb6655120f">More...</a><br /></td></tr>
<tr class="separator:a10f27d4cd641b74bf61f8eeb6655120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea00aebb8f7928cab7ed9deb83a5270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a1ea00aebb8f7928cab7ed9deb83a5270">rend</a> ()</td></tr>
<tr class="memdesc:a1ea00aebb8f7928cab7ed9deb83a5270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed range.  <a href="classrttr_1_1array__range.html#a1ea00aebb8f7928cab7ed9deb83a5270">More...</a><br /></td></tr>
<tr class="separator:a1ea00aebb8f7928cab7ed9deb83a5270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b071611cdcb541353dc341ff8feefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ae8b071611cdcb541353dc341ff8feefa">rend</a> () const</td></tr>
<tr class="memdesc:ae8b071611cdcb541353dc341ff8feefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the element following the last element of the reversed range.  <a href="classrttr_1_1array__range.html#ae8b071611cdcb541353dc341ff8feefa">More...</a><br /></td></tr>
<tr class="separator:ae8b071611cdcb541353dc341ff8feefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4e321f630dba1bead6a3629fca75e8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#afc4e321f630dba1bead6a3629fca75e8">size</a> () const</td></tr>
<tr class="memdesc:afc4e321f630dba1bead6a3629fca75e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range.  <a href="classrttr_1_1array__range.html#afc4e321f630dba1bead6a3629fca75e8">More...</a><br /></td></tr>
<tr class="separator:afc4e321f630dba1bead6a3629fca75e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt;<br />
class rttr::array_range&lt; T, Predicate &gt;</h3>

<p>The <a class="el" href="classrttr_1_1array__range.html">array_range</a> class provides a view into an underlying data structure with lower and upper limits. </p>
<p>In order to iterate over the data structure use the returned forward iterators from <a class="el" href="classrttr_1_1array__range.html#a77ef89b9834db7beca634c257300a328" title="Returns an iterator to the first element of the range.">begin()</a> or <a class="el" href="classrttr_1_1array__range.html#ac905ef9925f47b70ed65dedba3155cac" title="Returns a reverse iterator to the first element of the reversed range.">rbegin()</a>. To check whether the end of the range has reached use <a class="el" href="classrttr_1_1array__range.html#a09562ceb3ebe5c72a74084cc1717ce94" title="Returns an iterator to the element following the last element of the range.">end()</a> or <a class="el" href="classrttr_1_1array__range.html#a1ea00aebb8f7928cab7ed9deb83a5270" title="Returns a reverse iterator to the element following the last element of the reversed range.">rend()</a>. Using the standard C++ range-based for loop will implicit do all this work.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When the underlying data structure gets modified while holding a range, its iterators and the range itself will be invalidated. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7ea3dc42cccc2e26cb9ee8fa6fd1d534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea3dc42cccc2e26cb9ee8fa6fd1d534">&#9670;&nbsp;</a></span>bounds_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a7ea3dc42cccc2e26cb9ee8fa6fd1d534">bounds_type</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62cd5ffa9de2d2fca76d486cf0461976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cd5ffa9de2d2fca76d486cf0461976">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> =  array_iterator&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant forward iterator. </p>

</div>
</div>
<a id="aaa344d1585997aed6c09623b16cc7539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa344d1585997aed6c09623b16cc7539">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> =  array_reverse_iterator&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant forward iterator that reverses the direction. </p>

</div>
</div>
<a id="ac0258d2c5cec42693d3c3d5583f03bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0258d2c5cec42693d3c3d5583f03bf3">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#ac0258d2c5cec42693d3c3d5583f03bf3">iterator</a> =  array_iterator&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A forward iterator. </p>

</div>
</div>
<a id="afc4d75a6ecd9a31c8e7cffbed51d1938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4d75a6ecd9a31c8e7cffbed51d1938">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#afc4d75a6ecd9a31c8e7cffbed51d1938">reverse_iterator</a> =  array_reverse_iterator&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A forward iterator that reverses the direction. </p>

</div>
</div>
<a id="aedc99768a20e004e8bb2c2dd8f6f38e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc99768a20e004e8bb2c2dd8f6f38e5">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aedc99768a20e004e8bb2c2dd8f6f38e5">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a568cdf1e55c4686cc9fc31bc9bdccc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568cdf1e55c4686cc9fc31bc9bdccc6a">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a568cdf1e55c4686cc9fc31bc9bdccc6a">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afd6ca91b76f7ae39e1cdc7911446f327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6ca91b76f7ae39e1cdc7911446f327">&#9670;&nbsp;</a></span>array_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html">array_range</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty <a class="el" href="classrttr_1_1array__range.html" title="The array_range class provides a view into an underlying data structure with lower and upper limits.">array_range</a>. </p>

</div>
</div>
<a id="a4f292c213cbd26222d9a741480b972cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f292c213cbd26222d9a741480b972cd">&#9670;&nbsp;</a></span>array_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html">array_range</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1array__range.html#aedc99768a20e004e8bb2c2dd8f6f38e5">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>Predicate()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an array range starting from <code>begin</code> to <code>end</code> [begin, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Marks the start of the range. Is included of the range. </td></tr>
    <tr><td class="paramname">size</td><td>The number of elements to include in the range. </td></tr>
    <tr><td class="paramname">pred</td><td>Determines whether an element in the range fulfills the condition of the predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77ef89b9834db7beca634c257300a328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ef89b9834db7beca634c257300a328">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a09562ceb3ebe5c72a74084cc1717ce94">end()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a9be61969316fe861e3c1d9744be3c1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be61969316fe861e3c1d9744be3c1ac">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a09562ceb3ebe5c72a74084cc1717ce94">end()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the first element. </dd></dl>

</div>
</div>
<a id="af5e61263b3398ee11b31e929722e4e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e61263b3398ee11b31e929722e4e26">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a09562ceb3ebe5c72a74084cc1717ce94">end()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the first element. </dd></dl>

</div>
</div>
<a id="ab178ee3878618f8a7c825567201786eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab178ee3878618f8a7c825567201786eb">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the element following the last element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as placeholder, attempting to access it results in <b>undefined behavior</b>. If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a77ef89b9834db7beca634c257300a328">begin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a89da4a6ad4c1f92d3f7ddb48b4f06674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89da4a6ad4c1f92d3f7ddb48b4f06674">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the first element of the reversed range. </p>
<p>It corresponds to the last element of the non-reversed range.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a1ea00aebb8f7928cab7ed9deb83a5270">rend()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the first element. </dd></dl>

</div>
</div>
<a id="ae8d994702be1efd67429516b6104d9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d994702be1efd67429516b6104d9d3">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the element following the last element of the reversed range. </p>
<p>It corresponds to the element preceding the first element of the non-reversed range.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#ac905ef9925f47b70ed65dedba3155cac">rbegin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a33b6b1d9cf6f5f2b0f76f6d631935d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b6b1d9cf6f5f2b0f76f6d631935d78">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the range has no elements, i.e. </p>
<p>whether <code><a class="el" href="classrttr_1_1array__range.html#a77ef89b9834db7beca634c257300a328" title="Returns an iterator to the first element of the range.">begin()</a> == <a class="el" href="classrttr_1_1array__range.html#a09562ceb3ebe5c72a74084cc1717ce94" title="Returns an iterator to the element following the last element of the range.">end()</a></code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Every element will be checked against the condition of the used predicate. Only when every element doe not fulfill the condition of predicate, the range is declared empty. That means, in order to check for emptiness, the underlying algorithm needs to iterate through the whole range. So don't call it to often. It's better to cache the result in a temporary variable.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if this range is empty, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a09562ceb3ebe5c72a74084cc1717ce94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09562ceb3ebe5c72a74084cc1717ce94">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as placeholder, attempting to access it results in <b>undefined behavior</b>. If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a77ef89b9834db7beca634c257300a328">begin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="ad74d5f14ed8d33e4f731fabd6226cb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74d5f14ed8d33e4f731fabd6226cb73">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the element following the last element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as placeholder, attempting to access it results in <b>undefined behavior</b>. If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a77ef89b9834db7beca634c257300a328">begin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="ac905ef9925f47b70ed65dedba3155cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac905ef9925f47b70ed65dedba3155cac">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed range. </p>
<p>It corresponds to the last element of the non-reversed range.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a1ea00aebb8f7928cab7ed9deb83a5270">rend()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

</div>
</div>
<a id="a10f27d4cd641b74bf61f8eeb6655120f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f27d4cd641b74bf61f8eeb6655120f">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the first element of the reversed range. </p>
<p>It corresponds to the last element of the non-reversed range.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a1ea00aebb8f7928cab7ed9deb83a5270">rend()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the first element. </dd></dl>

</div>
</div>
<a id="a1ea00aebb8f7928cab7ed9deb83a5270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea00aebb8f7928cab7ed9deb83a5270">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed range. </p>
<p>It corresponds to the element preceding the first element of the non-reversed range.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#ac905ef9925f47b70ed65dedba3155cac">rbegin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="ae8b071611cdcb541353dc341ff8feefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b071611cdcb541353dc341ff8feefa">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the element following the last element of the reversed range. </p>
<p>It corresponds to the element preceding the first element of the non-reversed range.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#ac905ef9925f47b70ed65dedba3155cac">rbegin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="afc4e321f630dba1bead6a3629fca75e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4e321f630dba1bead6a3629fca75e8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate  = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Every element will be checked against the condition of the used predicate. Only elements which fulfill the condition of predicate will be included in the counter. That means, in order to determine the size of the range, the underlying algorithm needs to iterate through the whole range. So don't call it to often. It's better to cache the result in a temporary variable.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the range. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="array__range_8h_source.html">array_range.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
