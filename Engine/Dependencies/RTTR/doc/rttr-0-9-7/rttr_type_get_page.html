<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: Retrieving rttr::type objects</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Retrieving <a class="el" href="classrttr_1_1type.html" title="The type class holds the type information for any arbitrary object.">rttr::type</a> objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>RTTR uses an own, in C++ implemented, alternative to the build in <a href="http://en.wikipedia.org/wiki/Run-time_type_information" target="_blank">RTTI</a> mechanism of C++. The reason for that are problems when using <code>typeid</code> <a href="https://svn.boost.org/trac/boost/ticket/754" target="_blank">across shared boundaries</a>, <a href="http://tinodidriksen.com/2010/04/14/cpp-dynamic-cast-performance/" target="_blank">execution speed</a> and sometimes <a href="http://stackoverflow.com/questions/28553165/inconsistent-typeid-for-nested-template-function-in-visual-studio" target="_blank">not correct</a> implemented. That means it is possible to disable RTTI completly in your target application and use RTTR instead.</p>
<p>The entry point for all type related operation is the class <a class="el" href="classrttr_1_1type.html">type</a>. It is the central class for retrieving type objects or also querying all kind information about types.</p>
<p>A <a class="el" href="classrttr_1_1type.html">type</a> object cannot be created directly. It is only possible to retrieve it with one of the three static getter member functions of the <a class="el" href="classrttr_1_1type.html">type</a> class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/type&gt;</span> <span class="comment">// when working with type objects, this is the only header you have to include</span></div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classrttr_1_1type.html">type</a> my_int_type  = type::get&lt;int&gt;();     <span class="comment">// statically or</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classrttr_1_1type.html">type</a> my_bool_type = <a class="code" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get</a>(<span class="keyword">true</span>);      <span class="comment">// dynamically</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md87"></a>
rttr::type::get&lt;T&gt;()</h1>
<p>This function just expects one template argument. Use it to check against a known type.</p>
<div class="fragment"><div class="line">type::get&lt;int&gt;() == type::get&lt;int&gt;();     <span class="comment">// yields to true</span></div>
<div class="line"> </div>
<div class="line">type::get&lt;int&gt;() == type::get&lt;bool&gt;();    <span class="comment">// yields to false</span></div>
</div><!-- fragment --><p>Remark that when comparing types, internally always a simple integer comparison is done, instead how often with <a href="http://en.cppreference.com/w/cpp/language/typeid" target="_blank">typeid</a>, a string comparison.</p>
<h1><a class="anchor" id="autotoc_md88"></a>
rttr::type::get&lt;T&gt;(T&amp;&amp; obj)</h1>
<p>This function takes a universal reference and returns from every given object the corresponding <a class="el" href="classrttr_1_1type.html">type</a> object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> int_obj = 23;</div>
<div class="line"><span class="keywordtype">int</span>* int_obj_ptr         = &amp;int_obj;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>* c_int_obj_ptr = int_obj_ptr;</div>
<div class="line"> </div>
<div class="line">type::get&lt;int&gt;()        == type::get(int_obj);        <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;int*&gt;()       == type::get(int_obj_ptr);    <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;const int*&gt;() == type::get(c_int_obj_ptr);  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><p>When this function is called for a <a href="http://en.cppreference.com/w/cpp/language/value_category#glvalue" target="_blank">glvalue</a> expression whose type is a polymorphic class type, then the result refers to a <a class="el" href="classrttr_1_1type.html">type</a> object representing the type of the most derived object.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Base {};</div>
<div class="line"><span class="keyword">struct </span>Derived : Base {};</div>
<div class="line">Derived d;</div>
<div class="line">Base&amp; base = d;</div>
<div class="line"> </div>
<div class="line">type::get&lt;Derived&gt;()  == type::get(base)        <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;Base&gt;()     == type::get(base)        <span class="comment">// yields to false</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// REMARK when called with pointers:</span></div>
<div class="line">Base* base_ptr = &amp;d;</div>
<div class="line">type::get&lt;Derived&gt;()  == type::get(base_ptr);   <span class="comment">// yields to false</span></div>
<div class="line">type::get&lt;Base*&gt;()    == type::get(base_ptr);   <span class="comment">// yields to true</span></div>
</div><!-- fragment --><p>If the type of the expression is a cv-qualified type, the result of the <a class="el" href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">type::get()</a> expression refers to a <a class="el" href="classrttr_1_1type.html">type</a> object representing the cv-unqualified type.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>D { ... };</div>
<div class="line">D d1;</div>
<div class="line"><span class="keyword">const</span> D d2;</div>
<div class="line">type::get(d1)  == type::get(d2);         <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D&gt;();  <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get(d2);         <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D&amp;&gt;(); <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D*&gt;(); <span class="comment">// yields false</span></div>
</div><!-- fragment --><p>Any <code>top level</code> cv-qualifier of the given type <code>T</code> will be removed.</p>
<h1><a class="anchor" id="autotoc_md89"></a>
rttr::type::get_by_name(string_view)</h1>
<p>This function just expects the name of the type. This is useful when you know only the name of the type and cannot include the type itself into the source code.</p>
<div class="fragment"><div class="line">type::get_by_name(<span class="stringliteral">&quot;int&quot;</span>)  == type::get&lt;int&gt;();   <span class="comment">// yields to true</span></div>
<div class="line">type::get_by_name(<span class="stringliteral">&quot;bool&quot;</span>) == type::get&lt;int&gt;();  <span class="comment">// yields to false</span></div>
<div class="line">type::get_by_name(<span class="stringliteral">&quot;MyNameSpace::MyStruct&quot;</span>) == type::get&lt;MyNameSpace::MyStruct&gt;();  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Before using the function type::get_by_name(), you have to use one time the function via type::get&lt;T&gt;(), otherwise the type is not registered in the type system.</dd></dl>
<h1><a class="anchor" id="autotoc_md90"></a>
Container Support</h1>
<p>Unlike the <a href="http://en.cppreference.com/w/cpp/types/type_info" target="_blank">type_info</a> class, the <a class="el" href="classrttr_1_1type.html">rttr::type</a> class will not need and additional <a href="http://en.cppreference.com/w/cpp/types/type_index" target="_blank">wrapper</a> to place type objects inside containers:</p>
<div class="fragment"><div class="line">std::vector&lt;rttr::type&gt; type_list;</div>
<div class="line">std::map&lt;rttr::type, std::string&gt; mapping;</div>
<div class="line">std::unordered_map&lt;rttr::type, std::string&gt; type_names;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md91"></a>
Summary</h1>
<ul>
<li><a class="el" href="classrttr_1_1type.html">type</a> objects cannot be created, only retrieved via static member functions in the type class itself</li>
<li><a class="el" href="classrttr_1_1type.html">type</a> objects are lightweight, they contain only a single integer ID</li>
<li>every unique C++ type maps to the same unique ID, which will be used for comparing <a class="el" href="classrttr_1_1type.html">types</a></li>
<li><a class="el" href="classrttr_1_1type.html">type</a> objects can be easily placed inside containers or maps</li>
<li>retrieving a <a class="el" href="classrttr_1_1type.html">type</a> object results always in the cv-unqualified type (<code>type::get(T)==type::get(const T))</code>; same like <code>typeid</code>)</li>
<li>retrieving a <a class="el" href="classrttr_1_1type.html">type</a> object of a gvalue expression whose type is a polymorphic class, will refer to a <a class="el" href="classrttr_1_1type.html">type</a> object representing the type of the most derived class</li>
</ul>
<hr  />
<div class="btn btn-default doxy-button" disabled="true">previous</div><div class="btn btn-default  doxy-button"><a class="el" href="rttr_type_info_page.html">next</a></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespacerttr_html"><div class="ttname"><a href="namespacerttr.html">rttr</a></div><div class="ttdef"><b>Definition:</b> access_levels.h:33</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a5336e448f0881d2141be932e74fc756f"><div class="ttname"><a href="classrttr_1_1type.html#a5336e448f0881d2141be932e74fc756f">rttr::type::get</a></div><div class="ttdeci">static type get() noexcept</div><div class="ttdoc">Returns a type object for the given template type T.</div></div>
<div class="ttc" id="aclassrttr_1_1type_html"><div class="ttname"><a href="classrttr_1_1type.html">rttr::type</a></div><div class="ttdoc">The type class holds the type information for any arbitrary object.</div><div class="ttdef"><b>Definition:</b> type.h:202</div></div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
