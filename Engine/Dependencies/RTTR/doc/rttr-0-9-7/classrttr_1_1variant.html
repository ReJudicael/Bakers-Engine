<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr::variant Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1variant.html">variant</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrttr_1_1variant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::variant Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classrttr_1_1variant.html">variant</a> class allows to store data of any type and convert between these types transparently.  
 <a href="classrttr_1_1variant.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="variant_8h_source.html">variant.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2846ae50eae204afaa9cb5d772f0dadc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> ()</td></tr>
<tr class="memdesc:a2846ae50eae204afaa9cb5d772f0dadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an invalid variant.  <a href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">More...</a><br /></td></tr>
<tr class="separator:a2846ae50eae204afaa9cb5d772f0dadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373eb3ee4a7b25f172a057a8eefb309f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a373eb3ee4a7b25f172a057a8eefb309f">variant</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other)</td></tr>
<tr class="memdesc:a373eb3ee4a7b25f172a057a8eefb309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new variant object from the given variant <code>other</code>.  <a href="classrttr_1_1variant.html#a373eb3ee4a7b25f172a057a8eefb309f">More...</a><br /></td></tr>
<tr class="separator:a373eb3ee4a7b25f172a057a8eefb309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0f0f933c66b9cd3236bea92eb98c4f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tp  = detail::decay_variant_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a8e0f0f933c66b9cd3236bea92eb98c4f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a8e0f0f933c66b9cd3236bea92eb98c4f">variant</a> (T &amp;&amp;val)</td></tr>
<tr class="memdesc:a8e0f0f933c66b9cd3236bea92eb98c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new variant with the new value <code>val</code>.  <a href="classrttr_1_1variant.html#a8e0f0f933c66b9cd3236bea92eb98c4f">More...</a><br /></td></tr>
<tr class="separator:a8e0f0f933c66b9cd3236bea92eb98c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62f0dc5257483758c7dabba3445b9ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#af62f0dc5257483758c7dabba3445b9ae">variant</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:af62f0dc5257483758c7dabba3445b9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new variant via move constructor.  <a href="classrttr_1_1variant.html#af62f0dc5257483758c7dabba3445b9ae">More...</a><br /></td></tr>
<tr class="separator:af62f0dc5257483758c7dabba3445b9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfdf2a3ff661141d864f913ca665caf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a2dfdf2a3ff661141d864f913ca665caf">~variant</a> ()</td></tr>
<tr class="memdesc:a2dfdf2a3ff661141d864f913ca665caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the variant and the contained object.  <a href="classrttr_1_1variant.html#a2dfdf2a3ff661141d864f913ca665caf">More...</a><br /></td></tr>
<tr class="separator:a2dfdf2a3ff661141d864f913ca665caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab44ee073209655c7ae613a7f8c2c92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adab44ee073209655c7ae613a7f8c2c92"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92">can_convert</a> () const</td></tr>
<tr class="memdesc:adab44ee073209655c7ae613a7f8c2c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the contained value can be converted to the given type <code>T</code>.  <a href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92">More...</a><br /></td></tr>
<tr class="separator:adab44ee073209655c7ae613a7f8c2c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad172dbffcab73a71ab9ab5939b422ea1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#ad172dbffcab73a71ab9ab5939b422ea1">can_convert</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;target_type) const</td></tr>
<tr class="memdesc:ad172dbffcab73a71ab9ab5939b422ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the contained value can be converted to the given type <code>target_type</code>; otherwise <code>false</code>.  <a href="classrttr_1_1variant.html#ad172dbffcab73a71ab9ab5939b422ea1">More...</a><br /></td></tr>
<tr class="separator:ad172dbffcab73a71ab9ab5939b422ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3922eacbc4434254d814c615147033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a8f3922eacbc4434254d814c615147033">clear</a> ()</td></tr>
<tr class="memdesc:a8f3922eacbc4434254d814c615147033"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the variant contains a value, then this function will clear the content.  <a href="classrttr_1_1variant.html#a8f3922eacbc4434254d814c615147033">More...</a><br /></td></tr>
<tr class="separator:a8f3922eacbc4434254d814c615147033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54e0a9672e40be1ec85daeace00f379"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab54e0a9672e40be1ec85daeace00f379"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#ab54e0a9672e40be1ec85daeace00f379">convert</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:ab54e0a9672e40be1ec85daeace00f379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the containing data to a <em>new value</em> of type <code>T</code> and return this <em>value</em>.  <a href="classrttr_1_1variant.html#ab54e0a9672e40be1ec85daeace00f379">More...</a><br /></td></tr>
<tr class="separator:ab54e0a9672e40be1ec85daeace00f379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48031e0f0a64cc87b7476138071e9c2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c">convert</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;target_type)</td></tr>
<tr class="memdesc:a48031e0f0a64cc87b7476138071e9c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the containing variant internally to the given type <code>target_type</code>.  <a href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c">More...</a><br /></td></tr>
<tr class="separator:a48031e0f0a64cc87b7476138071e9c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5276edc6ac926b87e929909c434a32a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5276edc6ac926b87e929909c434a32a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a5276edc6ac926b87e929909c434a32a8">convert</a> (T &amp;<a class="el" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>) const</td></tr>
<tr class="memdesc:a5276edc6ac926b87e929909c434a32a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the containing data to the given value <code>value</code> and returns a <code>bool</code> flag that indicated whether the conversion was successful or not.  <a href="classrttr_1_1variant.html#a5276edc6ac926b87e929909c434a32a8">More...</a><br /></td></tr>
<tr class="separator:a5276edc6ac926b87e929909c434a32a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797610655507c3bbd1383dd44d967463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant__associative__view.html">variant_associative_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a797610655507c3bbd1383dd44d967463">create_associative_view</a> () const</td></tr>
<tr class="memdesc:a797610655507c3bbd1383dd44d967463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classrttr_1_1variant__associative__view.html">variant_associative_view</a> from the containing value, when the <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> or its <a class="el" href="classrttr_1_1type.html#a50e0f91eaae62ff7f44419fd94836a1c">raw type</a> or the <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">wrapped type</a> is an <a class="el" href="classrttr_1_1type.html#a95d23b7e6159ef21e64b6245cfe7d59b">associative container</a>.  <a href="classrttr_1_1variant.html#a797610655507c3bbd1383dd44d967463">More...</a><br /></td></tr>
<tr class="separator:a797610655507c3bbd1383dd44d967463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfadd6720c8e59459ec411bca8ab690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant__sequential__view.html">variant_sequential_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a0bfadd6720c8e59459ec411bca8ab690">create_sequential_view</a> () const</td></tr>
<tr class="memdesc:a0bfadd6720c8e59459ec411bca8ab690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classrttr_1_1variant__sequential__view.html">variant_sequential_view</a> from the containing value, when the <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> or its <a class="el" href="classrttr_1_1type.html#a50e0f91eaae62ff7f44419fd94836a1c">raw type</a> or the <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">wrapped type</a> is an <a class="el" href="classrttr_1_1type.html#a8362b580469d9357d8c97d9b3a6fe8ff">sequential container</a>.  <a href="classrttr_1_1variant.html#a0bfadd6720c8e59459ec411bca8ab690">More...</a><br /></td></tr>
<tr class="separator:a0bfadd6720c8e59459ec411bca8ab690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add029d6e6ecd677f34bd006ddfb2a52b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#add029d6e6ecd677f34bd006ddfb2a52b">extract_wrapped_value</a> () const</td></tr>
<tr class="memdesc:add029d6e6ecd677f34bd006ddfb2a52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the wrapped value and copies its content into a new variant.  <a href="classrttr_1_1variant.html#add029d6e6ecd677f34bd006ddfb2a52b">More...</a><br /></td></tr>
<tr class="separator:add029d6e6ecd677f34bd006ddfb2a52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a72579286ed164225c5be882ab6ea81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">get_type</a> () const</td></tr>
<tr class="memdesc:a7a72579286ed164225c5be882ab6ea81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classrttr_1_1type.html">type</a> object of underlying data.  <a href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">More...</a><br /></td></tr>
<tr class="separator:a7a72579286ed164225c5be882ab6ea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a9f7e07cdc4d922a4e09882c5c0574"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3a9f7e07cdc4d922a4e09882c5c0574"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">get_value</a> ()</td></tr>
<tr class="memdesc:aa3a9f7e07cdc4d922a4e09882c5c0574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the containing value as type <code>T</code>.  <a href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">More...</a><br /></td></tr>
<tr class="separator:aa3a9f7e07cdc4d922a4e09882c5c0574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0cf1700611bc8097687186525546a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c0cf1700611bc8097687186525546a2"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a1c0cf1700611bc8097687186525546a2">get_value</a> () const</td></tr>
<tr class="memdesc:a1c0cf1700611bc8097687186525546a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the containing value as type <code>T</code>.  <a href="classrttr_1_1variant.html#a1c0cf1700611bc8097687186525546a2">More...</a><br /></td></tr>
<tr class="separator:a1c0cf1700611bc8097687186525546a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8924e71d1c8d9d681067f440b7dcadce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8924e71d1c8d9d681067f440b7dcadce"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a8924e71d1c8d9d681067f440b7dcadce">get_wrapped_value</a> () const</td></tr>
<tr class="memdesc:a8924e71d1c8d9d681067f440b7dcadce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained wrapped value as type <code>T</code>.  <a href="classrttr_1_1variant.html#a8924e71d1c8d9d681067f440b7dcadce">More...</a><br /></td></tr>
<tr class="separator:a8924e71d1c8d9d681067f440b7dcadce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07183dcfa0b361dae335cca819404f82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a07183dcfa0b361dae335cca819404f82">is_associative_container</a> () const</td></tr>
<tr class="memdesc:a07183dcfa0b361dae335cca819404f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, when for the underlying or the <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">wrapped type</a> an associative_mapper exists.  <a href="classrttr_1_1variant.html#a07183dcfa0b361dae335cca819404f82">More...</a><br /></td></tr>
<tr class="separator:a07183dcfa0b361dae335cca819404f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefee30e65e17bcca951e53c6ff2d6395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#aefee30e65e17bcca951e53c6ff2d6395">is_sequential_container</a> () const</td></tr>
<tr class="memdesc:aefee30e65e17bcca951e53c6ff2d6395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, when for the underlying or the <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">wrapped type</a> an sequential_mapper exists.  <a href="classrttr_1_1variant.html#aefee30e65e17bcca951e53c6ff2d6395">More...</a><br /></td></tr>
<tr class="separator:aefee30e65e17bcca951e53c6ff2d6395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2fe635a8452ac3a2370589d6fc4bfb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a2fe635a8452ac3a2370589d6fc4bfb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type</a> () const</td></tr>
<tr class="memdesc:a8a2fe635a8452ac3a2370589d6fc4bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the containing variant data is of the given template type <code>T</code>.  <a href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">More...</a><br /></td></tr>
<tr class="separator:a8a2fe635a8452ac3a2370589d6fc4bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e6a2e29b4d1ac51a09b7d9037dd44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">is_valid</a> () const</td></tr>
<tr class="memdesc:aed6e6a2e29b4d1ac51a09b7d9037dd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this variant is valid, that means the variant is holding some data.  <a href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">More...</a><br /></td></tr>
<tr class="separator:aed6e6a2e29b4d1ac51a09b7d9037dd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e781aff0b814263604311a4506532b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a9e781aff0b814263604311a4506532b6">operator bool</a> () const</td></tr>
<tr class="memdesc:a9e781aff0b814263604311a4506532b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to check if this <a class="el" href="classrttr_1_1variant.html">variant</a> is valid or not.  <a href="classrttr_1_1variant.html#a9e781aff0b814263604311a4506532b6">More...</a><br /></td></tr>
<tr class="separator:a9e781aff0b814263604311a4506532b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472e108e9707b4a5e938fa244b36f76c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a472e108e9707b4a5e938fa244b36f76c">operator!=</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other) const</td></tr>
<tr class="memdesc:a472e108e9707b4a5e938fa244b36f76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this variant with <code>other</code> and returns <code>true</code> if they are <b>not</b> equal; otherwise returns <code>false</code>.  <a href="classrttr_1_1variant.html#a472e108e9707b4a5e938fa244b36f76c">More...</a><br /></td></tr>
<tr class="separator:a472e108e9707b4a5e938fa244b36f76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234abe122450f444d9564dc96ffc4043"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a234abe122450f444d9564dc96ffc4043">operator&lt;</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other) const</td></tr>
<tr class="memdesc:a234abe122450f444d9564dc96ffc4043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this variant with <code>other</code> and returns <code>true</code> if this is <em>less than</em> <code>other</code>, otherwise returns <code>false</code>.  <a href="classrttr_1_1variant.html#a234abe122450f444d9564dc96ffc4043">More...</a><br /></td></tr>
<tr class="separator:a234abe122450f444d9564dc96ffc4043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30935158926e0a55b16ffffc113c7ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#af30935158926e0a55b16ffffc113c7ea">operator&lt;=</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other) const</td></tr>
<tr class="memdesc:af30935158926e0a55b16ffffc113c7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this variant with <code>other</code> and returns <code>true</code> if this is <em>less</em> or <em>equal</em> than <code>other</code>, otherwise returns <code>false</code>.  <a href="classrttr_1_1variant.html#af30935158926e0a55b16ffffc113c7ea">More...</a><br /></td></tr>
<tr class="separator:af30935158926e0a55b16ffffc113c7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c4b84c74002c8705469747f3ff51eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a44c4b84c74002c8705469747f3ff51eb">operator=</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other)</td></tr>
<tr class="memdesc:a44c4b84c74002c8705469747f3ff51eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value of the <em>other</em> variant to this variant.  <a href="classrttr_1_1variant.html#a44c4b84c74002c8705469747f3ff51eb">More...</a><br /></td></tr>
<tr class="separator:a44c4b84c74002c8705469747f3ff51eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db5d6b14c7856ba306e920714d6ef2f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tp  = detail::decay_variant_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1db5d6b14c7856ba306e920714d6ef2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a1db5d6b14c7856ba306e920714d6ef2f">operator=</a> (T &amp;&amp;other)</td></tr>
<tr class="memdesc:a1db5d6b14c7856ba306e920714d6ef2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value of the <code>other</code> object to this variant.  <a href="classrttr_1_1variant.html#a1db5d6b14c7856ba306e920714d6ef2f">More...</a><br /></td></tr>
<tr class="separator:a1db5d6b14c7856ba306e920714d6ef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d543743275d7f88b05b52d0fac364e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a75d543743275d7f88b05b52d0fac364e">operator=</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a75d543743275d7f88b05b52d0fac364e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value of the <em>other</em> variant to this variant.  <a href="classrttr_1_1variant.html#a75d543743275d7f88b05b52d0fac364e">More...</a><br /></td></tr>
<tr class="separator:a75d543743275d7f88b05b52d0fac364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c60d6dd82d2ba2e88fc73ee9f3a950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a37c60d6dd82d2ba2e88fc73ee9f3a950">operator==</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other) const</td></tr>
<tr class="memdesc:a37c60d6dd82d2ba2e88fc73ee9f3a950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this variant with <code>other</code> and returns <code>true</code> if they are equal; otherwise returns <code>false</code>.  <a href="classrttr_1_1variant.html#a37c60d6dd82d2ba2e88fc73ee9f3a950">More...</a><br /></td></tr>
<tr class="separator:a37c60d6dd82d2ba2e88fc73ee9f3a950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fb3244430968663994c83d65ef9c68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a01fb3244430968663994c83d65ef9c68">operator&gt;</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other) const</td></tr>
<tr class="memdesc:a01fb3244430968663994c83d65ef9c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this variant with <code>other</code> and returns <code>true</code> if this is <em>greater than</em> <code>other</code>, otherwise returns <code>false</code>.  <a href="classrttr_1_1variant.html#a01fb3244430968663994c83d65ef9c68">More...</a><br /></td></tr>
<tr class="separator:a01fb3244430968663994c83d65ef9c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2e1d6c3106119d26b6e36ae6193094"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a7a2e1d6c3106119d26b6e36ae6193094">operator&gt;=</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other) const</td></tr>
<tr class="memdesc:a7a2e1d6c3106119d26b6e36ae6193094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this variant with <code>other</code> and returns <code>true</code> if this is <em>greater</em> or <em>equal</em> then <code>other</code>, otherwise returns <code>false</code>.  <a href="classrttr_1_1variant.html#a7a2e1d6c3106119d26b6e36ae6193094">More...</a><br /></td></tr>
<tr class="separator:a7a2e1d6c3106119d26b6e36ae6193094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ec4b42274ca9dbd3f2daec8d5bddaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#af0ec4b42274ca9dbd3f2daec8d5bddaa">swap</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> &amp;other)</td></tr>
<tr class="memdesc:af0ec4b42274ca9dbd3f2daec8d5bddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the content of this variant with <code>other</code> variant.  <a href="classrttr_1_1variant.html#af0ec4b42274ca9dbd3f2daec8d5bddaa">More...</a><br /></td></tr>
<tr class="separator:af0ec4b42274ca9dbd3f2daec8d5bddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b25079f42b96958c1bfe4d7c4f1a4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#ac2b25079f42b96958c1bfe4d7c4f1a4f">to_bool</a> () const</td></tr>
<tr class="memdesc:ac2b25079f42b96958c1bfe4d7c4f1a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variant as a <code>bool</code> if this variant is of <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> <code>bool</code>.  <a href="classrttr_1_1variant.html#ac2b25079f42b96958c1bfe4d7c4f1a4f">More...</a><br /></td></tr>
<tr class="separator:ac2b25079f42b96958c1bfe4d7c4f1a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ab55d69e38cbdabd57d0e0590fce8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a297ab55d69e38cbdabd57d0e0590fce8">to_double</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:a297ab55d69e38cbdabd57d0e0590fce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as a <code>double</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is a <code>double</code>.  <a href="classrttr_1_1variant.html#a297ab55d69e38cbdabd57d0e0590fce8">More...</a><br /></td></tr>
<tr class="separator:a297ab55d69e38cbdabd57d0e0590fce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4974cd7131c807542ab45027087c8581"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a4974cd7131c807542ab45027087c8581">to_float</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:a4974cd7131c807542ab45027087c8581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as a <code>float</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is a <code>float</code>.  <a href="classrttr_1_1variant.html#a4974cd7131c807542ab45027087c8581">More...</a><br /></td></tr>
<tr class="separator:a4974cd7131c807542ab45027087c8581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5acffcd7dcbe87d0d976e37a815ab43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#ae5acffcd7dcbe87d0d976e37a815ab43">to_int</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:ae5acffcd7dcbe87d0d976e37a815ab43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>int</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>integer</code>.  <a href="classrttr_1_1variant.html#ae5acffcd7dcbe87d0d976e37a815ab43">More...</a><br /></td></tr>
<tr class="separator:ae5acffcd7dcbe87d0d976e37a815ab43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa35d4a086742f3ab436751795a4be37"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#aaa35d4a086742f3ab436751795a4be37">to_int16</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:aaa35d4a086742f3ab436751795a4be37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>int16_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>int16_t</code>.  <a href="classrttr_1_1variant.html#aaa35d4a086742f3ab436751795a4be37">More...</a><br /></td></tr>
<tr class="separator:aaa35d4a086742f3ab436751795a4be37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d6f09f59567848f23542b7e0c44796"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a24d6f09f59567848f23542b7e0c44796">to_int32</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:a24d6f09f59567848f23542b7e0c44796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>int32_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>int32_t</code>.  <a href="classrttr_1_1variant.html#a24d6f09f59567848f23542b7e0c44796">More...</a><br /></td></tr>
<tr class="separator:a24d6f09f59567848f23542b7e0c44796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ee983738527837a776a4b66170b10b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a85ee983738527837a776a4b66170b10b">to_int64</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:a85ee983738527837a776a4b66170b10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>int64_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>int64_t</code>.  <a href="classrttr_1_1variant.html#a85ee983738527837a776a4b66170b10b">More...</a><br /></td></tr>
<tr class="separator:a85ee983738527837a776a4b66170b10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa122a754d6fa6b509ae92621719bb66"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#aaa122a754d6fa6b509ae92621719bb66">to_int8</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:aaa122a754d6fa6b509ae92621719bb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>int8_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>int8_t</code>.  <a href="classrttr_1_1variant.html#aaa122a754d6fa6b509ae92621719bb66">More...</a><br /></td></tr>
<tr class="separator:aaa122a754d6fa6b509ae92621719bb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bab1ccff5776d2f713b7a2543167a9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a28bab1ccff5776d2f713b7a2543167a9">to_string</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:a28bab1ccff5776d2f713b7a2543167a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as a <code>std::string</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is a <code>std::string</code>.  <a href="classrttr_1_1variant.html#a28bab1ccff5776d2f713b7a2543167a9">More...</a><br /></td></tr>
<tr class="separator:a28bab1ccff5776d2f713b7a2543167a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c56e1588efa8327bf51ba539c7b0be7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a9c56e1588efa8327bf51ba539c7b0be7">to_uint16</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:a9c56e1588efa8327bf51ba539c7b0be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>uint16_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>uint16_t</code>.  <a href="classrttr_1_1variant.html#a9c56e1588efa8327bf51ba539c7b0be7">More...</a><br /></td></tr>
<tr class="separator:a9c56e1588efa8327bf51ba539c7b0be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27caf5592d4a03091bbdf447e2e6355"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#aa27caf5592d4a03091bbdf447e2e6355">to_uint32</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:aa27caf5592d4a03091bbdf447e2e6355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>uint32_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>uint32_t</code>.  <a href="classrttr_1_1variant.html#aa27caf5592d4a03091bbdf447e2e6355">More...</a><br /></td></tr>
<tr class="separator:aa27caf5592d4a03091bbdf447e2e6355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9993e730b72c605b290db6ae8897bf63"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#a9993e730b72c605b290db6ae8897bf63">to_uint64</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:a9993e730b72c605b290db6ae8897bf63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>uint64_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>uint64_t</code>.  <a href="classrttr_1_1variant.html#a9993e730b72c605b290db6ae8897bf63">More...</a><br /></td></tr>
<tr class="separator:a9993e730b72c605b290db6ae8897bf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dd63fb67aac0d294d1665e4f74b2b8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html#ab7dd63fb67aac0d294d1665e4f74b2b8">to_uint8</a> (bool *ok=nullptr) const</td></tr>
<tr class="memdesc:ab7dd63fb67aac0d294d1665e4f74b2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the containing variant as an <code>uint8_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>uint8_t</code>.  <a href="classrttr_1_1variant.html#ab7dd63fb67aac0d294d1665e4f74b2b8">More...</a><br /></td></tr>
<tr class="separator:ab7dd63fb67aac0d294d1665e4f74b2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classrttr_1_1variant.html">variant</a> class allows to store data of any type and convert between these types transparently. </p>
<p>This class serves as container for any given single <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a>. It can hold one value at a time (using containers you can hold multiple types e.g. <code>std::vector&lt;int&gt;</code>). Remark that the content is copied into the variant class. Even raw arrays (e.g. <code>int[10]</code>) are copied. However, the internal implementation of variant has an optimization for storing small types, which avoid heap allocation.</p>
<p>The main purpose of this class is to be the return value for <a class="el" href="classrttr_1_1property.html#a324d3c3065ebe9db99c3962a9fe0a41b">property</a> and <a class="el" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">method</a> invokes or as container for storing meta data.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Copying and Assignment</h2>
<p>A <a class="el" href="classrttr_1_1variant.html">variant</a> object can be copied and assigned, however each copy will perform a copy of the contained value.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Typical Usage</h2>
<div class="fragment"><div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var;</div>
<div class="line">var = 23;                               <span class="comment">// copy integer</span></div>
<div class="line"><span class="keywordtype">int</span> x = var.to_int();                   <span class="comment">// x = 23</span></div>
<div class="line"> </div>
<div class="line">var = <span class="stringliteral">&quot;Hello World&quot;</span>;                    <span class="comment">// var contains now a std::string (implicit conversion of string literals to std::string)</span></div>
<div class="line"><span class="keywordtype">int</span> y = var.to_int();                   <span class="comment">// y = 0, because invalid conversion</span></div>
<div class="line"> </div>
<div class="line">var = <span class="stringliteral">&quot;42&quot;</span>;                             <span class="comment">// contains a std::string</span></div>
<div class="line">std::cout &lt;&lt; var.to_int();              <span class="comment">// convert std::string to integer and prints &quot;42&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> my_array[100];</div>
<div class="line">var = my_array;                         <span class="comment">// copies the content of my_array into var</span></div>
<div class="line"><span class="keyword">auto</span>&amp; arr = var.get_value&lt;<span class="keywordtype">int</span>[100]&gt;();  <span class="comment">// extracts the content of var by reference</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md29"></a>
Extract Value</h2>
<p>For extracting a value out of a variant you can use the <a class="el" href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">get_value()</a> function. This will return a <em>const reference</em> to the contained value. However, you must instantiated this function with the exact type of the stored value, otherwise undefined behaviour will occur. Therefore you <b>should</b> check it's <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> before extracting with <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type&lt;T&gt;()</a>.</p>
<p>See following example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>custom_type</div>
<div class="line">{</div>
<div class="line">   <span class="comment">//...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = custom_type{};</div>
<div class="line"><span class="keywordflow">if</span> (var.is_type&lt;custom_type&gt;())                             <span class="comment">// yields to true</span></div>
<div class="line">  <span class="keyword">const</span> custom_type&amp; <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> = var.get_value&lt;custom_type&gt;();  <span class="comment">// extracts the value by reference</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Conversion</h2>
<p>The <a class="el" href="classrttr_1_1variant.html">variant</a> class offers three possibilities to convert to a new type.</p><ul>
<li><a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c">convert(const type&amp; target_type)</a> - convert the variant internally to a new type</li>
<li>convert&lt;T&gt;(bool *ok) - convert the contained value to an internally default created value of type <code>T</code> and returns this new value</li>
<li>convert&lt;T&gt;(T&amp; value) - convert the contained value to a given <code>value</code> of type <code>T</code> </li>
</ul>
<p>See following example code: </p><div class="fragment"><div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = 23;                           <span class="comment">// var contains an int</span></div>
<div class="line"><span class="keywordflow">if</span>(var.can_convert&lt;std::string&gt;())          <span class="comment">// check whether conversion is possible</span></div>
<div class="line">{</div>
<div class="line">  var.convert(type::get&lt;std::string&gt;());    <span class="comment">// var contains now a std::string, with value =&gt; &quot;23&quot;</span></div>
<div class="line">  var.is_type&lt;std::string&gt;();               <span class="comment">// yields to &#39;true&#39;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordtype">int</span> int_value = var.convert&lt;<span class="keywordtype">int</span>&gt;(&amp;ok);      <span class="comment">// int_value == 23, ok yields to &#39;true&#39;</span></div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">uint8_t small_int = 0;</div>
<div class="line"><span class="keywordtype">bool</span> result = var.convert&lt;uint8_t&gt;(small_int); <span class="comment">// result == false, because small_int cannot hold the value &#39;500&#39;</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>It is possible that <a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92">can_convert()</a> will return <code>true</code>, but <a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c">convert()</a> will actually fail and return <code>false</code>. The reason for this is <a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92">can_convert()</a> will return the general ability of converting between types given suitable data; when no suitable data is given, the conversion cannot be performed.</dd></dl>
<p>A good example is the conversion from <code>std::string</code> to <code>int</code>. </p><div class="fragment"><div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = <span class="stringliteral">&quot;Answer: 42&quot;</span>;</div>
<div class="line">var.can_convert&lt;<span class="keywordtype">int</span>&gt;();             <span class="comment">// yields to &#39;true&#39;</span></div>
<div class="line"><span class="keywordtype">int</span> number;</div>
<div class="line"><span class="keywordtype">bool</span> result = var.convert(number);  <span class="comment">// yields to &#39;false&#39;, because the string contains non-numeric characters</span></div>
</div><!-- fragment --><p>Hence, it is important to have both functions return true for a successful conversion.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Custom Converter</h2>
<p>The variant class allows to convert from and to user-defined types, therefore you have to register a conversion function.</p>
<p>See following example code: </p><div class="fragment"><div class="line">std::string converter_func(<span class="keyword">const</span> custom_type&amp; <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>, <span class="keywordtype">bool</span>&amp; ok)</div>
<div class="line">{</div>
<div class="line">    ok = <span class="keyword">true</span>;</div>
<div class="line">    <span class="comment">// convert value to std::string</span></div>
<div class="line">    <span class="keywordflow">return</span> std::string(...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = custom_type(...);</div>
<div class="line">var.can_convert&lt;std::string&gt;();     <span class="comment">// return &#39;false&#39;</span></div>
<div class="line"><span class="comment">// register the conversion function</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func</a>(converter_func);</div>
<div class="line"> </div>
<div class="line">var.can_convert&lt;std::string&gt;();     <span class="comment">// return &#39;true&#39;</span></div>
<div class="line">var.to_string();                    <span class="comment">// converts from &#39;custom_type&#39; to &#39;std::string&#39;</span></div>
</div><!-- fragment --><p>For more information see <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func()</a></p>
<dl class="section see"><dt>See also</dt><dd>variant_array_view </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2846ae50eae204afaa9cb5d772f0dadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2846ae50eae204afaa9cb5d772f0dadc">&#9670;&nbsp;</a></span>variant() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rttr::variant::variant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an invalid variant. </p>
<p>That means a valid which contains no data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44" title="Returns true if this variant is valid, that means the variant is holding some data.">is_valid()</a> </dd></dl>

</div>
</div>
<a id="a8e0f0f933c66b9cd3236bea92eb98c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0f0f933c66b9cd3236bea92eb98c4f">&#9670;&nbsp;</a></span>variant() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tp  = detail::decay_variant_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rttr::variant::variant </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new variant with the new value <code>val</code>. </p>
<p>The value will be copied or moved into the variant. </p>

</div>
</div>
<a id="a373eb3ee4a7b25f172a057a8eefb309f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373eb3ee4a7b25f172a057a8eefb309f">&#9670;&nbsp;</a></span>variant() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rttr::variant::variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new variant object from the given variant <code>other</code>. </p>

</div>
</div>
<a id="af62f0dc5257483758c7dabba3445b9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62f0dc5257483758c7dabba3445b9ae">&#9670;&nbsp;</a></span>variant() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rttr::variant::variant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new variant via move constructor. </p>

</div>
</div>
<a id="a2dfdf2a3ff661141d864f913ca665caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfdf2a3ff661141d864f913ca665caf">&#9670;&nbsp;</a></span>~variant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rttr::variant::~variant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the variant and the contained object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adab44ee073209655c7ae613a7f8c2c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab44ee073209655c7ae613a7f8c2c92">&#9670;&nbsp;</a></span>can_convert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::can_convert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the contained value can be converted to the given type <code>T</code>. </p>
<p>Otherwise <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if this variant can be converted to <code>T</code>; otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c" title="Converts the containing variant internally to the given type target_type.">convert()</a>, <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0" title="Register a converter func F, which will be used internally by the variant class to convert between ty...">type::register_converter_func()</a> </dd></dl>

</div>
</div>
<a id="ad172dbffcab73a71ab9ab5939b422ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad172dbffcab73a71ab9ab5939b422ea1">&#9670;&nbsp;</a></span>can_convert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::can_convert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>target_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the contained value can be converted to the given type <code>target_type</code>; otherwise <code>false</code>. </p>
<p>The returned value indicates that a conversion is in general possible. However a conversion might still fail when doing the actual conversion with <a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c">convert()</a>. An example is the conversion from a string to a number. When the string does not contain non-numeric characters, the conversion will not succeed.</p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if this variant can be converted to <code>target_type</code>; otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c" title="Converts the containing variant internally to the given type target_type.">convert()</a>, <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0" title="Register a converter func F, which will be used internally by the variant class to convert between ty...">type::register_converter_func()</a> </dd></dl>

</div>
</div>
<a id="a8f3922eacbc4434254d814c615147033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3922eacbc4434254d814c615147033">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::variant::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When the variant contains a value, then this function will clear the content. </p>
<dl class="section remark"><dt>Remarks</dt><dd>After calling this function <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">is_valid()</a> will return <code>false</code>. </dd></dl>

</div>
</div>
<a id="ab54e0a9672e40be1ec85daeace00f379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54e0a9672e40be1ec85daeace00f379">&#9670;&nbsp;</a></span>convert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T rttr::variant::convert </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the containing data to a <em>new value</em> of type <code>T</code> and return this <em>value</em>. </p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> when the value was successfully converted to <code>T</code>; otherwise <code>*ok</code> is set to <code>false</code>. The type <code>T</code> must meet the requirement to be <em>default constructible</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> val = 12;</div>
<div class="line"><span class="keywordflow">if</span> (val.can_convert&lt;<span class="keywordtype">float</span>&gt;())</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordtype">float</span> result = val.<a class="code" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c">convert</a>&lt;<span class="keywordtype">float</span>&gt;(&amp;ok);</div>
<div class="line">  <span class="keywordflow">if</span> (ok)</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In order to enable a custom type conversion, a conversion function has to be registered via <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func()</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Before doing the conversion you should check whether it is in general possible to convert to type <code>T</code> with the function <a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92">can_convert()</a>. When the conversion fails, a default constructed value of type <code>T</code> is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The converted value as type <code>T</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0" title="Register a converter func F, which will be used internally by the variant class to convert between ty...">type::register_converter_func()</a> </dd></dl>

</div>
</div>
<a id="a48031e0f0a64cc87b7476138071e9c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48031e0f0a64cc87b7476138071e9c2c">&#9670;&nbsp;</a></span>convert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::convert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>target_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the containing variant internally to the given type <code>target_type</code>. </p>
<p>When the conversion was successfully the function will return <code>true</code>. When the conversion fails, then the containing variant value stays the same and the function will return <code>false</code>.</p>
<p>There are already certain standard type conversions implemented:</p><ol type="1">
<li>Conversion of all arithmetic types (e.g. <code>double</code> to <code>int</code>, 'std::size_t' to 'int8_t' and so on)</li>
<li>Conversion of all arithmetic types to and from <code>std::string</code>.</li>
<li>Conversion of enum types to <code>std::string</code>, its underlying arithmetic types and vice versa.</li>
<li>Conversion of <a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper classes</a> to wrapped types and vice versa (e.g, <code>std::shared_ptr&lt;int&gt;</code> to <code>int*</code>)</li>
<li>Conversion of raw pointers to its derived types, if a <a class="el" href="namespacerttr.html#ab3dd8b62e5ddca4c1d57cc572ba6bb81">rttr_cast</a> to the type described by <code>target_type</code> would succeed.</li>
</ol>
<p>See therefore following example code: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>base { <span class="keyword">virtual</span> ~base(){} <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>derived : base { <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(base) };</div>
<div class="line">derived d;</div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = <span class="keyword">static_cast&lt;</span>base*<span class="keyword">&gt;</span>(&amp;d);           <span class="comment">// var contains a &#39;*base&#39; ptr</span></div>
<div class="line"><span class="keywordtype">bool</span> ret = var.convert(type::get&lt;derived*&gt;());  <span class="comment">// yields to &#39;true&#39;</span></div>
<div class="line">var.is_type&lt;derived*&gt;();                        <span class="comment">// yields to &#39;true&#39;</span></div>
</div><!-- fragment --><p>Additionally, it is possible to add custom conversion function, which has to be registered via <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if this variant can be converted to <code>target_type</code>; otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0" title="Register a converter func F, which will be used internally by the variant class to convert between ty...">type::register_converter_func()</a> </dd></dl>

</div>
</div>
<a id="a5276edc6ac926b87e929909c434a32a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5276edc6ac926b87e929909c434a32a8">&#9670;&nbsp;</a></span>convert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::convert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the containing data to the given value <code>value</code> and returns a <code>bool</code> flag that indicated whether the conversion was successful or not. </p>
<p>When you need to convert to a type which cannot be default constructed use this function.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> val = 12;</div>
<div class="line"><span class="keywordflow">if</span> (val.can_convert&lt;custom_type&gt;())</div>
<div class="line">{</div>
<div class="line">  custom_type obj(42); <span class="comment">// non-default ctor type</span></div>
<div class="line">  <span class="keywordtype">bool</span> result = val.convert(obj);</div>
<div class="line">  <span class="keywordflow">if</span> (result)</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In order to enable a custom type conversion, a conversion function has to be registered via <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func()</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Before doing the conversion you should check whether it is in general possible to convert to type <code>T</code> with the function <a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92">can_convert()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the contained data could be converted to <code>value</code>; otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0" title="Register a converter func F, which will be used internally by the variant class to convert between ty...">type::register_converter_func()</a> </dd></dl>

</div>
</div>
<a id="a797610655507c3bbd1383dd44d967463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797610655507c3bbd1383dd44d967463">&#9670;&nbsp;</a></span>create_associative_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant__associative__view.html">variant_associative_view</a> rttr::variant::create_associative_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classrttr_1_1variant__associative__view.html">variant_associative_view</a> from the containing value, when the <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> or its <a class="el" href="classrttr_1_1type.html#a50e0f91eaae62ff7f44419fd94836a1c">raw type</a> or the <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">wrapped type</a> is an <a class="el" href="classrttr_1_1type.html#a95d23b7e6159ef21e64b6245cfe7d59b">associative container</a>. </p>
<p>Otherwise a default constructed <a class="el" href="classrttr_1_1variant__associative__view.html" title="The variant_associative_view describes a class that refers to an associative container (e....">variant_associative_view</a> will be returned.</p>
<p>A typical example is the following:</p>
<div class="fragment"><div class="line">std::map&lt;int, std::string&gt; my_map;</div>
<div class="line">my_map.insert({1, <span class="stringliteral">&quot;One&quot;</span>});</div>
<div class="line">my_map.insert({2, <span class="stringliteral">&quot;Two&quot;</span>});</div>
<div class="line">my_map.insert({3, <span class="stringliteral">&quot;Three&quot;</span>});</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = my_map;                                          <span class="comment">// copies the content of my_map into var</span></div>
<div class="line">variant_associative_view view = var.create_associative_view(); <span class="comment">// creates a view of the hold container in the variant (data is not copied!)</span></div>
<div class="line">std::size_t x = view.get_size();                               <span class="comment">// return number of elements x = 3</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; item : view)                                        <span class="comment">// iterates over all items stored in the container</span></div>
<div class="line">{</div>
<div class="line">   <span class="keyword">auto</span> key = item.first.extract_wrapped_value().to_string();</div>
<div class="line">   <span class="keyword">auto</span> <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> = item.second.extract_wrapped_value().to_string();</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot; value: &quot;</span> &lt;&lt; <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>This function will return an <a class="el" href="classrttr_1_1variant__associative__view.html#ae5cc73903f1f07307f422a2b03eab552">invalid</a> object, when the <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> is no associative container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classrttr_1_1variant__associative__view.html" title="The variant_associative_view describes a class that refers to an associative container (e....">variant_associative_view</a> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c" title="Converts the containing variant internally to the given type target_type.">convert()</a> </dd></dl>

</div>
</div>
<a id="a0bfadd6720c8e59459ec411bca8ab690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfadd6720c8e59459ec411bca8ab690">&#9670;&nbsp;</a></span>create_sequential_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant__sequential__view.html">variant_sequential_view</a> rttr::variant::create_sequential_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classrttr_1_1variant__sequential__view.html">variant_sequential_view</a> from the containing value, when the <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> or its <a class="el" href="classrttr_1_1type.html#a50e0f91eaae62ff7f44419fd94836a1c">raw type</a> or the <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">wrapped type</a> is an <a class="el" href="classrttr_1_1type.html#a8362b580469d9357d8c97d9b3a6fe8ff">sequential container</a>. </p>
<p>Otherwise a default constructed <a class="el" href="classrttr_1_1variant__sequential__view.html" title="The variant_sequential_view describes a class that refers to an sequence container (e....">variant_sequential_view</a> will be returned.</p>
<p>A typical example is the following:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; my_vec = { 1, 2, 3, 4, 5};</div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = my_vec; <span class="comment">// copies data into variant</span></div>
<div class="line"><span class="keywordflow">if</span> (var.is_sequential_container())</div>
<div class="line">{</div>
<div class="line">    variant_sequential_view view = var.create_sequential_view();  <span class="comment">// performs no copy of the underlying vector</span></div>
<div class="line">    std::cout &lt;&lt; view.get_size() &lt;&lt; std::endl;  <span class="comment">// prints: &#39;5&#39;</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : view) <span class="comment">// iterates over all elements of the std::vector&lt;T&gt;</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// remark that the value is stored inside a &#39;std::reference_wrapper&#39;, however there is an automatic conversion for wrapper classes implemented.</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;data: &quot;</span> &lt;&lt; item.to_string() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>This function will return an <a class="el" href="classrttr_1_1variant__sequential__view.html#af3314b761c65a198d80bab519226c7bd">invalid</a> object, when the <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> is no sequential container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classrttr_1_1variant__sequential__view.html" title="The variant_sequential_view describes a class that refers to an sequence container (e....">variant_sequential_view</a> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c" title="Converts the containing variant internally to the given type target_type.">convert()</a> </dd></dl>

</div>
</div>
<a id="add029d6e6ecd677f34bd006ddfb2a52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add029d6e6ecd677f34bd006ddfb2a52b">&#9670;&nbsp;</a></span>extract_wrapped_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::variant::extract_wrapped_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the wrapped value and copies its content into a new variant. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> value1 = 23;</div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var1 = std::ref(value1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (var1.get_type().get_wrapped_type() == type::get&lt;int&gt;())  <span class="comment">// yields to true</span></div>
<div class="line">{</div>
<div class="line">   <a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var2 = var1.extract_wrapped_value(); <span class="comment">// value will be copied into &quot;var2&quot;</span></div>
<div class="line">   var2.get_type() == type::get&lt;int&gt;(); <span class="comment">// yields to true</span></div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; value2 = var2.get_value&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line">   std::cout &lt;&lt; value2 &lt;&lt; std::endl;    <span class="comment">// prints &quot;23&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Calling this method works only for wrapped types which are copiable. When you work with custom types, which are not copyable, the variant will be <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">invalid</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant with the wrapped value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#af1bd09e2408fbc2816e201c2d82df582" title="Returns true whether the given type represents a wrapper type.">type::is_wrapper()</a> </dd></dl>

</div>
</div>
<a id="a7a72579286ed164225c5be882ab6ea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a72579286ed164225c5be882ab6ea81">&#9670;&nbsp;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::variant::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classrttr_1_1type.html">type</a> object of underlying data. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the variant has not stored any data, then an invalid <a class="el" href="classrttr_1_1type.html">type</a> object is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classrttr_1_1type.html">type</a> of the underlying data type. </dd></dl>

</div>
</div>
<a id="aa3a9f7e07cdc4d922a4e09882c5c0574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a9f7e07cdc4d922a4e09882c5c0574">&#9670;&nbsp;</a></span>get_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; rttr::variant::get_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the containing value as type <code>T</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>custom_type</div>
<div class="line">{</div>
<div class="line">   <span class="comment">//...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = custom_type{};</div>
<div class="line"><span class="keywordflow">if</span> (var.is_type&lt;custom_type&gt;())                         <span class="comment">// yields to true</span></div>
<div class="line">    custom_type&amp; <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> = var.get_value&lt;custom_type&gt;();  <span class="comment">// extracts the value by reference</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Only call this method when it is possible to return the containing value as the given type <code>T</code>. Use therefore the method <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type()</a>. Otherwise the call leads to undefined behaviour. Also make sure you don't clean this variant, when you still hold a reference to the containing value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a>, <a class="el" href="namespacerttr.html#a061fa22f1348eefc697cbeff24bafbc4" title="Returns a reference to the containing value as type T.">variant_cast&lt;T&gt;</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the stored value. </dd></dl>

</div>
</div>
<a id="a1c0cf1700611bc8097687186525546a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0cf1700611bc8097687186525546a2">&#9670;&nbsp;</a></span>get_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; rttr::variant::get_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the containing value as type <code>T</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>custom_type</div>
<div class="line">{</div>
<div class="line">   <span class="comment">//...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = custom_type{};</div>
<div class="line"><span class="keywordflow">if</span> (var.is_type&lt;custom_type&gt;())                             <span class="comment">// yields to true</span></div>
<div class="line">  <span class="keyword">const</span> custom_type&amp; <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> = var.get_value&lt;custom_type&gt;();  <span class="comment">// extracts the value by reference</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Only call this method when it is possible to return the containing value as the given type <code>T</code>. Use therefore the method <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">is_type()</a>. Otherwise the call leads to undefined behaviour. Also make sure you don't clean this variant, when you still hold a reference to the containing value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a>, <a class="el" href="namespacerttr.html#a061fa22f1348eefc697cbeff24bafbc4" title="Returns a reference to the containing value as type T.">variant_cast&lt;T&gt;</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the stored value. </dd></dl>

</div>
</div>
<a id="a8924e71d1c8d9d681067f440b7dcadce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8924e71d1c8d9d681067f440b7dcadce">&#9670;&nbsp;</a></span>get_wrapped_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; rttr::variant::get_wrapped_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the contained wrapped value as type <code>T</code>. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> = 23;</div>
<div class="line"><a class="code" href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">variant</a> var = std::ref(<a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (var.get_type().get_wrapped_type() == type::get&lt;int&gt;())  <span class="comment">// yields to true</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; ref_value = var.get_wrapped_value&lt;<span class="keywordtype">int</span>&gt;();  <span class="comment">// extracts the value by reference</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Only call this method when it is possible to return the containing value as the given type <code>T</code>. Use therefore the method <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">get_wrapped_type()</a>. Otherwise the call leads to undefined behaviour.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724" title="Returns a type object which represent the wrapped type.">rttr::type::get_wrapped_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the stored wrapped value. </dd></dl>

</div>
</div>
<a id="a07183dcfa0b361dae335cca819404f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07183dcfa0b361dae335cca819404f82">&#9670;&nbsp;</a></span>is_associative_container()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::is_associative_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, when for the underlying or the <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">wrapped type</a> an associative_mapper exists. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the containing value is an associative container; otherwise false. </dd></dl>

</div>
</div>
<a id="aefee30e65e17bcca951e53c6ff2d6395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefee30e65e17bcca951e53c6ff2d6395">&#9670;&nbsp;</a></span>is_sequential_container()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::is_sequential_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, when for the underlying or the <a class="el" href="classrttr_1_1type.html#a9b6af1ac4dd7e107cdfabb1050546724">wrapped type</a> an sequential_mapper exists. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the containing value is an sequentail container; otherwise false. </dd></dl>

</div>
</div>
<a id="a8a2fe635a8452ac3a2370589d6fc4bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2fe635a8452ac3a2370589d6fc4bfb">&#9670;&nbsp;</a></span>is_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::is_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the containing variant data is of the given template type <code>T</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if variant data is of type <code>T</code>, otherwise false. </dd></dl>

</div>
</div>
<a id="aed6e6a2e29b4d1ac51a09b7d9037dd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6e6a2e29b4d1ac51a09b7d9037dd44">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this variant is valid, that means the variant is holding some data. </p>
<p>When the variant doesn't hold any data it will return false.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A variant can also hold <code>void</code> data, this is used to indicate that a method call, which has no return value, was successfully. In this case, there is no data actually stored, but this function will return true.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if this variant is valid, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a9e781aff0b814263604311a4506532b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e781aff0b814263604311a4506532b6">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rttr::variant::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to check if this <a class="el" href="classrttr_1_1variant.html">variant</a> is valid or not. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44" title="Returns true if this variant is valid, that means the variant is holding some data.">is_valid()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if this <a class="el" href="classrttr_1_1variant.html">variant</a> is valid, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a472e108e9707b4a5e938fa244b36f76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472e108e9707b4a5e938fa244b36f76c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this variant with <code>other</code> and returns <code>true</code> if they are <b>not</b> equal; otherwise returns <code>false</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to use this function with template types, like <code>std::tuple&lt;int, std::string&gt;</code>, you need to register the comparison operator to the type system with <a class="el" href="classrttr_1_1type.html#a4912d4dac773276a6142a70a40ab0543">type::register_comparators&lt;T&gt;()</a>. The reason for that is, template types might define the <code>!=</code> operator, but not the contained template type.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Comparability might not be available for the type stored in this variant or in <code>other</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a37c60d6dd82d2ba2e88fc73ee9f3a950">operator==</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean with value <code>true</code>, that indicates both variant's are <b>not</b> equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a234abe122450f444d9564dc96ffc4043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234abe122450f444d9564dc96ffc4043">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this variant with <code>other</code> and returns <code>true</code> if this is <em>less than</em> <code>other</code>, otherwise returns <code>false</code>. </p>
<p>The variant uses the <em>less than</em> operator of the containing <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a>. When <code>other</code> is not of the same type as the containing type, it will try to convert to it and do then the <em>less than</em> check.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to use this function with template types, like <code>std::tuple&lt;int, std::string&gt;</code>, you need to register the comparison operator to the type system with <a class="el" href="classrttr_1_1type.html#a4912d4dac773276a6142a70a40ab0543">type::register_comparators&lt;T&gt;()</a>. The reason for that is, template types might define the <code>&lt;</code> operator, but not the contained template type.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Comparability might not be available for the type stored in this variant or in <code>other</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a01fb3244430968663994c83d65ef9c68">operator&gt;</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean with value <code>true</code>, that indicates that this variant is <em>less than</em> <code>other</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="af30935158926e0a55b16ffffc113c7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30935158926e0a55b16ffffc113c7ea">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this variant with <code>other</code> and returns <code>true</code> if this is <em>less</em> or <em>equal</em> than <code>other</code>, otherwise returns <code>false</code>. </p>
<p>The variant uses the <em>less than</em> and equality operator of the containing <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> to get the result of the comparision.</p>
<dl class="section note"><dt>Note</dt><dd>Comparability might not be available for the type stored in this variant or in <code>other</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a234abe122450f444d9564dc96ffc4043">operator&lt;</a>, <a class="el" href="classrttr_1_1variant.html#a37c60d6dd82d2ba2e88fc73ee9f3a950">operator==</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean with value <code>true</code>, that indicates that this variant is <em>less</em> or <em>equal</em> than <code>other</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a44c4b84c74002c8705469747f3ff51eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c4b84c74002c8705469747f3ff51eb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a>&amp; rttr::variant::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the value of the <em>other</em> variant to this variant. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the variant with the new data. </dd></dl>

</div>
</div>
<a id="a1db5d6b14c7856ba306e920714d6ef2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db5d6b14c7856ba306e920714d6ef2f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tp  = detail::decay_variant_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a>&amp; rttr::variant::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the value of the <code>other</code> object to this variant. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the variant with the new data. </dd></dl>

</div>
</div>
<a id="a75d543743275d7f88b05b52d0fac364e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d543743275d7f88b05b52d0fac364e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a>&amp; rttr::variant::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the value of the <em>other</em> variant to this variant. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the variant with the new data. </dd></dl>

</div>
</div>
<a id="a37c60d6dd82d2ba2e88fc73ee9f3a950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c60d6dd82d2ba2e88fc73ee9f3a950">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this variant with <code>other</code> and returns <code>true</code> if they are equal; otherwise returns <code>false</code>. </p>
<p>The variant uses the equality operator of the containing <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> to check for equality. When <code>other</code> is not of the same type as the containing type, it will try to convert to it and do then the equality check.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to use this function with template types, like <code>std::tuple&lt;int, std::string&gt;</code>, you need to register the comparison operator to the type system with <a class="el" href="classrttr_1_1type.html#a4912d4dac773276a6142a70a40ab0543">type::register_comparators&lt;T&gt;()</a>. The reason for that is, template types might define the <code>==</code> operator, but not the contained template type.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Comparability might not be available for the type stored in this variant or in <code>other</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a472e108e9707b4a5e938fa244b36f76c">operator!=</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean with value <code>true</code>, that indicates both variant's are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a01fb3244430968663994c83d65ef9c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fb3244430968663994c83d65ef9c68">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this variant with <code>other</code> and returns <code>true</code> if this is <em>greater than</em> <code>other</code>, otherwise returns <code>false</code>. </p>
<p>The variant uses the <em>less than</em> and equality operator of the containing <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> to get the result of the comparision.</p>
<dl class="section note"><dt>Note</dt><dd>Comparability might not be available for the type stored in this variant or in <code>other</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a234abe122450f444d9564dc96ffc4043">operator&lt;</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean with value <code>true</code>, that indicates that this variant is <em>greater than</em> <code>other</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a7a2e1d6c3106119d26b6e36ae6193094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2e1d6c3106119d26b6e36ae6193094">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this variant with <code>other</code> and returns <code>true</code> if this is <em>greater</em> or <em>equal</em> then <code>other</code>, otherwise returns <code>false</code>. </p>
<p>The variant uses the <em>greater than</em> and equality operator of the containing <a class="el" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">type</a> to get the result of the comparision.</p>
<dl class="section note"><dt>Note</dt><dd>Comparability might not be available for the type stored in this variant or in <code>other</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a01fb3244430968663994c83d65ef9c68">operator&gt;</a>, <a class="el" href="classrttr_1_1variant.html#a37c60d6dd82d2ba2e88fc73ee9f3a950">operator==</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean with value <code>true</code>, that indicates that this variant is <em>greater</em> or <em>equal</em> than <code>other</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="af0ec4b42274ca9dbd3f2daec8d5bddaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ec4b42274ca9dbd3f2daec8d5bddaa">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::variant::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the content of this variant with <code>other</code> variant. </p>

</div>
</div>
<a id="ac2b25079f42b96958c1bfe4d7c4f1a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b25079f42b96958c1bfe4d7c4f1a4f">&#9670;&nbsp;</a></span>to_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::variant::to_bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variant as a <code>bool</code> if this variant is of <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> <code>bool</code>. </p>
<p>Returns <code>true</code> if the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> which value is non-zero or if the variant contains a <code>std::string</code> and its lower-case content is not one of the following: <code>""</code> (empty), <code>"0"</code> or <code>"false"</code>; otherwise returns <code>false</code>.</p>
<p>Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>bool</code> will be executed when necessary.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>bool</code> value. </dd></dl>

</div>
</div>
<a id="a297ab55d69e38cbdabd57d0e0590fce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297ab55d69e38cbdabd57d0e0590fce8">&#9670;&nbsp;</a></span>to_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double rttr::variant::to_double </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as a <code>double</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is a <code>double</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>double</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>double</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>double</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>double</code>, the conversion will fail. Precision loss, such as in conversion from <code>double</code> to <code>float</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>double</code> value. </dd></dl>

</div>
</div>
<a id="a4974cd7131c807542ab45027087c8581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4974cd7131c807542ab45027087c8581">&#9670;&nbsp;</a></span>to_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rttr::variant::to_float </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as a <code>float</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is a <code>float</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>float</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>float</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>float</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>float</code>, the conversion will fail. Precision loss, such as in conversion from <code>double</code> to <code>float</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>float</code> value. </dd></dl>

</div>
</div>
<a id="ae5acffcd7dcbe87d0d976e37a815ab43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5acffcd7dcbe87d0d976e37a815ab43">&#9670;&nbsp;</a></span>to_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rttr::variant::to_int </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>int</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>integer</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>int</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>int</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>int</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>int</code>, the conversion will fail. Precision loss, such as in conversion from floating-point to <code>int</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>int</code> value. </dd></dl>

</div>
</div>
<a id="aaa35d4a086742f3ab436751795a4be37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa35d4a086742f3ab436751795a4be37">&#9670;&nbsp;</a></span>to_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t rttr::variant::to_int16 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>int16_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>int16_t</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>int16_t</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>int16_t</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>int16_t</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>int16_t</code>, the conversion will fail. Precision loss, such as in conversion from floating-point to <code>int16_t</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>int16_t</code> value. </dd></dl>

</div>
</div>
<a id="a24d6f09f59567848f23542b7e0c44796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d6f09f59567848f23542b7e0c44796">&#9670;&nbsp;</a></span>to_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rttr::variant::to_int32 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>int32_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>int32_t</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>int32_t</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>int32_t</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>int32_t</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>int32_t</code>, the conversion will fail. Precision loss, such as in conversion from floating-point to <code>int32_t</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>int32_t</code> value. </dd></dl>

</div>
</div>
<a id="a85ee983738527837a776a4b66170b10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ee983738527837a776a4b66170b10b">&#9670;&nbsp;</a></span>to_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t rttr::variant::to_int64 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>int64_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>int64_t</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>int64_t</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>int64_t</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>int64_t</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>int64_t</code>, the conversion will fail. Precision loss, such as in conversion from floating-point to <code>int64_t</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>int64_t</code> value. </dd></dl>

</div>
</div>
<a id="aaa122a754d6fa6b509ae92621719bb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa122a754d6fa6b509ae92621719bb66">&#9670;&nbsp;</a></span>to_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t rttr::variant::to_int8 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>int8_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>int8_t</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>int8_t</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>int8_t</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>int8_t</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>int8_t</code>, the conversion will fail. Precision loss, such as in conversion from floating-point to <code>int8_t</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>int8_t</code> value. </dd></dl>

</div>
</div>
<a id="a28bab1ccff5776d2f713b7a2543167a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bab1ccff5776d2f713b7a2543167a9">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rttr::variant::to_string </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as a <code>std::string</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is a <code>std::string</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> then a conversion to <code>std::string</code> will be done. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>std::string</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>std::string</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::string</code> value. </dd></dl>

</div>
</div>
<a id="a9c56e1588efa8327bf51ba539c7b0be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c56e1588efa8327bf51ba539c7b0be7">&#9670;&nbsp;</a></span>to_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rttr::variant::to_uint16 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>uint16_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>uint16_t</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>uint16_t</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>uint16_t</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>uint16_t</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>uint16_t</code>, the conversion will fail. Also a loss of signedness is not allowed, that means a negative signed integer cannot be converted to <code>uint16_t</code>. Precision loss, such as in conversion from floating-point to <code>uint16_t</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>uint16_t</code> value. </dd></dl>

</div>
</div>
<a id="aa27caf5592d4a03091bbdf447e2e6355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27caf5592d4a03091bbdf447e2e6355">&#9670;&nbsp;</a></span>to_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rttr::variant::to_uint32 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>uint32_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>uint32_t</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>uint32_t</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>uint32_t</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>uint32_t</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>uint32_t</code>, the conversion will fail. Also a loss of signedness is not allowed, that means a negative signed integer cannot be converted to <code>uint32_t</code>. Precision loss, such as in conversion from floating-point to <code>uint32_t</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>uint32_t</code> value. </dd></dl>

</div>
</div>
<a id="a9993e730b72c605b290db6ae8897bf63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9993e730b72c605b290db6ae8897bf63">&#9670;&nbsp;</a></span>to_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rttr::variant::to_uint64 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>uint64_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>uint64_t</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>uint64_t</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>uint64_t</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>uint8_t</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>uint64_t</code>, the conversion will fail. Also a loss of signedness is not allowed, that means a negative signed integer cannot be converted to <code>uint64_t</code>. Precision loss, such as in conversion from floating-point to <code>uint64_t</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>uint64_t</code> value. </dd></dl>

</div>
</div>
<a id="ab7dd63fb67aac0d294d1665e4f74b2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dd63fb67aac0d294d1665e4f74b2b8">&#9670;&nbsp;</a></span>to_uint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rttr::variant::to_uint8 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ok</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the containing variant as an <code>uint8_t</code> when the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">type</a> is an <code>uint8_t</code>. </p>
<p>When the variant contains an <a class="el" href="classrttr_1_1type.html#aac53b079eca2d784a126ad6a3b13b9e5">arithmetic type</a> or an <code>std::string</code> then a conversion to <code>uint8_t</code> will be tried. Also any user-defined <a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">conversion function</a> from the <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb">source type</a> to <code>uint8_t</code> will be executed when necessary.</p>
<p>If <code>ok</code> is non-null: <code>*ok</code> is set to <code>true</code> if the value could be converted to an <code>uint8_t</code>; otherwise <code>*ok</code> is set to <code>false</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A value overflow is not allowed, so if the internal value is larger than <code>uint8_t</code>, the conversion will fail. Also a loss of signedness is not allowed, that means a negative signed integer cannot be converted to <code>uint8_t</code>. Precision loss, such as in conversion from floating-point to <code>uint8_t</code> on platforms where they differ in size is allowed. A conversion from <code>std::string</code> which contains non-numeric characters will fail.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#adab44ee073209655c7ae613a7f8c2c92" title="Returns true if the contained value can be converted to the given type T.">can_convert()</a>, <a class="el" href="classrttr_1_1variant.html#a8a2fe635a8452ac3a2370589d6fc4bfb" title="Returns true if the containing variant data is of the given template type T.">is_type()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>uint8_t</code> value. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="variant_8h_source.html">variant.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassrttr_1_1variant_html_a48031e0f0a64cc87b7476138071e9c2c"><div class="ttname"><a href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c">rttr::variant::convert</a></div><div class="ttdeci">bool convert(const type &amp;target_type)</div><div class="ttdoc">Converts the containing variant internally to the given type target_type.</div></div>
<div class="ttc" id="anamespacerttr_html_a54ecd8bad715cbc451e7aa8491667d4a"><div class="ttname"><a href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">rttr::value</a></div><div class="ttdeci">detail::enum_data&lt; Enum_Type &gt; value(string_view, Enum_Type value)</div><div class="ttdoc">The value function should be used to add a mapping from enum name to value during the registration pr...</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a81f5f2ea31cc79846a829aa5737680f0"><div class="ttname"><a href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">rttr::type::register_converter_func</a></div><div class="ttdeci">static void register_converter_func(F func)</div><div class="ttdoc">Register a converter func F, which will be used internally by the variant class to convert between ty...</div></div>
<div class="ttc" id="arttr__enable_8h_html_a848bcae21d3a54e07ca6450689820a59"><div class="ttname"><a href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a></div><div class="ttdeci">#define RTTR_ENABLE(...)</div><div class="ttdoc">This macro is necessary in order to retrieve type information about the inheritance graph of a class.</div><div class="ttdef"><b>Definition:</b> rttr_enable.h:76</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html_a2846ae50eae204afaa9cb5d772f0dadc"><div class="ttname"><a href="classrttr_1_1variant.html#a2846ae50eae204afaa9cb5d772f0dadc">rttr::variant::variant</a></div><div class="ttdeci">variant()</div><div class="ttdoc">Constructs an invalid variant.</div></div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
