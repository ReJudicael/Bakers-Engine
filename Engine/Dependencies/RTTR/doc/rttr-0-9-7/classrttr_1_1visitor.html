<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr::visitor Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1visitor.html">visitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrttr_1_1visitor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::visitor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class <a class="el" href="classrttr_1_1visitor.html">visitor</a>, is used for visiting your registered accessors of a type at compile time.  
 <a href="classrttr_1_1visitor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="visitor_8h_source.html">visitor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1visitor_1_1constructor__function__info.html">constructor_function_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1visitor_1_1constructor__function__info.html">constructor_function_info</a> class is used to forward all information during registration of a <a class="el" href="classrttr_1_1constructor.html">constructor</a> function.  <a href="structrttr_1_1visitor_1_1constructor__function__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1visitor_1_1constructor__info.html">constructor_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1visitor_1_1constructor__info.html">constructor_info</a> class is used to forward all information during registration of a constructor.  <a href="structrttr_1_1visitor_1_1constructor__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1visitor_1_1method__info.html">method_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1visitor_1_1method__info.html">method_info</a> class is used to forward all information during registration of a <a class="el" href="classrttr_1_1method.html">method</a>.  <a href="structrttr_1_1visitor_1_1method__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1visitor_1_1property__getter__setter__info.html">property_getter_setter_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1visitor_1_1method__info.html">method_info</a> class is used to forward all information during registration of a <a class="el" href="classrttr_1_1property.html">property</a>.  <a href="structrttr_1_1visitor_1_1property__getter__setter__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a> class is used to forward all information during registration of a <a class="el" href="classrttr_1_1property.html">property</a>.  <a href="structrttr_1_1visitor_1_1property__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1visitor_1_1type__info.html">type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1visitor_1_1type__info.html">type_info</a> class is used to forward all information during registration of a <a class="el" href="classrttr_1_1registration_1_1class__.html">class</a>.  <a href="structrttr_1_1visitor_1_1type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9163d4191db01379565b661a96e748d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a9163d4191db01379565b661a96e748d9">visitor</a> ()</td></tr>
<tr class="memdesc:a9163d4191db01379565b661a96e748d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor of the visitor class.  <a href="classrttr_1_1visitor.html#a9163d4191db01379565b661a96e748d9">More...</a><br /></td></tr>
<tr class="separator:a9163d4191db01379565b661a96e748d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d4677025d7995536f455dce8b6c3e6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a27d4677025d7995536f455dce8b6c3e6">~visitor</a> ()</td></tr>
<tr class="memdesc:a27d4677025d7995536f455dce8b6c3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor of the visitor class.  <a href="classrttr_1_1visitor.html#a27d4677025d7995536f455dce8b6c3e6">More...</a><br /></td></tr>
<tr class="separator:a27d4677025d7995536f455dce8b6c3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e2f7777fe71a78710be27672fb1ffc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a57e2f7777fe71a78710be27672fb1ffc">visit</a> (<a class="el" href="classrttr_1_1constructor.html">constructor</a> ctor)</td></tr>
<tr class="memdesc:a57e2f7777fe71a78710be27672fb1ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this function will indirectly call the function <a class="el" href="classrttr_1_1visitor.html#a06f25ec9658c51a5f12d797021e26098">visit_constructor()</a> or <a class="el" href="classrttr_1_1visitor.html#a48493d942873416daf727c2db35a4d8c">visit_constructor_function()</a> for the underlying registered type.  <a href="classrttr_1_1visitor.html#a57e2f7777fe71a78710be27672fb1ffc">More...</a><br /></td></tr>
<tr class="separator:a57e2f7777fe71a78710be27672fb1ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbc829b44f3b89b5c6c877c26838bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a2dbc829b44f3b89b5c6c877c26838bd1">visit</a> (<a class="el" href="classrttr_1_1method.html">method</a> meth)</td></tr>
<tr class="memdesc:a2dbc829b44f3b89b5c6c877c26838bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this function will indirectly call the function <a class="el" href="classrttr_1_1visitor.html#af8be3ffc422426ab05e336eadd6e8f73">visit_method()</a> for the underlying registered type.  <a href="classrttr_1_1visitor.html#a2dbc829b44f3b89b5c6c877c26838bd1">More...</a><br /></td></tr>
<tr class="separator:a2dbc829b44f3b89b5c6c877c26838bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36b1ebef7ba224275b963a01fe18760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit</a> (<a class="el" href="classrttr_1_1property.html">property</a> prop)</td></tr>
<tr class="memdesc:ab36b1ebef7ba224275b963a01fe18760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this function will indirectly call one of the functions:  <a href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">More...</a><br /></td></tr>
<tr class="separator:ab36b1ebef7ba224275b963a01fe18760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659921da402f9176ff9432fbbde778d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit</a> (<a class="el" href="classrttr_1_1type.html">type</a> t)</td></tr>
<tr class="memdesc:a659921da402f9176ff9432fbbde778d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this function will indirectly call the visit functions for all registered types members (constructors, methods, properties, etc...) This includes also registered base classes.  <a href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">More...</a><br /></td></tr>
<tr class="separator:a659921da402f9176ff9432fbbde778d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f25ec9658c51a5f12d797021e26098"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ctor_Args&gt; </td></tr>
<tr class="memitem:a06f25ec9658c51a5f12d797021e26098"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a06f25ec9658c51a5f12d797021e26098">visit_constructor</a> (const <a class="el" href="structrttr_1_1visitor_1_1constructor__info.html">constructor_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:a06f25ec9658c51a5f12d797021e26098"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a constructor via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a> or directly<a class="el" href="classrttr_1_1visitor.html#a57e2f7777fe71a78710be27672fb1ffc">visit(constructor)</a>.  <a href="classrttr_1_1visitor.html#a06f25ec9658c51a5f12d797021e26098">More...</a><br /></td></tr>
<tr class="separator:a06f25ec9658c51a5f12d797021e26098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48493d942873416daf727c2db35a4d8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48493d942873416daf727c2db35a4d8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a48493d942873416daf727c2db35a4d8c">visit_constructor_function</a> (const <a class="el" href="structrttr_1_1visitor_1_1constructor__function__info.html">constructor_function_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:a48493d942873416daf727c2db35a4d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a constructor function via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a> or <a class="el" href="classrttr_1_1visitor.html#a57e2f7777fe71a78710be27672fb1ffc">visit(constructor)</a>.  <a href="classrttr_1_1visitor.html#a48493d942873416daf727c2db35a4d8c">More...</a><br /></td></tr>
<tr class="separator:a48493d942873416daf727c2db35a4d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98191e509a3e9f11b58d90db8683d5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab98191e509a3e9f11b58d90db8683d5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#ab98191e509a3e9f11b58d90db8683d5a">visit_getter_setter_property</a> (const <a class="el" href="structrttr_1_1visitor_1_1property__getter__setter__info.html">property_getter_setter_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:ab98191e509a3e9f11b58d90db8683d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>.  <a href="classrttr_1_1visitor.html#ab98191e509a3e9f11b58d90db8683d5a">More...</a><br /></td></tr>
<tr class="separator:ab98191e509a3e9f11b58d90db8683d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec930042acbc5af7e642caca60a31846"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec930042acbc5af7e642caca60a31846"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#aec930042acbc5af7e642caca60a31846">visit_global_getter_setter_property</a> (const <a class="el" href="structrttr_1_1visitor_1_1property__getter__setter__info.html">property_getter_setter_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:aec930042acbc5af7e642caca60a31846"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a global property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>.  <a href="classrttr_1_1visitor.html#aec930042acbc5af7e642caca60a31846">More...</a><br /></td></tr>
<tr class="separator:aec930042acbc5af7e642caca60a31846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd52ec5497d611801c6ea5c0ac9c57a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bd52ec5497d611801c6ea5c0ac9c57a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a9bd52ec5497d611801c6ea5c0ac9c57a">visit_global_method</a> (const <a class="el" href="structrttr_1_1visitor_1_1method__info.html">method_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:a9bd52ec5497d611801c6ea5c0ac9c57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a global method via: <a class="el" href="classrttr_1_1visitor.html#a2dbc829b44f3b89b5c6c877c26838bd1">visit(method)</a>.  <a href="classrttr_1_1visitor.html#a9bd52ec5497d611801c6ea5c0ac9c57a">More...</a><br /></td></tr>
<tr class="separator:a9bd52ec5497d611801c6ea5c0ac9c57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab704dcc5237941a3b50a4180ca7bbb27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab704dcc5237941a3b50a4180ca7bbb27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#ab704dcc5237941a3b50a4180ca7bbb27">visit_global_property</a> (const <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:ab704dcc5237941a3b50a4180ca7bbb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a global property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>.  <a href="classrttr_1_1visitor.html#ab704dcc5237941a3b50a4180ca7bbb27">More...</a><br /></td></tr>
<tr class="separator:ab704dcc5237941a3b50a4180ca7bbb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecce1bd39e03b9cdb4b53401e87fa28f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecce1bd39e03b9cdb4b53401e87fa28f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#aecce1bd39e03b9cdb4b53401e87fa28f">visit_global_readonly_property</a> (const <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:aecce1bd39e03b9cdb4b53401e87fa28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a global read only property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>.  <a href="classrttr_1_1visitor.html#aecce1bd39e03b9cdb4b53401e87fa28f">More...</a><br /></td></tr>
<tr class="separator:aecce1bd39e03b9cdb4b53401e87fa28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8be3ffc422426ab05e336eadd6e8f73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8be3ffc422426ab05e336eadd6e8f73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#af8be3ffc422426ab05e336eadd6e8f73">visit_method</a> (const <a class="el" href="structrttr_1_1visitor_1_1method__info.html">method_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:af8be3ffc422426ab05e336eadd6e8f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a type method via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a> or <a class="el" href="classrttr_1_1visitor.html#a2dbc829b44f3b89b5c6c877c26838bd1">visit(method)</a>.  <a href="classrttr_1_1visitor.html#af8be3ffc422426ab05e336eadd6e8f73">More...</a><br /></td></tr>
<tr class="separator:af8be3ffc422426ab05e336eadd6e8f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9dea846dd0f8aa5d97e2a67ce6933c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d9dea846dd0f8aa5d97e2a67ce6933c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#a8d9dea846dd0f8aa5d97e2a67ce6933c">visit_property</a> (const <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:a8d9dea846dd0f8aa5d97e2a67ce6933c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>.  <a href="classrttr_1_1visitor.html#a8d9dea846dd0f8aa5d97e2a67ce6933c">More...</a><br /></td></tr>
<tr class="separator:a8d9dea846dd0f8aa5d97e2a67ce6933c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbba36ed2a1ba85fe52b33f7d779f6fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbba36ed2a1ba85fe52b33f7d779f6fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#abbba36ed2a1ba85fe52b33f7d779f6fc">visit_readonly_property</a> (const <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:abbba36ed2a1ba85fe52b33f7d779f6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a read only property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>.  <a href="classrttr_1_1visitor.html#abbba36ed2a1ba85fe52b33f7d779f6fc">More...</a><br /></td></tr>
<tr class="separator:abbba36ed2a1ba85fe52b33f7d779f6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75649729b94306df014c46e7219040e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Base_Classes&gt; </td></tr>
<tr class="memitem:ac75649729b94306df014c46e7219040e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#ac75649729b94306df014c46e7219040e">visit_type_begin</a> (const <a class="el" href="structrttr_1_1visitor_1_1type__info.html">type_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:ac75649729b94306df014c46e7219040e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a type via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a> It is the first function that will be invoked, when visiting a type.  <a href="classrttr_1_1visitor.html#ac75649729b94306df014c46e7219040e">More...</a><br /></td></tr>
<tr class="separator:ac75649729b94306df014c46e7219040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fba48bc4bd19bf413268be3112dc3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Base_Classes&gt; </td></tr>
<tr class="memitem:ae8fba48bc4bd19bf413268be3112dc3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html#ae8fba48bc4bd19bf413268be3112dc3a">visit_type_end</a> (const <a class="el" href="structrttr_1_1visitor_1_1type__info.html">type_info</a>&lt; T &gt; &amp;info)</td></tr>
<tr class="memdesc:ae8fba48bc4bd19bf413268be3112dc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called when you visit a type via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a>.  <a href="classrttr_1_1visitor.html#ae8fba48bc4bd19bf413268be3112dc3a">More...</a><br /></td></tr>
<tr class="separator:ae8fba48bc4bd19bf413268be3112dc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class <a class="el" href="classrttr_1_1visitor.html">visitor</a>, is used for visiting your registered accessors of a type at compile time. </p>
<p>Sometimes it might be necessary to get access to the underlying registered accessor (e.g. function pointers, object pointers, etc...) of a type. For example in order to bind a type to a scripting library, which only allows to register concrete types. The generic approach of using a visitor will solve this problem. Furthermore, because it is template based, you can write one visitor to iterate over all your types in a generic way and have access to the static type information.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Own visitor</h2>
<p>In order to implement your own visitor class, you have to derive from the class <a class="el" href="classrttr_1_1visitor.html">visitor</a> and reimplement the following visitor function templates:</p><ol type="1">
<li><code>void <a class="el" href="classrttr_1_1visitor.html#ac75649729b94306df014c46e7219040e" title="This function will be called when you visit a type via: visit(type) It is the first function that wil...">visitor::visit_type_begin</a>(const <a class="el" href="structrttr_1_1visitor_1_1type__info.html" title="The type_info class is used to forward all information during registration of a class.">type_info</a>&lt;T&gt;&amp; info)</code></li>
<li><code>void <a class="el" href="classrttr_1_1visitor.html#ae8fba48bc4bd19bf413268be3112dc3a" title="This function will be called when you visit a type via: visit(type).">visitor::visit_type_end</a>(const <a class="el" href="structrttr_1_1visitor_1_1type__info.html" title="The type_info class is used to forward all information during registration of a class.">type_info</a>&lt;T&gt;&amp; info);</code></li>
<li><code>void <a class="el" href="classrttr_1_1visitor.html#a06f25ec9658c51a5f12d797021e26098" title="This function will be called when you visit a constructor via: visit(type) or directlyvisit(construct...">visitor::visit_constructor</a>(const <a class="el" href="structrttr_1_1visitor_1_1constructor__info.html" title="The constructor_info class is used to forward all information during registration of a constructor.">constructor_info</a>&lt;T&gt;&amp; info);</code></li>
<li><code>void <a class="el" href="classrttr_1_1visitor.html#a48493d942873416daf727c2db35a4d8c" title="This function will be called when you visit a constructor function via: visit(type) or visit(construc...">visitor::visit_constructor_function</a>(const <a class="el" href="structrttr_1_1visitor_1_1constructor__function__info.html" title="The constructor_function_info class is used to forward all information during registration of a const...">constructor_function_info</a>&lt;T&gt;&amp; info);</code></li>
<li><code>void <a class="el" href="classrttr_1_1visitor.html#af8be3ffc422426ab05e336eadd6e8f73" title="This function will be called when you visit a type method via: visit(type) or visit(method).">visitor::visit_method</a>(const <a class="el" href="structrttr_1_1visitor_1_1method__info.html" title="The method_info class is used to forward all information during registration of a method.">method_info</a>&lt;T&gt;&amp; info);</code></li>
<li><code>void <a class="el" href="classrttr_1_1visitor.html#a9bd52ec5497d611801c6ea5c0ac9c57a" title="This function will be called when you visit a global method via: visit(method).">visitor::visit_global_method</a>(const <a class="el" href="structrttr_1_1visitor_1_1method__info.html" title="The method_info class is used to forward all information during registration of a method.">method_info</a>&lt;T&gt;&amp; info);</code></li>
</ol>
<p>and add the macro <code><a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59" title="This macro is necessary in order to retrieve type information about the inheritance graph of a class.">RTTR_ENABLE(visitor)</a>;</code> in the class body.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
Using a visitor</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;print_visitor.h&quot;</span>  <span class="comment">// IMPORTANT: You have to include your visitor always before the include of the `&lt;rttr/registration&gt;`</span></div>
<div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;cat&gt;</a>(<span class="stringliteral">&quot;cat&quot;</span>)</div>
<div class="line">                          .<a class="code" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">method</a>(<span class="stringliteral">&quot;meow&quot;</span>, &amp;cat::meow);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   print_visitor vi;</div>
<div class="line"> </div>
<div class="line">   type t = type:get_by_name(<span class="stringliteral">&quot;cat&quot;</span>);</div>
<div class="line">   vi.visit(t);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is very important that the include of the visitor is done before the include of <code>&lt;rttr/registration&gt;</code>, otherwise the visitor will not be found by rttr. The reason for that is, the visit functions will be created at compile time, so the declaration has to be before the instantiation. Because of limitations of the c++ preprocessor, it is not possible to include the visitor or the <code>&lt;rttr/registration&gt;</code> header in a precompiled header and use the <a class="el" href="classrttr_1_1visitor.html">visitor</a> functionality. All custom visitors will not be found. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9163d4191db01379565b661a96e748d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9163d4191db01379565b661a96e748d9">&#9670;&nbsp;</a></span>visitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rttr::visitor::visitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor of the visitor class. </p>

</div>
</div>
<a id="a27d4677025d7995536f455dce8b6c3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d4677025d7995536f455dce8b6c3e6">&#9670;&nbsp;</a></span>~visitor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rttr::visitor::~visitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor of the visitor class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a57e2f7777fe71a78710be27672fb1ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e2f7777fe71a78710be27672fb1ffc">&#9670;&nbsp;</a></span>visit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1constructor.html">constructor</a>&#160;</td>
          <td class="paramname"><em>ctor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling this function will indirectly call the function <a class="el" href="classrttr_1_1visitor.html#a06f25ec9658c51a5f12d797021e26098">visit_constructor()</a> or <a class="el" href="classrttr_1_1visitor.html#a48493d942873416daf727c2db35a4d8c">visit_constructor_function()</a> for the underlying registered type. </p>

</div>
</div>
<a id="a2dbc829b44f3b89b5c6c877c26838bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbc829b44f3b89b5c6c877c26838bd1">&#9670;&nbsp;</a></span>visit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1method.html">method</a>&#160;</td>
          <td class="paramname"><em>meth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling this function will indirectly call the function <a class="el" href="classrttr_1_1visitor.html#af8be3ffc422426ab05e336eadd6e8f73">visit_method()</a> for the underlying registered type. </p>

</div>
</div>
<a id="ab36b1ebef7ba224275b963a01fe18760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36b1ebef7ba224275b963a01fe18760">&#9670;&nbsp;</a></span>visit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1property.html">property</a>&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling this function will indirectly call one of the functions: </p>
<ul>
<li><a class="el" href="classrttr_1_1visitor.html#a8d9dea846dd0f8aa5d97e2a67ce6933c">visit_property()</a></li>
<li><a class="el" href="classrttr_1_1visitor.html#abbba36ed2a1ba85fe52b33f7d779f6fc">visit_readonly_property()</a></li>
<li><a class="el" href="classrttr_1_1visitor.html#ab704dcc5237941a3b50a4180ca7bbb27">visit_global_property()</a></li>
<li><a class="el" href="classrttr_1_1visitor.html#aecce1bd39e03b9cdb4b53401e87fa28f">visit_global_readonly_property()</a> for the underlying registered type. </li>
</ul>

</div>
</div>
<a id="a659921da402f9176ff9432fbbde778d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659921da402f9176ff9432fbbde778d1">&#9670;&nbsp;</a></span>visit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling this function will indirectly call the visit functions for all registered types members (constructors, methods, properties, etc...) This includes also registered base classes. </p>

</div>
</div>
<a id="a06f25ec9658c51a5f12d797021e26098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f25ec9658c51a5f12d797021e26098">&#9670;&nbsp;</a></span>visit_constructor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ctor_Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_constructor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1constructor__info.html">constructor_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a constructor via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a> or directly<a class="el" href="classrttr_1_1visitor.html#a57e2f7777fe71a78710be27672fb1ffc">visit(constructor)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">Ctor_Args</td><td>The argument of the constructor </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#a57e2f7777fe71a78710be27672fb1ffc" title="Calling this function will indirectly call the function visit_constructor() or visit_constructor_func...">visit(constructor)</a> </dd></dl>

</div>
</div>
<a id="a48493d942873416daf727c2db35a4d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48493d942873416daf727c2db35a4d8c">&#9670;&nbsp;</a></span>visit_constructor_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_constructor_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1constructor__function__info.html">constructor_function_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a constructor function via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a> or <a class="el" href="classrttr_1_1visitor.html#a57e2f7777fe71a78710be27672fb1ffc">visit(constructor)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#a57e2f7777fe71a78710be27672fb1ffc" title="Calling this function will indirectly call the function visit_constructor() or visit_constructor_func...">visit(constructor)</a> </dd></dl>

</div>
</div>
<a id="ab98191e509a3e9f11b58d90db8683d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98191e509a3e9f11b58d90db8683d5a">&#9670;&nbsp;</a></span>visit_getter_setter_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_getter_setter_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1property__getter__setter__info.html">property_getter_setter_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760" title="Calling this function will indirectly call one of the functions:">visit(property)</a>, <a class="el" href="classrttr_1_1type.html#ae53c4df812c270f3f74b77210bc6a926" title="Returns a property with the name name.">type::get_property()</a> </dd></dl>

</div>
</div>
<a id="aec930042acbc5af7e642caca60a31846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec930042acbc5af7e642caca60a31846">&#9670;&nbsp;</a></span>visit_global_getter_setter_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_global_getter_setter_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1property__getter__setter__info.html">property_getter_setter_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a global property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760" title="Calling this function will indirectly call one of the functions:">visit(property)</a>, <a class="el" href="classrttr_1_1type.html#a9b754b6b0cccc39632323e3ee37f778e" title="Returns a global property with the name name.">type::get_global_property()</a> </dd></dl>

</div>
</div>
<a id="a9bd52ec5497d611801c6ea5c0ac9c57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd52ec5497d611801c6ea5c0ac9c57a">&#9670;&nbsp;</a></span>visit_global_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_global_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1method__info.html">method_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a global method via: <a class="el" href="classrttr_1_1visitor.html#a2dbc829b44f3b89b5c6c877c26838bd1">visit(method)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#a2dbc829b44f3b89b5c6c877c26838bd1" title="Calling this function will indirectly call the function visit_method() for the underlying registered ...">visit(method)</a>, <a class="el" href="classrttr_1_1type.html#a15fa4ae4fb0619be68c3b83967fefb51" title="Returns a global method with the name name.">type::get_global_method()</a> </dd></dl>

</div>
</div>
<a id="ab704dcc5237941a3b50a4180ca7bbb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab704dcc5237941a3b50a4180ca7bbb27">&#9670;&nbsp;</a></span>visit_global_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_global_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a global property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760" title="Calling this function will indirectly call one of the functions:">visit(property)</a>, <a class="el" href="classrttr_1_1type.html#a9b754b6b0cccc39632323e3ee37f778e" title="Returns a global property with the name name.">type::get_global_property()</a> </dd></dl>

</div>
</div>
<a id="aecce1bd39e03b9cdb4b53401e87fa28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecce1bd39e03b9cdb4b53401e87fa28f">&#9670;&nbsp;</a></span>visit_global_readonly_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_global_readonly_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a global read only property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760" title="Calling this function will indirectly call one of the functions:">visit(property)</a>, <a class="el" href="classrttr_1_1type.html#a9b754b6b0cccc39632323e3ee37f778e" title="Returns a global property with the name name.">type::get_global_property()</a> </dd></dl>

</div>
</div>
<a id="af8be3ffc422426ab05e336eadd6e8f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8be3ffc422426ab05e336eadd6e8f73">&#9670;&nbsp;</a></span>visit_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1method__info.html">method_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a type method via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a> or <a class="el" href="classrttr_1_1visitor.html#a2dbc829b44f3b89b5c6c877c26838bd1">visit(method)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#a2dbc829b44f3b89b5c6c877c26838bd1" title="Calling this function will indirectly call the function visit_method() for the underlying registered ...">visit(method)</a>, <a class="el" href="classrttr_1_1type.html#a4d31b84c050f5b22509c16d0379fe0c7" title="Returns a method with the name name.">type::get_method()</a> </dd></dl>

</div>
</div>
<a id="a8d9dea846dd0f8aa5d97e2a67ce6933c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9dea846dd0f8aa5d97e2a67ce6933c">&#9670;&nbsp;</a></span>visit_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760" title="Calling this function will indirectly call one of the functions:">visit(property)</a>, <a class="el" href="classrttr_1_1type.html#ae53c4df812c270f3f74b77210bc6a926" title="Returns a property with the name name.">type::get_property()</a> </dd></dl>

</div>
</div>
<a id="abbba36ed2a1ba85fe52b33f7d779f6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbba36ed2a1ba85fe52b33f7d779f6fc">&#9670;&nbsp;</a></span>visit_readonly_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_readonly_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1property__info.html">property_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a read only property via: <a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760">visit(property)</a>. </p>
<p>Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1visitor.html#ab36b1ebef7ba224275b963a01fe18760" title="Calling this function will indirectly call one of the functions:">visit(property)</a>, <a class="el" href="classrttr_1_1type.html#ae53c4df812c270f3f74b77210bc6a926" title="Returns a property with the name name.">type::get_property()</a> </dd></dl>

</div>
</div>
<a id="ac75649729b94306df014c46e7219040e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75649729b94306df014c46e7219040e">&#9670;&nbsp;</a></span>visit_type_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Base_Classes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_type_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1type__info.html">type_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a type via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a> It is the first function that will be invoked, when visiting a type. </p>
<p>When the visiting type has base classes, it will be first invoked with he most basic type and last step with the current type. Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal template type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">Base_Classes...</td><td>A list of base classes, ascending order </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>You have to register your type via: <a class="el" href="classrttr_1_1registration_1_1class__.html">registration::class_</a> otherwise the static type information for invoke cannot be retrieved. The signature has to match exactly the declaration here, otherwise it will not be invoked.</dd></dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#aed9b001581881e62aaf794f456e405e7" title="Returns a range of all base classes of this type.">type::get_base_classes()</a> </dd></dl>

</div>
</div>
<a id="ae8fba48bc4bd19bf413268be3112dc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fba48bc4bd19bf413268be3112dc3a">&#9670;&nbsp;</a></span>visit_type_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Base_Classes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rttr::visitor::visit_type_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrttr_1_1visitor_1_1type__info.html">type_info</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called when you visit a type via: <a class="el" href="classrttr_1_1visitor.html#a659921da402f9176ff9432fbbde778d1">visit(type)</a>. </p>
<p>It is the last function that will be invoked, when visiting a type. When the visiting type has base classes, it will be first invoked with he most basic type and last step with the current type. Reimplement this function, when you need the static compile time type information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Internal type type, do not work with this parameter directly. </td></tr>
    <tr><td class="paramname">Base_Classes...</td><td>A list of base classes, ascending order </td></tr>
    <tr><td class="paramname">info</td><td>This object will be provided by RTTR, use it's public members and the <code>using's</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>You have to register your type via: <a class="el" href="classrttr_1_1registration_1_1class__.html">registration::class_</a> otherwise the static type information for invoke cannot be retrieved. The signature has to match exactly the declaration here, otherwise it will not be invoked.</dd></dl>
<p>You normally don't call this function directly. However, make sure this function is declared public, otherwise it cannot be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#aed9b001581881e62aaf794f456e405e7" title="Returns a range of all base classes of this type.">type::get_base_classes()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="visitor_8h_source.html">visitor.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html_a8bbc90d48413ac8b5e172d9cc4e4019f"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">rttr::registration::class_::method</a></div><div class="ttdeci">bind&lt; detail::meth, Class_Type, F, acc_level, Visitor_List &gt; method(string_view name, F f, acc_level level=acc_level())</div><div class="ttdoc">Register a method to this class.</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_</a></div><div class="ttdoc">The class_ is used to register classes to RTTR.</div><div class="ttdef"><b>Definition:</b> registration.h:154</div></div>
<div class="ttc" id="aregistration_8h_html_ac6326400f16225ee15b52eabcaae8130"><div class="ttname"><a href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div><div class="ttdeci">#define RTTR_REGISTRATION</div><div class="ttdoc">Use this macro to automatically register your reflection information to RTTR before main is called.</div><div class="ttdef"><b>Definition:</b> registration.h:770</div></div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
