<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr::method Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1method.html">method</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrttr_1_1method-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::method Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classrttr_1_1method.html">method</a> class provides several meta information about a method and can be invoked.  
 <a href="classrttr_1_1method.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="method_8h_source.html">method.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad77b3825aa9e8378d5e05f7fafe01525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">access_levels</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#ad77b3825aa9e8378d5e05f7fafe01525">get_access_level</a> () const noexcept</td></tr>
<tr class="memdesc:ad77b3825aa9e8378d5e05f7fafe01525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the access level with which this method was <a class="el" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">registered</a>.  <a href="classrttr_1_1method.html#ad77b3825aa9e8378d5e05f7fafe01525">More...</a><br /></td></tr>
<tr class="separator:ad77b3825aa9e8378d5e05f7fafe01525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745efaefdfb89779773cccce3919379d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a745efaefdfb89779773cccce3919379d">get_declaring_type</a> () const noexcept</td></tr>
<tr class="memdesc:a745efaefdfb89779773cccce3919379d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class that declares this method.  <a href="classrttr_1_1method.html#a745efaefdfb89779773cccce3919379d">More...</a><br /></td></tr>
<tr class="separator:a745efaefdfb89779773cccce3919379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f5571bc11339c685ca787d14278f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a06f5571bc11339c685ca787d14278f84">get_metadata</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;key) const</td></tr>
<tr class="memdesc:a06f5571bc11339c685ca787d14278f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta data for the given key <code>key</code>.  <a href="classrttr_1_1method.html#a06f5571bc11339c685ca787d14278f84">More...</a><br /></td></tr>
<tr class="separator:a06f5571bc11339c685ca787d14278f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4175378b2b01539f7803462685229421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a4175378b2b01539f7803462685229421">get_name</a> () const noexcept</td></tr>
<tr class="memdesc:a4175378b2b01539f7803462685229421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this method.  <a href="classrttr_1_1method.html#a4175378b2b01539f7803462685229421">More...</a><br /></td></tr>
<tr class="separator:a4175378b2b01539f7803462685229421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e28213d7e723f90a601029e5e06041b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b">get_parameter_infos</a> () const noexcept</td></tr>
<tr class="memdesc:a5e28213d7e723f90a601029e5e06041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ordered range of <a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a> objects, which matches the signature of the method.  <a href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b">More...</a><br /></td></tr>
<tr class="separator:a5e28213d7e723f90a601029e5e06041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6664f371e32d239c5dfdc7abdcf9ba53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a6664f371e32d239c5dfdc7abdcf9ba53">get_return_type</a> () const noexcept</td></tr>
<tr class="memdesc:a6664f371e32d239c5dfdc7abdcf9ba53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type object of the return type.  <a href="classrttr_1_1method.html#a6664f371e32d239c5dfdc7abdcf9ba53">More...</a><br /></td></tr>
<tr class="separator:a6664f371e32d239c5dfdc7abdcf9ba53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c25c087fd4398a164b5ecdc8657828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a76c25c087fd4398a164b5ecdc8657828">get_signature</a> () const noexcept</td></tr>
<tr class="memdesc:a76c25c087fd4398a164b5ecdc8657828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the signature of this method as readable string.  <a href="classrttr_1_1method.html#a76c25c087fd4398a164b5ecdc8657828">More...</a><br /></td></tr>
<tr class="separator:a76c25c087fd4398a164b5ecdc8657828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4351075b4cbe6f2f2b6500cf226f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object) const</td></tr>
<tr class="memdesc:aea4351075b4cbe6f2f2b6500cf226f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>.  <a href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">More...</a><br /></td></tr>
<tr class="separator:aea4351075b4cbe6f2f2b6500cf226f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45898a433017eb397655a66fa2bd243f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a45898a433017eb397655a66fa2bd243f">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1) const</td></tr>
<tr class="memdesc:a45898a433017eb397655a66fa2bd243f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="classrttr_1_1method.html#a45898a433017eb397655a66fa2bd243f">More...</a><br /></td></tr>
<tr class="separator:a45898a433017eb397655a66fa2bd243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff19d8b10a2a6db85e5138c56d4b0c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#aff19d8b10a2a6db85e5138c56d4b0c8b">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2) const</td></tr>
<tr class="memdesc:aff19d8b10a2a6db85e5138c56d4b0c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="classrttr_1_1method.html#aff19d8b10a2a6db85e5138c56d4b0c8b">More...</a><br /></td></tr>
<tr class="separator:aff19d8b10a2a6db85e5138c56d4b0c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fb75626ca09a29e257511d72a06c0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a54fb75626ca09a29e257511d72a06c0c">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2, <a class="el" href="classrttr_1_1argument.html">argument</a> arg3) const</td></tr>
<tr class="memdesc:a54fb75626ca09a29e257511d72a06c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="classrttr_1_1method.html#a54fb75626ca09a29e257511d72a06c0c">More...</a><br /></td></tr>
<tr class="separator:a54fb75626ca09a29e257511d72a06c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ae9f26abe64243f035ca63fbf61b63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#ad3ae9f26abe64243f035ca63fbf61b63">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2, <a class="el" href="classrttr_1_1argument.html">argument</a> arg3, <a class="el" href="classrttr_1_1argument.html">argument</a> arg4) const</td></tr>
<tr class="memdesc:ad3ae9f26abe64243f035ca63fbf61b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="classrttr_1_1method.html#ad3ae9f26abe64243f035ca63fbf61b63">More...</a><br /></td></tr>
<tr class="separator:ad3ae9f26abe64243f035ca63fbf61b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912e86ab9bcd43cfbf2adc63ded6f348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a912e86ab9bcd43cfbf2adc63ded6f348">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2, <a class="el" href="classrttr_1_1argument.html">argument</a> arg3, <a class="el" href="classrttr_1_1argument.html">argument</a> arg4, <a class="el" href="classrttr_1_1argument.html">argument</a> arg5) const</td></tr>
<tr class="memdesc:a912e86ab9bcd43cfbf2adc63ded6f348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="classrttr_1_1method.html#a912e86ab9bcd43cfbf2adc63ded6f348">More...</a><br /></td></tr>
<tr class="separator:a912e86ab9bcd43cfbf2adc63ded6f348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a2cfbfc44c76c25c6b09015f0a172a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a33a2cfbfc44c76c25c6b09015f0a172a">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2, <a class="el" href="classrttr_1_1argument.html">argument</a> arg3, <a class="el" href="classrttr_1_1argument.html">argument</a> arg4, <a class="el" href="classrttr_1_1argument.html">argument</a> arg5, <a class="el" href="classrttr_1_1argument.html">argument</a> arg6) const</td></tr>
<tr class="memdesc:a33a2cfbfc44c76c25c6b09015f0a172a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="classrttr_1_1method.html#a33a2cfbfc44c76c25c6b09015f0a172a">More...</a><br /></td></tr>
<tr class="separator:a33a2cfbfc44c76c25c6b09015f0a172a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad72c0f02fd54b44dd3f8b440b2efae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#aad72c0f02fd54b44dd3f8b440b2efae6">invoke_variadic</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args) const</td></tr>
<tr class="memdesc:aad72c0f02fd54b44dd3f8b440b2efae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="classrttr_1_1method.html#aad72c0f02fd54b44dd3f8b440b2efae6">More...</a><br /></td></tr>
<tr class="separator:aad72c0f02fd54b44dd3f8b440b2efae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af774fe427572fcc02ba27e545d83e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a2af774fe427572fcc02ba27e545d83e0">is_static</a> () const noexcept</td></tr>
<tr class="memdesc:a2af774fe427572fcc02ba27e545d83e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this method is static method, otherwise false.  <a href="classrttr_1_1method.html#a2af774fe427572fcc02ba27e545d83e0">More...</a><br /></td></tr>
<tr class="separator:a2af774fe427572fcc02ba27e545d83e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2a8eb5a5145d5eb4e3d33787dd6c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a91f2a8eb5a5145d5eb4e3d33787dd6c7">is_valid</a> () const noexcept</td></tr>
<tr class="memdesc:a91f2a8eb5a5145d5eb4e3d33787dd6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this method is valid, otherwise false.  <a href="classrttr_1_1method.html#a91f2a8eb5a5145d5eb4e3d33787dd6c7">More...</a><br /></td></tr>
<tr class="separator:a91f2a8eb5a5145d5eb4e3d33787dd6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221b5e6633a53a2dafd5b83ff631cdc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a221b5e6633a53a2dafd5b83ff631cdc4">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a221b5e6633a53a2dafd5b83ff631cdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to check if this method is valid or not.  <a href="classrttr_1_1method.html#a221b5e6633a53a2dafd5b83ff631cdc4">More...</a><br /></td></tr>
<tr class="separator:a221b5e6633a53a2dafd5b83ff631cdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801d0f06011c99e46256ff54578a4dc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a801d0f06011c99e46256ff54578a4dc3">operator!=</a> (const <a class="el" href="classrttr_1_1method.html">method</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a801d0f06011c99e46256ff54578a4dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this method is the not the same like the <code>other</code>.  <a href="classrttr_1_1method.html#a801d0f06011c99e46256ff54578a4dc3">More...</a><br /></td></tr>
<tr class="separator:a801d0f06011c99e46256ff54578a4dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8843f51ceafcb39ae38e1a4ed4ee97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a6d8843f51ceafcb39ae38e1a4ed4ee97">operator==</a> (const <a class="el" href="classrttr_1_1method.html">method</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a6d8843f51ceafcb39ae38e1a4ed4ee97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this method is the same like the <code>other</code>.  <a href="classrttr_1_1method.html#a6d8843f51ceafcb39ae38e1a4ed4ee97">More...</a><br /></td></tr>
<tr class="separator:a6d8843f51ceafcb39ae38e1a4ed4ee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classrttr_1_1method.html">method</a> class provides several meta information about a method and can be invoked. </p>
<p>A instance of a method class can only be obtained from the <a class="el" href="classrttr_1_1type.html">type</a> class. See <a class="el" href="classrttr_1_1type.html#a4d31b84c050f5b22509c16d0379fe0c7">type::get_method()</a> and <a class="el" href="classrttr_1_1type.html#a67ffced2826ff08f2a761acbeb133ae9">type::get_methods()</a>.</p>
<p>For registration a method, nested inside a class, see <a class="el" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">registration::class_&lt;T&gt;::method()</a> and for global methods see <a class="el" href="classrttr_1_1registration.html#ae37c7b97c7b6cc20d88d34d8aa26e12b">registration::method()</a>.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Meta Information</h2>
<p>A <a class="el" href="classrttr_1_1method.html">method</a> has a <a class="el" href="classrttr_1_1method.html#a4175378b2b01539f7803462685229421">name</a>, a <a class="el" href="classrttr_1_1method.html#a76c25c087fd4398a164b5ecdc8657828">signature</a>, a <a class="el" href="classrttr_1_1method.html#a6664f371e32d239c5dfdc7abdcf9ba53">return type</a>, a list of <a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b">parameter information</a> as well as attributes that specify its behavior: <a class="el" href="classrttr_1_1method.html#a2af774fe427572fcc02ba27e545d83e0">is_static()</a>. When the <a class="el" href="classrttr_1_1method.html">method</a> was declared inside a class, then <a class="el" href="classrttr_1_1method.html#a745efaefdfb89779773cccce3919379d">get_declaring_type()</a> can be used to obtain the type of this class.</p>
<p>The method can be invoked with <a class="el" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke()</a>; When its not a <a class="el" href="classrttr_1_1method.html#a2af774fe427572fcc02ba27e545d83e0">static method</a> you have to provide a valid class instance to invoke the method. This instance can be the raw type on the stack; the current class hierarchy level doesn't matter. It can be also a raw pointer to the object or a <a class="el" href="classrttr_1_1variant.html">variant</a> which contains the instance, again as pointer or stack object. When the method is declared as static you you still have to provide an empty instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>, or as shortcut use simply <code>{}</code>.</p>
<p>A method will be successfully invoked when the provided instance can be converted to the <a class="el" href="classrttr_1_1method.html#a745efaefdfb89779773cccce3919379d">declared class</a> type. When the method has <a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b">parameters</a> defined, then the same number of arguments must be provided and the type itself must <b>100% match</b> the type of the registered function. An automatically type conversion is <b>not</b> performed.</p>
<p>The return type of <a class="el" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke()</a> is \ef variant object. This object contains not only the possible return value of a function, it also indicates whether the method was invoked or not. A <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">valid</a> variant object means, that then the method was successfully invoked, otherwise not. When the invoked method has no return type, i.e. is a <code>void</code> method, then a valid variant of type <code>void</code> is returned.</p>
<p>While the <a class="el" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke()</a> function can directly forward up to six arguments, it is sometime necessary to forward even more arguments. Therefore the function <a class="el" href="classrttr_1_1method.html#aad72c0f02fd54b44dd3f8b440b2efae6">invoke_variadic()</a> should be used; it allows to pack an unlimited amount of arguments into a std::vector and forward them to the function.</p>
<p>Another way to invoke a method is to use the <a class="el" href="classrttr_1_1type.html">type</a> class through <a class="el" href="classrttr_1_1type.html#afc7329cac11337f4022d7d10eebe80d3">type::invoke()</a>.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Copying and Assignment</h2>
<p>A <a class="el" href="classrttr_1_1method.html">method</a> object is lightweight and can be copied by value. However, each copy will refer to the same underlying method.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Typical Usage</h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>MyStruct { <span class="keywordtype">int</span> my_method(<span class="keywordtype">int</span> param) { <span class="keywordflow">return</span> param; } };</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><a class="code" href="classrttr_1_1variant.html">variant</a> obj = <a class="code" href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">type::get_by_name</a>(<span class="stringliteral">&quot;MyStruct&quot;</span>).<a class="code" href="classrttr_1_1type.html#ad44572a03514d83035580f516ebaf4e1">create</a>({});</div>
<div class="line"><a class="code" href="classrttr_1_1method.html">method</a> func = obj.<a class="code" href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">get_type</a>().<a class="code" href="classrttr_1_1type.html#a4d31b84c050f5b22509c16d0379fe0c7">get_method</a>(<span class="stringliteral">&quot;my_method&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (func)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="classrttr_1_1variant.html">variant</a> val = func.<a class="code" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke</a>(obj, 23);</div>
<div class="line">   std::cout &lt;&lt; val.<a class="code" href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">get_value</a>&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// prints 23</span></div>
<div class="line">   <span class="comment">// you can also invoke the method with an object on the stack</span></div>
<div class="line">   MyStruct inst;</div>
<div class="line">   val = func.<a class="code" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke</a>(inst, 42);</div>
<div class="line">   std::cout &lt;&lt; val.<a class="code" href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">get_value</a>&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// prints 42</span></div>
<div class="line">   <span class="comment">// or as pointer</span></div>
<div class="line">   MyStruct* ptr = &amp;inst;</div>
<div class="line">   val = func.<a class="code" href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">invoke</a>(ptr, 7);</div>
<div class="line">   std::cout &lt;&lt; val.<a class="code" href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">get_value</a>&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// prints 7</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1property.html" title="The property class provides several meta information about a property and gives read/write access to ...">property</a>, <a class="el" href="classrttr_1_1enumeration.html" title="The enumeration class provides several meta information about an enum.">enumeration</a>, <a class="el" href="classrttr_1_1constructor.html" title="The constructor class provides several meta information about a constructor and can be invoked.">constructor</a> and <a class="el" href="classrttr_1_1type.html" title="The type class holds the type information for any arbitrary object.">type</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad77b3825aa9e8378d5e05f7fafe01525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77b3825aa9e8378d5e05f7fafe01525">&#9670;&nbsp;</a></span>get_access_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">access_levels</a> rttr::method::get_access_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the access level with which this method was <a class="el" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">registered</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the method is not valid, this function will return level <a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611ba84807fec67699af41c7bcb3a57dce40b">access_levels::public_access</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">access_levels</a> of the method. </dd></dl>

</div>
</div>
<a id="a745efaefdfb89779773cccce3919379d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745efaefdfb89779773cccce3919379d">&#9670;&nbsp;</a></span>get_declaring_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::method::get_declaring_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class that declares this method. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When this method does not belong to a class (i.e. is a global method) it will return an invalid type. When this method is not valid, this function will return an invalid type object (see <a class="el" href="classrttr_1_1type.html#a5d6b241be3e6a25d787248e0b9d6f20b">type::is_valid</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classrttr_1_1type.html">Type</a> of the declaring class/struct for this method. </dd></dl>

</div>
</div>
<a id="a06f5571bc11339c685ca787d14278f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f5571bc11339c685ca787d14278f84">&#9670;&nbsp;</a></span>get_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::get_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the meta data for the given key <code>key</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When no meta data is registered with the given <code>key</code>, an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object is returned (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant object, containing arbitrary data. </dd></dl>

</div>
</div>
<a id="a4175378b2b01539f7803462685229421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4175378b2b01539f7803462685229421">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> rttr::method::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this method. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of the method. </dd></dl>

</div>
</div>
<a id="a5e28213d7e723f90a601029e5e06041b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e28213d7e723f90a601029e5e06041b">&#9670;&nbsp;</a></span>get_parameter_infos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt;<a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a>&gt; rttr::method::get_parameter_infos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an ordered range of <a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a> objects, which matches the signature of the method. </p>
<dl class="section return"><dt>Returns</dt><dd>A range of <a class="el" href="classrttr_1_1parameter__info.html" title="The parameter_info class provides several meta information about a parameter.">parameter_info</a> objects of the method signature. </dd></dl>

</div>
</div>
<a id="a6664f371e32d239c5dfdc7abdcf9ba53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6664f371e32d239c5dfdc7abdcf9ba53">&#9670;&nbsp;</a></span>get_return_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::method::get_return_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type object of the return type. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a id="a76c25c087fd4398a164b5ecdc8657828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c25c087fd4398a164b5ecdc8657828">&#9670;&nbsp;</a></span>get_signature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> rttr::method::get_signature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the signature of this method as readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>The signature as readable string. </dd></dl>

</div>
</div>
<a id="aea4351075b4cbe6f2f2b6500cf226f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4351075b4cbe6f2f2b6500cf226f20">&#9670;&nbsp;</a></span>invoke() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b" title="Returns an ordered range of parameter_info objects, which matches the signature of the method.">get_parameter_infos()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The possible return value of the method. </dd></dl>

</div>
</div>
<a id="a45898a433017eb397655a66fa2bd243f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45898a433017eb397655a66fa2bd243f">&#9670;&nbsp;</a></span>invoke() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The given argument type has to match <b>exactly</b> the type of the underling method parameter, otherwise the method cannot be invoked and an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>) will be returned. When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The possible return value of the method.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b" title="Returns an ordered range of parameter_info objects, which matches the signature of the method.">get_parameter_infos()</a> </dd></dl>

</div>
</div>
<a id="aff19d8b10a2a6db85e5138c56d4b0c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff19d8b10a2a6db85e5138c56d4b0c8b">&#9670;&nbsp;</a></span>invoke() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The given argument type has to match <b>exactly</b> the type of the underling method parameter, otherwise the method cannot be invoked and an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>) will be returned. When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b" title="Returns an ordered range of parameter_info objects, which matches the signature of the method.">get_parameter_infos()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The possible return value of the method. </dd></dl>

</div>
</div>
<a id="a54fb75626ca09a29e257511d72a06c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fb75626ca09a29e257511d72a06c0c">&#9670;&nbsp;</a></span>invoke() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The given argument type has to match <b>exactly</b> the type of the underling method parameter, otherwise the method cannot be invoked and an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>) will be returned. When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b" title="Returns an ordered range of parameter_info objects, which matches the signature of the method.">get_parameter_infos()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The possible return value of the method. </dd></dl>

</div>
</div>
<a id="ad3ae9f26abe64243f035ca63fbf61b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ae9f26abe64243f035ca63fbf61b63">&#9670;&nbsp;</a></span>invoke() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The given argument type has to match <b>exactly</b> the type of the underling method parameter, otherwise the method cannot be invoked and an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>) will be returned. When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b" title="Returns an ordered range of parameter_info objects, which matches the signature of the method.">get_parameter_infos()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The possible return value of the method. </dd></dl>

</div>
</div>
<a id="a912e86ab9bcd43cfbf2adc63ded6f348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912e86ab9bcd43cfbf2adc63ded6f348">&#9670;&nbsp;</a></span>invoke() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The given argument type has to match <b>exactly</b> the type of the underling method parameter, otherwise the method cannot be invoked and an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>) will be returned. When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b" title="Returns an ordered range of parameter_info objects, which matches the signature of the method.">get_parameter_infos()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The possible return value of the method. </dd></dl>

</div>
</div>
<a id="a33a2cfbfc44c76c25c6b09015f0a172a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a2cfbfc44c76c25c6b09015f0a172a">&#9670;&nbsp;</a></span>invoke() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The given argument type has to match <b>exactly</b> the type of the underling method parameter, otherwise the method cannot be invoked and an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>) will be returned. When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b" title="Returns an ordered range of parameter_info objects, which matches the signature of the method.">get_parameter_infos()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The possible return value of the method. </dd></dl>

</div>
</div>
<a id="aad72c0f02fd54b44dd3f8b440b2efae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad72c0f02fd54b44dd3f8b440b2efae6">&#9670;&nbsp;</a></span>invoke_variadic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke_variadic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<p>Use this method when the argument count is higher then six.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The given argument type has to match <b>exactly</b> the type of the underling method parameter, otherwise the method cannot be invoked and an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object (see <a class="el" href="classrttr_1_1variant.html#aed6e6a2e29b4d1ac51a09b7d9037dd44">variant::is_valid</a>) will be returned. When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a0cf19f806ca5d41cf2341a08c0c3a38c">instance()</a>. Using this invoke function is slower, then specifying the arguments directly.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#a5e28213d7e723f90a601029e5e06041b" title="Returns an ordered range of parameter_info objects, which matches the signature of the method.">get_parameter_infos()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The possible return value of the method. </dd></dl>

</div>
</div>
<a id="a2af774fe427572fcc02ba27e545d83e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af774fe427572fcc02ba27e545d83e0">&#9670;&nbsp;</a></span>is_static()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::method::is_static </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this method is static method, otherwise false. </p>
<p>A static method does not need an instance for performing an invoke.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When the method is not valid, this function will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a static method, otherwise false. </dd></dl>

</div>
</div>
<a id="a91f2a8eb5a5145d5eb4e3d33787dd6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f2a8eb5a5145d5eb4e3d33787dd6c7">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::method::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this method is valid, otherwise false. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this method is valid, otherwise false. </dd></dl>

</div>
</div>
<a id="a221b5e6633a53a2dafd5b83ff631cdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221b5e6633a53a2dafd5b83ff631cdc4">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rttr::method::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to check if this method is valid or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this method is valid, otherwise false. </dd></dl>

</div>
</div>
<a id="a801d0f06011c99e46256ff54578a4dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801d0f06011c99e46256ff54578a4dc3">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::method::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1method.html">method</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this method is the not the same like the <code>other</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both methods are different, otherwise false. </dd></dl>

</div>
</div>
<a id="a6d8843f51ceafcb39ae38e1a4ed4ee97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8843f51ceafcb39ae38e1a4ed4ee97">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::method::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1method.html">method</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this method is the same like the <code>other</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both methods are equal, otherwise false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="method_8h_source.html">method.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespacerttr_html"><div class="ttname"><a href="namespacerttr.html">rttr</a></div><div class="ttdef"><b>Definition:</b> access_levels.h:33</div></div>
<div class="ttc" id="aclassrttr_1_1method_html_aea4351075b4cbe6f2f2b6500cf226f20"><div class="ttname"><a href="classrttr_1_1method.html#aea4351075b4cbe6f2f2b6500cf226f20">rttr::method::invoke</a></div><div class="ttdeci">variant invoke(instance object) const</div><div class="ttdoc">Invokes the method represented by the current instance object.</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a4d31b84c050f5b22509c16d0379fe0c7"><div class="ttname"><a href="classrttr_1_1type.html#a4d31b84c050f5b22509c16d0379fe0c7">rttr::type::get_method</a></div><div class="ttdeci">method get_method(string_view name) const noexcept</div><div class="ttdoc">Returns a method with the name name.</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html_aa3a9f7e07cdc4d922a4e09882c5c0574"><div class="ttname"><a href="classrttr_1_1variant.html#aa3a9f7e07cdc4d922a4e09882c5c0574">rttr::variant::get_value</a></div><div class="ttdeci">T &amp; get_value()</div><div class="ttdoc">Returns a reference to the containing value as type T.</div></div>
<div class="ttc" id="aclassrttr_1_1method_html"><div class="ttname"><a href="classrttr_1_1method.html">rttr::method</a></div><div class="ttdoc">The method class provides several meta information about a method and can be invoked.</div><div class="ttdef"><b>Definition:</b> method.h:146</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html"><div class="ttname"><a href="classrttr_1_1variant.html">rttr::variant</a></div><div class="ttdoc">The variant class allows to store data of any type and convert between these types transparently.</div><div class="ttdef"><b>Definition:</b> variant.h:223</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_ad44572a03514d83035580f516ebaf4e1"><div class="ttname"><a href="classrttr_1_1type.html#ad44572a03514d83035580f516ebaf4e1">rttr::type::create</a></div><div class="ttdeci">variant create(std::vector&lt; argument &gt; args=std::vector&lt; argument &gt;()) const</div><div class="ttdoc">Creates an instance of the current type, with the given arguments args for the constructor.</div></div>
<div class="ttc" id="aclassrttr_1_1variant_html_a7a72579286ed164225c5be882ab6ea81"><div class="ttname"><a href="classrttr_1_1variant.html#a7a72579286ed164225c5be882ab6ea81">rttr::variant::get_type</a></div><div class="ttdeci">type get_type() const</div><div class="ttdoc">Returns the type object of underlying data.</div></div>
<div class="ttc" id="aclassrttr_1_1type_html_a7ba79b9f4916c30db74fe65508dca033"><div class="ttname"><a href="classrttr_1_1type.html#a7ba79b9f4916c30db74fe65508dca033">rttr::type::get_by_name</a></div><div class="ttdeci">static type get_by_name(string_view name) noexcept</div><div class="ttdoc">Returns the type object with the given name name.</div></div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
