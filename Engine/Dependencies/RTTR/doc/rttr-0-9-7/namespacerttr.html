<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.7</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rttr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1argument.html">argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1argument.html">argument</a> class is used for forwarding arguments to <a class="el" href="classrttr_1_1property.html">properties</a> or <a class="el" href="classrttr_1_1method.html">methods</a>.  <a href="classrttr_1_1argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html">array_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1array__range.html">array_range</a> class provides a view into an underlying data structure with lower and upper limits.  <a href="classrttr_1_1array__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1associative__container__mapper.html">associative_container_mapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1associative__container__mapper.html">associative_container_mapper</a> class is a class template to access an associative container via one common interface.  <a href="structrttr_1_1associative__container__mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a> describes an non-owning reference to a constant contiguous sequence of char-like objects.  <a href="classrttr_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1constructor.html">constructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1constructor.html">constructor</a> class provides several meta information about a constructor and can be invoked.  <a href="classrttr_1_1constructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1destructor.html">destructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1destructor.html">destructor</a> class provides a destructor for registered types.  <a href="classrttr_1_1destructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1enum__flags.html">enum_flags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1enum__flags.html">enum_flags</a> class template is used to store OR-combinations of enum values in a type-safe way.  <a href="classrttr_1_1enum__flags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1enumeration.html">enumeration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1enumeration.html">enumeration</a> class provides several meta information about an enum.  <a href="classrttr_1_1enumeration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1instance.html">instance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1instance.html">instance</a> class is used for forwarding the instance of an object to invoke a <a class="el" href="classrttr_1_1property.html">property</a> or <a class="el" href="classrttr_1_1method.html">method</a>.  <a href="classrttr_1_1instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1library.html">library</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1library.html">library</a> class provides a cross platform way of explicit loading shared objects (<code>.so</code> on Unix based system and <code>.DLL</code> on windows).  <a href="classrttr_1_1library.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html">method</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1method.html">method</a> class provides several meta information about a method and can be invoked.  <a href="classrttr_1_1method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a> class provides several meta information about a parameter.  <a href="classrttr_1_1parameter__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1policy.html">policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1policy.html">policy</a> class contains all policies that can be used during the registration of reflection information.  <a href="structrttr_1_1policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1property.html">property</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1property.html">property</a> class provides several meta information about a property and gives read/write access to its value.  <a href="classrttr_1_1property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1registration.html">registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1registration.html">registration</a> class is the entry point for the manual registration of reflection information to the type system.  <a href="classrttr_1_1registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1sequential__container__mapper.html">sequential_container_mapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1sequential__container__mapper.html">sequential_container_mapper</a> class is a class template to access an associative container via one common interface.  <a href="structrttr_1_1sequential__container__mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html">type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1type.html">type</a> class holds the type information for any arbitrary object.  <a href="classrttr_1_1type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1type__list.html">type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a list of template parameters.  <a href="structrttr_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant.html">variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1variant.html">variant</a> class allows to store data of any type and convert between these types transparently.  <a href="classrttr_1_1variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant__associative__view.html">variant_associative_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1variant__associative__view.html">variant_associative_view</a> describes a class that refers to an <a href="https://en.wikipedia.org/wiki/Associative_containers" target="_blank">associative container</a> (e.g: <code>std::map</code>) inside a <a class="el" href="classrttr_1_1variant.html">variant</a>.  <a href="classrttr_1_1variant__associative__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1variant__sequential__view.html">variant_sequential_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classrttr_1_1variant__sequential__view.html">variant_sequential_view</a> describes a class that refers to an <a href="https://en.wikipedia.org/wiki/Sequence_container_(C%2B%2B)" target="_blank">sequence container</a> (e.g: <code>std::vector</code>) inside a <a class="el" href="classrttr_1_1variant.html">variant</a>.  <a href="classrttr_1_1variant__sequential__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1visitor.html">visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classrttr_1_1visitor.html">visitor</a>, is used for visiting your registered accessors of a type at compile time.  <a href="classrttr_1_1visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper</a> class is a class template to access different wrapper types via one common interface.  <a href="structrttr_1_1wrapper__mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a61265f69675ac438ecfa23b084adaa56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> = <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a61265f69675ac438ecfa23b084adaa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to hold a reference to a continuous sequence of <code>char</code> objects.  <a href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">More...</a><br /></td></tr>
<tr class="separator:a61265f69675ac438ecfa23b084adaa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa07db0e4984d0c48adc5d61f834d611b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">access_levels</a> { <a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611ba84807fec67699af41c7bcb3a57dce40b">access_levels::public_access</a>, 
<a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611ba2a680ba924878f265e7babc8b99edeb5">access_levels::protected_access</a>, 
<a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611bac660fa8edf326cb81471f80104953e47">access_levels::private_access</a>
 }</td></tr>
<tr class="memdesc:aa07db0e4984d0c48adc5d61f834d611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The access_levels enum represents the three access modifiers, which can be used in classes to encapsulate members access.  <a href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">More...</a><br /></td></tr>
<tr class="separator:aa07db0e4984d0c48adc5d61f834d611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3814ecb941ae0fe288c8d67703ced7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">filter_item</a> { <br />
&#160;&#160;<a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> = 1, 
<a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d">filter_item::static_item</a> = 2, 
<a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b">filter_item::public_access</a> = 4, 
<a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a> = 8, 
<br />
&#160;&#160;<a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da">filter_item::declared_only</a> = 16
<br />
 }</td></tr>
<tr class="memdesc:a5b3814ecb941ae0fe288c8d67703ced7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filter_item enum is used to filter the search for certain members in types.  <a href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">More...</a><br /></td></tr>
<tr class="separator:a5b3814ecb941ae0fe288c8d67703ced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afdaed4515c436b34b8e24af714a09c64"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs&gt; </td></tr>
<tr class="memitem:afdaed4515c436b34b8e24af714a09c64"><td class="memTemplItemLeft" align="right" valign="top">detail::default_args&lt; TArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> (TArgs &amp;&amp;...args)</td></tr>
<tr class="memdesc:afdaed4515c436b34b8e24af714a09c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> function should be used add default arguments, for <a class="el" href="classrttr_1_1constructor.html">constructors</a> or a <a class="el" href="classrttr_1_1method.html">methods</a> during the registration process of reflection information.  <a href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">More...</a><br /></td></tr>
<tr class="separator:afdaed4515c436b34b8e24af714a09c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd2b848b4d218241a8b6e8f7cdbeb93"><td class="memItemLeft" align="right" valign="top">detail::metadata&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a2cd2b848b4d218241a8b6e8f7cdbeb93">metadata</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> key, <a class="el" href="classrttr_1_1variant.html">variant</a> <a class="el" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a>)</td></tr>
<tr class="memdesc:a2cd2b848b4d218241a8b6e8f7cdbeb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacerttr.html#a2cd2b848b4d218241a8b6e8f7cdbeb93">metadata</a> function can be used to add additional meta data information during the registration process of reflection information.  <a href="namespacerttr.html#a2cd2b848b4d218241a8b6e8f7cdbeb93">More...</a><br /></td></tr>
<tr class="separator:a2cd2b848b4d218241a8b6e8f7cdbeb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abd793e9a1346ca80ca4783b7460685"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a0abd793e9a1346ca80ca4783b7460685"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a0abd793e9a1346ca80ca4783b7460685">operator!=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a0abd793e9a1346ca80ca4783b7460685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two views <code>lhs</code> and <code>rhs</code>.  <a href="namespacerttr.html#a0abd793e9a1346ca80ca4783b7460685">More...</a><br /></td></tr>
<tr class="separator:a0abd793e9a1346ca80ca4783b7460685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d8d40085ba97ccb6fc88814c0c8b47"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a69d8d40085ba97ccb6fc88814c0c8b47"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a69d8d40085ba97ccb6fc88814c0c8b47">operator!=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a69d8d40085ba97ccb6fc88814c0c8b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583618e87cd4e9f780934248754a2ba4"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a583618e87cd4e9f780934248754a2ba4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a583618e87cd4e9f780934248754a2ba4">operator!=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a583618e87cd4e9f780934248754a2ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fde7d28377d122dc39bcb9b7ad2b1fe"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a4fde7d28377d122dc39bcb9b7ad2b1fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a4fde7d28377d122dc39bcb9b7ad2b1fe">operator!=</a> (const char *lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:a4fde7d28377d122dc39bcb9b7ad2b1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f8b8f2eccc4ec22a6a188a3661701e"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a83f8b8f2eccc4ec22a6a188a3661701e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a83f8b8f2eccc4ec22a6a188a3661701e">operator!=</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:a83f8b8f2eccc4ec22a6a188a3661701e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c3420c543216c1544456be71e30869"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a33c3420c543216c1544456be71e30869"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a33c3420c543216c1544456be71e30869">operator+</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="separator:a33c3420c543216c1544456be71e30869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11ff54066618c4fed339975c5570aa8"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ae11ff54066618c4fed339975c5570aa8"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#ae11ff54066618c4fed339975c5570aa8">operator+</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, std::basic_string&lt; CharT, Traits &gt; &amp;&amp;rhs)</td></tr>
<tr class="separator:ae11ff54066618c4fed339975c5570aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a190ef645ecf8c0d0f0cc281cb0c3e1"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a9a190ef645ecf8c0d0f0cc281cb0c3e1"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a9a190ef645ecf8c0d0f0cc281cb0c3e1">operator+</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="separator:a9a190ef645ecf8c0d0f0cc281cb0c3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932b2ea821dffaf8ae5a8264694df8ca"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a932b2ea821dffaf8ae5a8264694df8ca"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a932b2ea821dffaf8ae5a8264694df8ca">operator+</a> (std::basic_string&lt; CharT, Traits &gt; &amp;&amp;lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="separator:a932b2ea821dffaf8ae5a8264694df8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f898015327841d2862726e29ea6af4"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ac8f898015327841d2862726e29ea6af4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#ac8f898015327841d2862726e29ea6af4">operator&lt;</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ac8f898015327841d2862726e29ea6af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two views <code>lhs</code> and <code>rhs</code>.  <a href="namespacerttr.html#ac8f898015327841d2862726e29ea6af4">More...</a><br /></td></tr>
<tr class="separator:ac8f898015327841d2862726e29ea6af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0436d4ed4f29f452c0102b01961e033b"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a0436d4ed4f29f452c0102b01961e033b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a0436d4ed4f29f452c0102b01961e033b">operator&lt;</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a0436d4ed4f29f452c0102b01961e033b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0814fb707205323e46e021965f5b6467"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a0814fb707205323e46e021965f5b6467"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a0814fb707205323e46e021965f5b6467">operator&lt;</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0814fb707205323e46e021965f5b6467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a537d9a01f979fa046f7d1cbbf3cfc"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a37a537d9a01f979fa046f7d1cbbf3cfc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a37a537d9a01f979fa046f7d1cbbf3cfc">operator&lt;</a> (const char *lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:a37a537d9a01f979fa046f7d1cbbf3cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefad3fbe367d9b94fbb7c3dac737c22"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:afefad3fbe367d9b94fbb7c3dac737c22"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#afefad3fbe367d9b94fbb7c3dac737c22">operator&lt;</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:afefad3fbe367d9b94fbb7c3dac737c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2079d606e33ce6fb3d46351e7806b8e5"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a2079d606e33ce6fb3d46351e7806b8e5"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a2079d606e33ce6fb3d46351e7806b8e5">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;os, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; v)</td></tr>
<tr class="memdesc:a2079d606e33ce6fb3d46351e7806b8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a stream output on a <a class="el" href="classrttr_1_1basic__string__view.html" title="The class template basic_string_view describes an non-owning reference to a constant contiguous seque...">basic_string_view</a> .  <a href="namespacerttr.html#a2079d606e33ce6fb3d46351e7806b8e5">More...</a><br /></td></tr>
<tr class="separator:a2079d606e33ce6fb3d46351e7806b8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031dfd0b213dcb2128d8cdf9b32ae573"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a031dfd0b213dcb2128d8cdf9b32ae573"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a031dfd0b213dcb2128d8cdf9b32ae573">operator&lt;=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a031dfd0b213dcb2128d8cdf9b32ae573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two views <code>lhs</code> and <code>rhs</code>.  <a href="namespacerttr.html#a031dfd0b213dcb2128d8cdf9b32ae573">More...</a><br /></td></tr>
<tr class="separator:a031dfd0b213dcb2128d8cdf9b32ae573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96568e5a10c8cab6ae94227951ca8165"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a96568e5a10c8cab6ae94227951ca8165"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a96568e5a10c8cab6ae94227951ca8165">operator&lt;=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a96568e5a10c8cab6ae94227951ca8165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41278e01f38cba2efd6adb40c4ea5d7"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab41278e01f38cba2efd6adb40c4ea5d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#ab41278e01f38cba2efd6adb40c4ea5d7">operator&lt;=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab41278e01f38cba2efd6adb40c4ea5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0decbe50db05fb1696af289bd1d5d594"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a0decbe50db05fb1696af289bd1d5d594"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a0decbe50db05fb1696af289bd1d5d594">operator&lt;=</a> (const char *lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:a0decbe50db05fb1696af289bd1d5d594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f027b305cc60359fe8a6ca9e78216e6"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a4f027b305cc60359fe8a6ca9e78216e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a4f027b305cc60359fe8a6ca9e78216e6">operator&lt;=</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:a4f027b305cc60359fe8a6ca9e78216e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a12343f43cbacffc32270264c6d57c9"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a4a12343f43cbacffc32270264c6d57c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a4a12343f43cbacffc32270264c6d57c9">operator==</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a4a12343f43cbacffc32270264c6d57c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two views <code>lhs</code> and <code>rhs</code>.  <a href="namespacerttr.html#a4a12343f43cbacffc32270264c6d57c9">More...</a><br /></td></tr>
<tr class="separator:a4a12343f43cbacffc32270264c6d57c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a068dc67129c918622d48104d86a954"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a6a068dc67129c918622d48104d86a954"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a6a068dc67129c918622d48104d86a954">operator==</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a6a068dc67129c918622d48104d86a954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a5fc58ed5ee423669eba72860b5a39"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a14a5fc58ed5ee423669eba72860b5a39"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a14a5fc58ed5ee423669eba72860b5a39">operator==</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a14a5fc58ed5ee423669eba72860b5a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70c62e45b922606e1b3923ac5031bcb"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab70c62e45b922606e1b3923ac5031bcb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#ab70c62e45b922606e1b3923ac5031bcb">operator==</a> (const char *lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:ab70c62e45b922606e1b3923ac5031bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfef07771d1fec568a07697a45a5b4c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:accfef07771d1fec568a07697a45a5b4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#accfef07771d1fec568a07697a45a5b4c">operator==</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:accfef07771d1fec568a07697a45a5b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394c98c068855b6ea7a914529f391c5d"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a394c98c068855b6ea7a914529f391c5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a394c98c068855b6ea7a914529f391c5d">operator&gt;</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a394c98c068855b6ea7a914529f391c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two views <code>lhs</code> and <code>rhs</code>.  <a href="namespacerttr.html#a394c98c068855b6ea7a914529f391c5d">More...</a><br /></td></tr>
<tr class="separator:a394c98c068855b6ea7a914529f391c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a273b89f74476b16f3669309338c08"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a63a273b89f74476b16f3669309338c08"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a63a273b89f74476b16f3669309338c08">operator&gt;</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a63a273b89f74476b16f3669309338c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb63d24f286b18dfe28be8cfbbfe6c3d"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:adb63d24f286b18dfe28be8cfbbfe6c3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#adb63d24f286b18dfe28be8cfbbfe6c3d">operator&gt;</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:adb63d24f286b18dfe28be8cfbbfe6c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669c240442ffb53fb2f4b2d2a4f13b52"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a669c240442ffb53fb2f4b2d2a4f13b52"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a669c240442ffb53fb2f4b2d2a4f13b52">operator&gt;</a> (const char *lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:a669c240442ffb53fb2f4b2d2a4f13b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf49fa1202825cded8ab7d590bdb090"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aedf49fa1202825cded8ab7d590bdb090"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#aedf49fa1202825cded8ab7d590bdb090">operator&gt;</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:aedf49fa1202825cded8ab7d590bdb090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed1e6b0a98459fa540d4578bfafb266"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a8ed1e6b0a98459fa540d4578bfafb266"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a8ed1e6b0a98459fa540d4578bfafb266">operator&gt;=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a8ed1e6b0a98459fa540d4578bfafb266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two views <code>lhs</code> and <code>rhs</code>.  <a href="namespacerttr.html#a8ed1e6b0a98459fa540d4578bfafb266">More...</a><br /></td></tr>
<tr class="separator:a8ed1e6b0a98459fa540d4578bfafb266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff3a94648e92422b7d698e3c5b44b57"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:afff3a94648e92422b7d698e3c5b44b57"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#afff3a94648e92422b7d698e3c5b44b57">operator&gt;=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:afff3a94648e92422b7d698e3c5b44b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea15d353ad803a62d9a56315218f4d12"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aea15d353ad803a62d9a56315218f4d12"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#aea15d353ad803a62d9a56315218f4d12">operator&gt;=</a> (<a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aea15d353ad803a62d9a56315218f4d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aca74e9c529a8160c95c91d7350fa85"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a8aca74e9c529a8160c95c91d7350fa85"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a8aca74e9c529a8160c95c91d7350fa85">operator&gt;=</a> (const char *lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:a8aca74e9c529a8160c95c91d7350fa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65177c7143b2695b7507fcf84ff209eb"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a65177c7143b2695b7507fcf84ff209eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a65177c7143b2695b7507fcf84ff209eb">operator&gt;=</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="separator:a65177c7143b2695b7507fcf84ff209eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab708b3893cbd5a10e8782f3825052ea6"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs&gt; </td></tr>
<tr class="memitem:ab708b3893cbd5a10e8782f3825052ea6"><td class="memTemplItemLeft" align="right" valign="top">detail::parameter_names&lt; detail::decay_t&lt; TArgs &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#ab708b3893cbd5a10e8782f3825052ea6">parameter_names</a> (TArgs &amp;&amp;...args)</td></tr>
<tr class="memdesc:ab708b3893cbd5a10e8782f3825052ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacerttr.html#ab708b3893cbd5a10e8782f3825052ea6">parameter_names</a> function should be used add human-readable names of the parameters, for <a class="el" href="classrttr_1_1constructor.html">constructors</a> or a <a class="el" href="classrttr_1_1method.html">methods</a> during the registration process of reflection information.  <a href="namespacerttr.html#ab708b3893cbd5a10e8782f3825052ea6">More...</a><br /></td></tr>
<tr class="separator:ab708b3893cbd5a10e8782f3825052ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dd8b62e5ddca4c1d57cc572ba6bb81"><td class="memTemplParams" colspan="2">template&lt;typename Target_Type , typename Source_Type &gt; </td></tr>
<tr class="memitem:ab3dd8b62e5ddca4c1d57cc572ba6bb81"><td class="memTemplItemLeft" align="right" valign="top">Target_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#ab3dd8b62e5ddca4c1d57cc572ba6bb81">rttr_cast</a> (Source_Type object) noexcept</td></tr>
<tr class="memdesc:ab3dd8b62e5ddca4c1d57cc572ba6bb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the given <code>object</code> of type <code>Source_Type</code> to an object of type <code>Target_Type</code>.  <a href="namespacerttr.html#ab3dd8b62e5ddca4c1d57cc572ba6bb81">More...</a><br /></td></tr>
<tr class="separator:ab3dd8b62e5ddca4c1d57cc572ba6bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3f8702a5c01a032921b5400dcf3a36"><td class="memTemplParams" colspan="2">template&lt;typename ClassType , typename ReturnType , typename... Args&gt; </td></tr>
<tr class="memitem:a8f3f8702a5c01a032921b5400dcf3a36"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a8f3f8702a5c01a032921b5400dcf3a36">select_const</a> (ReturnType(ClassType::*func)(Args...) const noexcept) -&gt; decltype(func)</td></tr>
<tr class="memdesc:a8f3f8702a5c01a032921b5400dcf3a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code>noexcept</code> function type.  <a href="namespacerttr.html#a8f3f8702a5c01a032921b5400dcf3a36">More...</a><br /></td></tr>
<tr class="separator:a8f3f8702a5c01a032921b5400dcf3a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ab25763f38e207fba4461aeb307e4b"><td class="memTemplParams" colspan="2">template&lt;typename ClassType , typename ReturnType , typename... Args&gt; </td></tr>
<tr class="memitem:ab5ab25763f38e207fba4461aeb307e4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#ab5ab25763f38e207fba4461aeb307e4b">select_const</a> (ReturnType(ClassType::*func)(Args...) const) -&gt; decltype(func)</td></tr>
<tr class="memdesc:ab5ab25763f38e207fba4461aeb307e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function to register overloaded const member functions.  <a href="namespacerttr.html#ab5ab25763f38e207fba4461aeb307e4b">More...</a><br /></td></tr>
<tr class="separator:ab5ab25763f38e207fba4461aeb307e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f220ed51f07da6f29d5ab9a121f04"><td class="memTemplParams" colspan="2">template&lt;typename ClassType , typename ReturnType , typename... Args&gt; </td></tr>
<tr class="memitem:a824f220ed51f07da6f29d5ab9a121f04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a824f220ed51f07da6f29d5ab9a121f04">select_non_const</a> (ReturnType(ClassType::*func)(Args...) noexcept) -&gt; decltype(func)</td></tr>
<tr class="memdesc:a824f220ed51f07da6f29d5ab9a121f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code>noexcept</code> function type.  <a href="namespacerttr.html#a824f220ed51f07da6f29d5ab9a121f04">More...</a><br /></td></tr>
<tr class="separator:a824f220ed51f07da6f29d5ab9a121f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fe0add56b55e3ef993783060346d97"><td class="memTemplParams" colspan="2">template&lt;typename ClassType , typename ReturnType , typename... Args&gt; </td></tr>
<tr class="memitem:ac2fe0add56b55e3ef993783060346d97"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#ac2fe0add56b55e3ef993783060346d97">select_non_const</a> (ReturnType(ClassType::*func)(Args...)) -&gt; decltype(func)</td></tr>
<tr class="memdesc:ac2fe0add56b55e3ef993783060346d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function to register overloaded const member functions.  <a href="namespacerttr.html#ac2fe0add56b55e3ef993783060346d97">More...</a><br /></td></tr>
<tr class="separator:ac2fe0add56b55e3ef993783060346d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1582d7d5b803f7dd5498a4a0166d382d"><td class="memTemplParams" colspan="2">template&lt;typename Signature &gt; </td></tr>
<tr class="memitem:a1582d7d5b803f7dd5498a4a0166d382d"><td class="memTemplItemLeft" align="right" valign="top">Signature *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a1582d7d5b803f7dd5498a4a0166d382d">select_overload</a> (Signature *func)</td></tr>
<tr class="memdesc:a1582d7d5b803f7dd5498a4a0166d382d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function to register overloaded functions.  <a href="namespacerttr.html#a1582d7d5b803f7dd5498a4a0166d382d">More...</a><br /></td></tr>
<tr class="separator:a1582d7d5b803f7dd5498a4a0166d382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798f2d741400e53a74df3c80c4c0c887"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename ClassType &gt; </td></tr>
<tr class="memitem:a798f2d741400e53a74df3c80c4c0c887"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a798f2d741400e53a74df3c80c4c0c887">select_overload</a> (Signature(ClassType::*func)) -&gt; decltype(func)</td></tr>
<tr class="memdesc:a798f2d741400e53a74df3c80c4c0c887"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function to register overloaded member functions.  <a href="namespacerttr.html#a798f2d741400e53a74df3c80c4c0c887">More...</a><br /></td></tr>
<tr class="separator:a798f2d741400e53a74df3c80c4c0c887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ecd8bad715cbc451e7aa8491667d4a"><td class="memTemplParams" colspan="2">template&lt;typename Enum_Type &gt; </td></tr>
<tr class="memitem:a54ecd8bad715cbc451e7aa8491667d4a"><td class="memTemplItemLeft" align="right" valign="top">detail::enum_data&lt; Enum_Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>, Enum_Type value)</td></tr>
<tr class="memdesc:a54ecd8bad715cbc451e7aa8491667d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> function should be used to add a mapping from enum <code>name</code> to <code>value</code> during the registration process of reflection information.  <a href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">More...</a><br /></td></tr>
<tr class="separator:a54ecd8bad715cbc451e7aa8491667d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061fa22f1348eefc697cbeff24bafbc4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a061fa22f1348eefc697cbeff24bafbc4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a061fa22f1348eefc697cbeff24bafbc4">variant_cast</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;operand)</td></tr>
<tr class="memdesc:a061fa22f1348eefc697cbeff24bafbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the containing value as type <code>T</code>.  <a href="namespacerttr.html#a061fa22f1348eefc697cbeff24bafbc4">More...</a><br /></td></tr>
<tr class="separator:a061fa22f1348eefc697cbeff24bafbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0c189ce987128016854256825165c9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e0c189ce987128016854256825165c9"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a6e0c189ce987128016854256825165c9">variant_cast</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> *operand) noexcept</td></tr>
<tr class="memdesc:a6e0c189ce987128016854256825165c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the containing value with type <code>T</code>.  <a href="namespacerttr.html#a6e0c189ce987128016854256825165c9">More...</a><br /></td></tr>
<tr class="separator:a6e0c189ce987128016854256825165c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856595e05d78f5054d162ca055600df6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a856595e05d78f5054d162ca055600df6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a856595e05d78f5054d162ca055600df6">variant_cast</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&amp;operand)</td></tr>
<tr class="memdesc:a856595e05d78f5054d162ca055600df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the containing value from the variant into a type <code>T</code>.  <a href="namespacerttr.html#a856595e05d78f5054d162ca055600df6">More...</a><br /></td></tr>
<tr class="separator:a856595e05d78f5054d162ca055600df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899d3ccedf71a8dcd26573f36c76fe99"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a899d3ccedf71a8dcd26573f36c76fe99"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a899d3ccedf71a8dcd26573f36c76fe99">variant_cast</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> &amp;operand)</td></tr>
<tr class="memdesc:a899d3ccedf71a8dcd26573f36c76fe99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the containing value as type <code>T</code>.  <a href="namespacerttr.html#a899d3ccedf71a8dcd26573f36c76fe99">More...</a><br /></td></tr>
<tr class="separator:a899d3ccedf71a8dcd26573f36c76fe99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9979533caff6531bb4e2055fb4feb731"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9979533caff6531bb4e2055fb4feb731"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerttr.html#a9979533caff6531bb4e2055fb4feb731">variant_cast</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> *operand) noexcept</td></tr>
<tr class="memdesc:a9979533caff6531bb4e2055fb4feb731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the containing value with type <code>T</code>.  <a href="namespacerttr.html#a9979533caff6531bb4e2055fb4feb731">More...</a><br /></td></tr>
<tr class="separator:a9979533caff6531bb4e2055fb4feb731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a61265f69675ac438ecfa23b084adaa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61265f69675ac438ecfa23b084adaa56">&#9670;&nbsp;</a></span>string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">rttr::string_view</a> = typedef <a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A class to hold a reference to a continuous sequence of <code>char</code> objects. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa07db0e4984d0c48adc5d61f834d611b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07db0e4984d0c48adc5d61f834d611b">&#9670;&nbsp;</a></span>access_levels</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">rttr::access_levels</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">access_levels</a> enum represents the three access modifiers, which can be used in classes to encapsulate members access. </p>
<p>In contrast to the three static type values in the <a class="el" href="classrttr_1_1registration.html#a45df26a4b45b6715ac17e9a03594c369">registration</a> class, represents this enum the return value to retrieve the access level at runtime.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1method.html#ad77b3825aa9e8378d5e05f7fafe01525">method::get_access_level()</a>, <a class="el" href="classrttr_1_1property.html#ae3d36f39f60d0aca13d4c6b039799c7d">property::get_access_level()</a>, <a class="el" href="classrttr_1_1constructor.html#acccb0f27a9d2e4beef2788c4b95baf20">constructor::get_access_level()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa07db0e4984d0c48adc5d61f834d611ba84807fec67699af41c7bcb3a57dce40b"></a>public_access&#160;</td><td class="fielddoc"><p>Declares that this member was registered with <code>public</code> access. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa07db0e4984d0c48adc5d61f834d611ba2a680ba924878f265e7babc8b99edeb5"></a>protected_access&#160;</td><td class="fielddoc"><p>Declares that this member was registered with <code>protected</code> access. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa07db0e4984d0c48adc5d61f834d611bac660fa8edf326cb81471f80104953e47"></a>private_access&#160;</td><td class="fielddoc"><p>Declares that this member was registered with <code>private</code> access. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5b3814ecb941ae0fe288c8d67703ced7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3814ecb941ae0fe288c8d67703ced7">&#9670;&nbsp;</a></span>filter_item</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">rttr::filter_item</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">filter_item</a> enum is used to filter the search for certain members in <a class="el" href="classrttr_1_1type.html">types</a>. </p>
<p>Combine the enum value together with the bitwise OR operator.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to get a return, you must specify <b><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f" title="Includes all members in the search, which needs an instance to be invoked.">filter_item::instance_item</a></b> or <b><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d" title="Includes all static members in the search.">filter_item::static_item</a></b> along with an accessor <b><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b" title="Includes all public specified members in the search.">filter_item::public_access</a></b> or <b><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32" title="Includes all non public (private or protected) members in the search.">filter_item::non_public_access</a></b>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#ad77289c46150e0be761bc2168a56e2ae">type::get_properties(filter_items) const</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f"></a>instance_item&#160;</td><td class="fielddoc"><p>Includes all members in the search, which needs an instance to be invoked. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d"></a>static_item&#160;</td><td class="fielddoc"><p>Includes all static members in the search. </p>
<p>Static members doesn't need any instance for invoking. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b"></a>public_access&#160;</td><td class="fielddoc"><p>Includes all public specified members in the search. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b" title="The access_levels enum represents the three access modifiers, which can be used in classes to encapsu...">access_levels</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32"></a>non_public_access&#160;</td><td class="fielddoc"><p>Includes all non public (<em>private</em> or <em>protected</em>) members in the search. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b" title="The access_levels enum represents the three access modifiers, which can be used in classes to encapsu...">access_levels</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da"></a>declared_only&#160;</td><td class="fielddoc"><p>Returns all members declared for the current type; inherited members are not returned. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afdaed4515c436b34b8e24af714a09c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaed4515c436b34b8e24af714a09c64">&#9670;&nbsp;</a></span>default_arguments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::default_args&lt;TArgs...&gt; rttr::default_arguments </td>
          <td>(</td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> function should be used add default arguments, for <a class="el" href="classrttr_1_1constructor.html">constructors</a> or a <a class="el" href="classrttr_1_1method.html">methods</a> during the registration process of reflection information. </p>
<p>Use it in the <code>()</code> operator of the returned bind object.</p>
<p>The given arguments must match the signature from the starting position to the right most argument.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_function(<span class="keywordtype">int</span> a, <span class="keywordtype">bool</span> b, <span class="keyword">const</span> std::string&amp; text);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classrttr_1_1registration.html#ae37c7b97c7b6cc20d88d34d8aa26e12b">registration::method</a>(<span class="stringliteral">&quot;my_function&quot;</span>, &amp;my_function)</div>
<div class="line">    (</div>
<div class="line">        <a class="code" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a>(<span class="keyword">true</span>, std::string(<span class="stringliteral">&quot;default text&quot;</span>))</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// however setting default arguments like this, will raise a compile time error</span></div>
<div class="line">    <a class="code" href="classrttr_1_1registration.html#ae37c7b97c7b6cc20d88d34d8aa26e12b">registration::method</a>(<span class="stringliteral">&quot;my_function2&quot;</span>, &amp;my_function)</div>
<div class="line">    (</div>
<div class="line">         <a class="code" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a>(<span class="keyword">true</span>) <span class="comment">// does not work!!!; default value for the last argument is missing...</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2cd2b848b4d218241a8b6e8f7cdbeb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd2b848b4d218241a8b6e8f7cdbeb93">&#9670;&nbsp;</a></span>metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::metadata rttr::metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="namespacerttr.html#a2cd2b848b4d218241a8b6e8f7cdbeb93">metadata</a> function can be used to add additional meta data information during the registration process of reflection information. </p>
<p>Use it in the <code>()</code> operator of the returned bind object. </p>

</div>
</div>
<a id="a0abd793e9a1346ca80ca4783b7460685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abd793e9a1346ca80ca4783b7460685">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two views <code>lhs</code> and <code>rhs</code>. </p>
<p>Two views are not equal if the size() differ or the characters of <code>lhs</code> are not equivalent and in the same position in <code>rhs</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when both views are <b>not</b> the same, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a69d8d40085ba97ccb6fc88814c0c8b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d8d40085ba97ccb6fc88814c0c8b47">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a583618e87cd4e9f780934248754a2ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583618e87cd4e9f780934248754a2ba4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fde7d28377d122dc39bcb9b7ad2b1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fde7d28377d122dc39bcb9b7ad2b1fe">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83f8b8f2eccc4ec22a6a188a3661701e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f8b8f2eccc4ec22a6a188a3661701e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33c3420c543216c1544456be71e30869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c3420c543216c1544456be71e30869">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;CharT, Traits&gt; rttr::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae11ff54066618c4fed339975c5570aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11ff54066618c4fed339975c5570aa8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;CharT, Traits&gt; rttr::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a190ef645ecf8c0d0f0cc281cb0c3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a190ef645ecf8c0d0f0cc281cb0c3e1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;CharT, Traits&gt; rttr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a932b2ea821dffaf8ae5a8264694df8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932b2ea821dffaf8ae5a8264694df8ca">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;CharT, Traits&gt; rttr::operator+ </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8f898015327841d2862726e29ea6af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f898015327841d2862726e29ea6af4">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two views <code>lhs</code> and <code>rhs</code>. </p>
<p>The ordering comparisons is done lexicographically. The comparison is performed by a function equivalent to <code>std::lexicographical_compare</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when lhs is smaller than <code>rhs</code>, otherwise false. </dd></dl>

</div>
</div>
<a id="a0436d4ed4f29f452c0102b01961e033b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0436d4ed4f29f452c0102b01961e033b">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0814fb707205323e46e021965f5b6467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0814fb707205323e46e021965f5b6467">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37a537d9a01f979fa046f7d1cbbf3cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a537d9a01f979fa046f7d1cbbf3cfc">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afefad3fbe367d9b94fbb7c3dac737c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefad3fbe367d9b94fbb7c3dac737c22">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2079d606e33ce6fb3d46351e7806b8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2079d606e33ce6fb3d46351e7806b8e5">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharT, Traits&gt;&amp; rttr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a stream output on a <a class="el" href="classrttr_1_1basic__string__view.html" title="The class template basic_string_view describes an non-owning reference to a constant contiguous seque...">basic_string_view</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

</div>
</div>
<a id="a031dfd0b213dcb2128d8cdf9b32ae573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031dfd0b213dcb2128d8cdf9b32ae573">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two views <code>lhs</code> and <code>rhs</code>. </p>
<p>The ordering comparisons is done lexicographically. The comparison is performed by a function equivalent to <code>std::lexicographical_compare</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when lhs is smaller or equal to <code>rhs</code>, otherwise false. </dd></dl>

</div>
</div>
<a id="a96568e5a10c8cab6ae94227951ca8165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96568e5a10c8cab6ae94227951ca8165">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab41278e01f38cba2efd6adb40c4ea5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41278e01f38cba2efd6adb40c4ea5d7">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0decbe50db05fb1696af289bd1d5d594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0decbe50db05fb1696af289bd1d5d594">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f027b305cc60359fe8a6ca9e78216e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f027b305cc60359fe8a6ca9e78216e6">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a12343f43cbacffc32270264c6d57c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a12343f43cbacffc32270264c6d57c9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two views <code>lhs</code> and <code>rhs</code>. </p>
<p>Two views are equal if both the size() of <code>lhs</code> and <code>rhs</code> are equal and each character in <code>lhs</code> has an equivalent character in <code>rhs</code> at the same position.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when both views are the same, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a6a068dc67129c918622d48104d86a954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a068dc67129c918622d48104d86a954">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14a5fc58ed5ee423669eba72860b5a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a5fc58ed5ee423669eba72860b5a39">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab70c62e45b922606e1b3923ac5031bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70c62e45b922606e1b3923ac5031bcb">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accfef07771d1fec568a07697a45a5b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfef07771d1fec568a07697a45a5b4c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a394c98c068855b6ea7a914529f391c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394c98c068855b6ea7a914529f391c5d">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two views <code>lhs</code> and <code>rhs</code>. </p>
<p>The ordering comparisons is done lexicographically. The comparison is performed by a function equivalent to <code>std::lexicographical_compare</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when lhs is greater than <code>rhs</code>, otherwise false. </dd></dl>

</div>
</div>
<a id="a63a273b89f74476b16f3669309338c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a273b89f74476b16f3669309338c08">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb63d24f286b18dfe28be8cfbbfe6c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb63d24f286b18dfe28be8cfbbfe6c3d">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a669c240442ffb53fb2f4b2d2a4f13b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669c240442ffb53fb2f4b2d2a4f13b52">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedf49fa1202825cded8ab7d590bdb090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf49fa1202825cded8ab7d590bdb090">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ed1e6b0a98459fa540d4578bfafb266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed1e6b0a98459fa540d4578bfafb266">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two views <code>lhs</code> and <code>rhs</code>. </p>
<p>The ordering comparisons is done lexicographically. The comparison is performed by a function equivalent to <code>std::lexicographical_compare</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when lhs is greater or equal to <code>rhs</code>, otherwise false. </dd></dl>

</div>
</div>
<a id="afff3a94648e92422b7d698e3c5b44b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff3a94648e92422b7d698e3c5b44b57">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea15d353ad803a62d9a56315218f4d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea15d353ad803a62d9a56315218f4d12">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aca74e9c529a8160c95c91d7350fa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aca74e9c529a8160c95c91d7350fa85">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65177c7143b2695b7507fcf84ff209eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65177c7143b2695b7507fcf84ff209eb">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool rttr::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab708b3893cbd5a10e8782f3825052ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab708b3893cbd5a10e8782f3825052ea6">&#9670;&nbsp;</a></span>parameter_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::parameter_names&lt;detail::decay_t&lt;TArgs&gt;...&gt; rttr::parameter_names </td>
          <td>(</td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="namespacerttr.html#ab708b3893cbd5a10e8782f3825052ea6">parameter_names</a> function should be used add human-readable names of the parameters, for <a class="el" href="classrttr_1_1constructor.html">constructors</a> or a <a class="el" href="classrttr_1_1method.html">methods</a> during the registration process of reflection information. </p>
<p>Use it in the <code>()</code> operator of the returned bind object.</p>
<p>The names must be provided as string literals (i.e. const char*) arguments.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> set_window_geometry(<span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h) {...}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration.html#ae37c7b97c7b6cc20d88d34d8aa26e12b">registration::method</a>(<span class="stringliteral">&quot;set_window_geometry&quot;</span>, &amp;set_window_geometry)</div>
<div class="line">     (</div>
<div class="line">         <a class="code" href="namespacerttr.html#ab708b3893cbd5a10e8782f3825052ea6">parameter_names</a>(<span class="stringliteral">&quot;window name&quot;</span>, <span class="stringliteral">&quot;width&quot;</span>, <span class="stringliteral">&quot;height&quot;</span>)</div>
<div class="line">     );</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a> </dd></dl>

</div>
</div>
<a id="ab3dd8b62e5ddca4c1d57cc572ba6bb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3dd8b62e5ddca4c1d57cc572ba6bb81">&#9670;&nbsp;</a></span>rttr_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target_Type , typename Source_Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Target_Type rttr::rttr_cast </td>
          <td>(</td>
          <td class="paramtype">Source_Type&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the given <code>object</code> of type <code>Source_Type</code> to an object of type <code>Target_Type</code>. </p>
<p>When the given the given <code>object</code> is an instance of type <code>Target_Type</code>, then this function will cast the pointer to the <code>TargetType</code>; otherwise it will return a <code>nullptr</code>. If <code>object</code> is already a <code>nullptr</code> then it will also return a <code>nullptr</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Both class types must contain the macro <a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a> in the class declaration. <code>Source_Type</code> and <code>Target_Type</code> must be both pointer types.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer of type <code>Target_Type</code> </dd></dl>

</div>
</div>
<a id="a8f3f8702a5c01a032921b5400dcf3a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3f8702a5c01a032921b5400dcf3a36">&#9670;&nbsp;</a></span>select_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ClassType , typename ReturnType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rttr::select_const </td>
          <td>(</td>
          <td class="paramtype">ReturnType(ClassType::*)(Args...) const noexcept&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt; decltype(func)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload with <code>noexcept</code> function type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerttr.html#ab5ab25763f38e207fba4461aeb307e4b" title="This is a helper function to register overloaded const member functions.">select_const</a> </dd></dl>

</div>
</div>
<a id="ab5ab25763f38e207fba4461aeb307e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ab25763f38e207fba4461aeb307e4b">&#9670;&nbsp;</a></span>select_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ClassType , typename ReturnType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rttr::select_const </td>
          <td>(</td>
          <td class="paramtype">ReturnType(ClassType::*)(Args...) const&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt; decltype(func)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function to register overloaded const member functions. </p>
<p>Use it like following: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> func() {}</div>
<div class="line">  <span class="keywordtype">void</span> func()<span class="keyword"> const </span>{}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .<a class="code" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">method</a>(<span class="stringliteral">&quot;func&quot;</span>, <a class="code" href="namespacerttr.html#ac2fe0add56b55e3ef993783060346d97">select_non_const</a>(&amp;Foo::func))</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <a class="code" href="namespacerttr.html#ab5ab25763f38e207fba4461aeb307e4b">select_const</a>(&amp;Foo::func));</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The method <b>cannot</b> be used with <em>MSVC x86</em> compiler, because of the different calling convention for global- and member-functions. As workaround you have to explicitly cast to the member function pointer:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     registration::class_&lt;Foo&gt;(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>(Foo::*)()<span class="keyword">&gt;</span>(&amp;Foo::func))</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>(Foo::*)()const<span class="keyword">&gt;</span>(&amp;Foo::func));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a824f220ed51f07da6f29d5ab9a121f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824f220ed51f07da6f29d5ab9a121f04">&#9670;&nbsp;</a></span>select_non_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ClassType , typename ReturnType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rttr::select_non_const </td>
          <td>(</td>
          <td class="paramtype">ReturnType(ClassType::*)(Args...) noexcept&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt; decltype(func)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload with <code>noexcept</code> function type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerttr.html#ab5ab25763f38e207fba4461aeb307e4b" title="This is a helper function to register overloaded const member functions.">select_const</a> </dd></dl>

</div>
</div>
<a id="ac2fe0add56b55e3ef993783060346d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fe0add56b55e3ef993783060346d97">&#9670;&nbsp;</a></span>select_non_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ClassType , typename ReturnType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rttr::select_non_const </td>
          <td>(</td>
          <td class="paramtype">ReturnType(ClassType::*)(Args...)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt; decltype(func)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function to register overloaded const member functions. </p>
<p>Use it like following: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> func() {}</div>
<div class="line">  <span class="keywordtype">void</span> func()<span class="keyword"> const </span>{}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     registration::class&lt;Foo&gt;(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <a class="code" href="namespacerttr.html#ac2fe0add56b55e3ef993783060346d97">select_non_const</a>(&amp;Foo::func))</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <a class="code" href="namespacerttr.html#ab5ab25763f38e207fba4461aeb307e4b">select_const</a>(&amp;Foo::func));</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The method <b>cannot</b> be used with <em>MSVC x86</em> compiler, because of the different calling convention for global- and member-functions. As workaround you have to explicitly cast to the member function pointer:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     registration::class_&lt;Foo&gt;(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>(Foo::*)()<span class="keyword">&gt;</span>(&amp;Foo::func))</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>(Foo::*)()const<span class="keyword">&gt;</span>(&amp;Foo::func));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1582d7d5b803f7dd5498a4a0166d382d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1582d7d5b803f7dd5498a4a0166d382d">&#9670;&nbsp;</a></span>select_overload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Signature* rttr::select_overload </td>
          <td>(</td>
          <td class="paramtype">Signature *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function to register overloaded functions. </p>
<p>Use it like following: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration.html#ae37c7b97c7b6cc20d88d34d8aa26e12b">registration::method</a>(<span class="stringliteral">&quot;pow&quot;</span>, <a class="code" href="namespacerttr.html#a1582d7d5b803f7dd5498a4a0166d382d">select_overload</a>&lt;<span class="keywordtype">float</span>(<span class="keywordtype">float</span>, <span class="keywordtype">float</span>)&gt;(&amp;pow));</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The method <b>cannot</b> be used with <em>MSVC x86</em> compiler, because of the different calling convention for global- and member-functions. As workaround you have to explicitly cast to the function pointer:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration.html#ae37c7b97c7b6cc20d88d34d8aa26e12b">registration::method</a>(<span class="stringliteral">&quot;pow&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span>(*)(<span class="keywordtype">float</span>, <span class="keywordtype">float</span>)<span class="keyword">&gt;</span>(&amp;pow));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a798f2d741400e53a74df3c80c4c0c887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798f2d741400e53a74df3c80c4c0c887">&#9670;&nbsp;</a></span>select_overload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename ClassType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rttr::select_overload </td>
          <td>(</td>
          <td class="paramtype">Signature ClassType::*&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> -&gt; decltype(func)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function to register overloaded member functions. </p>
<p>Use it like following: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> func(<span class="keywordtype">int</span>) {}</div>
<div class="line">  <span class="keywordtype">void</span> func(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .<a class="code" href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">method</a>(<span class="stringliteral">&quot;func&quot;</span>, <a class="code" href="namespacerttr.html#a1582d7d5b803f7dd5498a4a0166d382d">select_overload</a>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">int</span>)&gt;(&amp;Foo::func))</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <a class="code" href="namespacerttr.html#a1582d7d5b803f7dd5498a4a0166d382d">select_overload</a>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)&gt;(&amp;Foo::func));</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The method <b>cannot</b> be used with <em>MSVC x86</em> compiler, because of the different calling convention for global- and member-functions. As workaround you have to explicitly cast to the member function pointer:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     registration::class_&lt;Foo&gt;(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>(Foo::*)(<span class="keywordtype">int</span>)<span class="keyword">&gt;</span>(&amp;Foo::func))</div>
<div class="line">                  .method(<span class="stringliteral">&quot;func&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>(Foo::*)(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)<span class="keyword">&gt;</span>(&amp;Foo::func));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a54ecd8bad715cbc451e7aa8491667d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ecd8bad715cbc451e7aa8491667d4a">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::enum_data&lt;Enum_Type&gt; rttr::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Enum_Type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> function should be used to add a mapping from enum <code>name</code> to <code>value</code> during the registration process of reflection information. </p>
<p>Use it in the <code>()</code> operator of the returned bind object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1registration.html#ae185f4e001154c4d95a3901bcbd6e234">registration::enumeration</a> </dd></dl>

</div>
</div>
<a id="a061fa22f1348eefc697cbeff24bafbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061fa22f1348eefc697cbeff24bafbc4">&#9670;&nbsp;</a></span>variant_cast() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T rttr::variant_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the containing value as type <code>T</code>. </p>
<div class="fragment"><div class="line">variant var = std::string(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line">std:<span class="keywordtype">string</span>&amp; value_ref = variant_cast&lt;std::string&amp;&gt;(var);  <span class="comment">// extracts the value by reference</span></div>
<div class="line">std:<span class="keywordtype">string</span> <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> = variant_cast&lt;std::string&gt;(var);        <span class="comment">// copies the value</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Extracting a value type, which is not stored in the variant, leads to undefined behaviour. No exception or error code will be returned! </dd></dl>

</div>
</div>
<a id="a6e0c189ce987128016854256825165c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0c189ce987128016854256825165c9">&#9670;&nbsp;</a></span>variant_cast() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* rttr::variant_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> *&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the containing value with type <code>T</code>. </p>
<p>When the containing value is of type <code>T</code>, a valid pointer to the type will be returned. Otherwise a <code>nullptr</code> is returned.</p>
<div class="fragment"><div class="line">variant var = std::string(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line">std:<span class="keywordtype">string</span>* a = variant_cast&lt;std::string&gt;(&amp;var);  <span class="comment">// performs an internal type check and returns the value by reference</span></div>
<div class="line"><span class="keywordtype">int</span>* b        = variant_cast&lt;int&gt;(&amp;var);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;a valid: &quot;</span> &lt;&lt; a != <span class="keyword">nullptr</span> &lt;&lt; std::endl;  <span class="comment">// prints &quot;1&quot;</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;b valid: &quot;</span> &lt;&lt; b != <span class="keyword">nullptr</span> &lt;&lt; std::endl;  <span class="comment">// prints &quot;0&quot;</span></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A valid pointer, when the containing type is of type <code>T</code>; otherwise a <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a856595e05d78f5054d162ca055600df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856595e05d78f5054d162ca055600df6">&#9670;&nbsp;</a></span>variant_cast() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T rttr::variant_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the containing value from the variant into a type <code>T</code>. </p>
<div class="fragment"><div class="line">variant var = std::string(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line">std::string&amp; a = variant_cast&lt;std::string&amp;&gt;(var);</div>
<div class="line">std::string b = variant_cast&lt;std::string&gt;(std::move(var)); <span class="comment">// move the value to &#39;b&#39;</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// is now empty (nothing to print)</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// prints &quot;hello world&quot;</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Extracting a value type, which is not stored in the variant, leads to undefined behaviour. No exception or error code will be returned! </dd></dl>

</div>
</div>
<a id="a899d3ccedf71a8dcd26573f36c76fe99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899d3ccedf71a8dcd26573f36c76fe99">&#9670;&nbsp;</a></span>variant_cast() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T rttr::variant_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the containing value as type <code>T</code>. </p>
<div class="fragment"><div class="line">variant var = std::string(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line">std::string&amp; value_ref = variant_cast&lt;std::string&amp;&gt;(var);  <span class="comment">// extracts the value by reference</span></div>
<div class="line">std::string <a class="code" href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">value</a> = variant_cast&lt;std::string&gt;(var);        <span class="comment">// copies the value</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Extracting a value type, which is not stored in the variant, leads to undefined behaviour. No exception or error code will be returned! </dd></dl>

</div>
</div>
<a id="a9979533caff6531bb4e2055fb4feb731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9979533caff6531bb4e2055fb4feb731">&#9670;&nbsp;</a></span>variant_cast() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* rttr::variant_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> *&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the containing value with type <code>T</code>. </p>
<p>When the containing value is of type <code>T</code>, a valid pointer to the type will be returned. Otherwise a <code>nullptr</code> is returned.</p>
<div class="fragment"><div class="line">variant var = std::string(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line">std:<span class="keywordtype">string</span>* a = variant_cast&lt;std::string&gt;(&amp;var);  <span class="comment">// performs an internal type check and returns the value by reference</span></div>
<div class="line"><span class="keywordtype">int</span>* b        = variant_cast&lt;int&gt;(&amp;var);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;a valid: &quot;</span> &lt;&lt; a != <span class="keyword">nullptr</span> &lt;&lt; std::endl;  <span class="comment">// prints &quot;1&quot;</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;b valid: &quot;</span> &lt;&lt; b != <span class="keyword">nullptr</span> &lt;&lt; std::endl;  <span class="comment">// prints &quot;0&quot;</span></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A valid pointer, when the containing type is of type <code>T</code>; otherwise a <code>nullptr</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacerttr_html_ab708b3893cbd5a10e8782f3825052ea6"><div class="ttname"><a href="namespacerttr.html#ab708b3893cbd5a10e8782f3825052ea6">rttr::parameter_names</a></div><div class="ttdeci">detail::parameter_names&lt; detail::decay_t&lt; TArgs &gt;... &gt; parameter_names(TArgs &amp;&amp;...args)</div><div class="ttdoc">The parameter_names function should be used add human-readable names of the parameters,...</div></div>
<div class="ttc" id="anamespacerttr_html"><div class="ttname"><a href="namespacerttr.html">rttr</a></div><div class="ttdef"><b>Definition:</b> access_levels.h:33</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html_a8bbc90d48413ac8b5e172d9cc4e4019f"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html#a8bbc90d48413ac8b5e172d9cc4e4019f">rttr::registration::class_::method</a></div><div class="ttdeci">bind&lt; detail::meth, Class_Type, F, acc_level, Visitor_List &gt; method(string_view name, F f, acc_level level=acc_level())</div><div class="ttdoc">Register a method to this class.</div></div>
<div class="ttc" id="anamespacerttr_html_a54ecd8bad715cbc451e7aa8491667d4a"><div class="ttname"><a href="namespacerttr.html#a54ecd8bad715cbc451e7aa8491667d4a">rttr::value</a></div><div class="ttdeci">detail::enum_data&lt; Enum_Type &gt; value(string_view, Enum_Type value)</div><div class="ttdoc">The value function should be used to add a mapping from enum name to value during the registration pr...</div></div>
<div class="ttc" id="anamespacerttr_html_afdaed4515c436b34b8e24af714a09c64"><div class="ttname"><a href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">rttr::default_arguments</a></div><div class="ttdeci">detail::default_args&lt; TArgs... &gt; default_arguments(TArgs &amp;&amp;...args)</div><div class="ttdoc">The default_arguments function should be used add default arguments, for constructors or a methods du...</div></div>
<div class="ttc" id="aclassrttr_1_1registration_1_1class___html"><div class="ttname"><a href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_</a></div><div class="ttdoc">The class_ is used to register classes to RTTR.</div><div class="ttdef"><b>Definition:</b> registration.h:154</div></div>
<div class="ttc" id="aregistration_8h_html_ac6326400f16225ee15b52eabcaae8130"><div class="ttname"><a href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div><div class="ttdeci">#define RTTR_REGISTRATION</div><div class="ttdoc">Use this macro to automatically register your reflection information to RTTR before main is called.</div><div class="ttdef"><b>Definition:</b> registration.h:770</div></div>
<div class="ttc" id="anamespacerttr_html_ab5ab25763f38e207fba4461aeb307e4b"><div class="ttname"><a href="namespacerttr.html#ab5ab25763f38e207fba4461aeb307e4b">rttr::select_const</a></div><div class="ttdeci">auto select_const(ReturnType(ClassType::*func)(Args...) const) -&gt; decltype(func)</div><div class="ttdoc">This is a helper function to register overloaded const member functions.</div><div class="ttdef"><b>Definition:</b> registration.h:592</div></div>
<div class="ttc" id="anamespacerttr_html_a1582d7d5b803f7dd5498a4a0166d382d"><div class="ttname"><a href="namespacerttr.html#a1582d7d5b803f7dd5498a4a0166d382d">rttr::select_overload</a></div><div class="ttdeci">Signature * select_overload(Signature *func)</div><div class="ttdoc">This is a helper function to register overloaded functions.</div><div class="ttdef"><b>Definition:</b> registration.h:506</div></div>
<div class="ttc" id="anamespacerttr_html_ac2fe0add56b55e3ef993783060346d97"><div class="ttname"><a href="namespacerttr.html#ac2fe0add56b55e3ef993783060346d97">rttr::select_non_const</a></div><div class="ttdeci">auto select_non_const(ReturnType(ClassType::*func)(Args...)) -&gt; decltype(func)</div><div class="ttdoc">This is a helper function to register overloaded const member functions.</div><div class="ttdef"><b>Definition:</b> registration.h:647</div></div>
<div class="ttc" id="aclassrttr_1_1registration_html_ae37c7b97c7b6cc20d88d34d8aa26e12b"><div class="ttname"><a href="classrttr_1_1registration.html#ae37c7b97c7b6cc20d88d34d8aa26e12b">rttr::registration::method</a></div><div class="ttdeci">static bind&lt; detail::meth, detail::invalid_type, F, detail::public_access, Visitor_List &gt; method(string_view name, F f)</div><div class="ttdoc">Register a method to this class.</div></div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Mar 4 2020 09:24:05 for rttr - 0.9.7 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
